#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Based on Default.rbbi, the default RBBI rules, based on UAX#29.
# Added dashes to $MidLetter and $Midnum, so that words and identifiers aren't broken on single dashes.
#




#===============================================================
!!chain;
#===============================================================

#
#  Character Class Definitions.
#

$CR           = [\p{Word_Break = CR}];
$LF           = [\p{Word_Break = LF}];
$Newline      = [\p{Word_Break = Newline}];
$Extend       = [\p{Word_Break = Extend}];
$Format       = [\p{Word_Break = Format}];
$Katakana     = [\p{Word_Break = Katakana}];
# Don't use [:Dash:] here - it contains lots of chars that should continue to trigger word breaks
$Dash         = [\N{HYPHEN-MINUS}
                 \N{HYPHEN}
                 \N{EN DASH}
                 \N{MINUS SIGN}
                 \N{SMALL HYPHEN-MINUS}
                 \N{FULLWIDTH HYPHEN-MINUS}];
$ALetter      = [\p{Word_Break = ALetter}];
$MidNumLet    = [\p{Word_Break = MidNumLet}];
$MidLetter    = [\p{Word_Break = MidLetter}]; # Don't break letters on (single) hyphen
$MidNum       = [\p{Word_Break = MidNum}$Dash]; # Don't break numbers on (single) hyphen
$Numeric      = [\p{Word_Break = Numeric}[[:Decomposition_Type=Wide:]&[:General_Category=Decimal_Number:]]];
$ExtendNumLet = [\p{Word_Break = ExtendNumLet}];


#   Dictionary character set, for triggering language-based break engines. Currently
#   limited to LineBreak=Complex_Context. Note that this set only works in Unicode
#   5.0 or later as the definition of Complex_Context was corrected to include all
#   characters requiring dictionary break.

$dictionary   = [:LineBreak = Complex_Context:];
$Control        = [\p{Grapheme_Cluster_Break = Control}];
$ALetterPlus  = [$ALetter [$dictionary-$Extend-$Control]];   # Note:  default ALetter does not
                                                             #  include the dictionary characters.

#
#  Rules 4    Ignore Format and Extend characters,
#             except when they appear at the beginning of a region of text.
#
$KatakanaEx     = $Katakana     ($Extend |  $Format)*;
$ALetterEx      = $ALetterPlus  ($Extend |  $Format)*;
$MidNumLetEx    = $MidNumLet    ($Extend |  $Format)*;
$MidLetterEx    = $MidLetter    ($Extend |  $Format)*;
$MidNumEx       = $MidNum       ($Extend |  $Format)*;
$NumericEx      = $Numeric      ($Extend |  $Format)*;
$ExtendNumLetEx = $ExtendNumLet ($Extend |  $Format)*;

$Hiragana       = [\p{script=Hiragana}];
$Ideographic    = [\p{Ideographic}];
$HiraganaEx     = $Hiragana     ($Extend |  $Format)*;
$IdeographicEx  = $Ideographic  ($Extend |  $Format)*;


## -------------------------------------------------

##==================================================##
!!forward;
##==================================================##


# Rule 3 - CR x LF
#
$CR $LF;
# Rule 4 - ignore Format and Extend characters, except when they appear at the beginning
#          of a region of Text.   The rule here comes into play when the start of text
#          begins with a group of Format chars, or with a "word" consisting of a single
#          char that is not in any of the listed word break categories followed by
#          format char(s).
[^$CR $LF $Newline]? ($Extend |  $Format)+;



# ============= Custom Rules ================
# Numeric
# 12:30
#-----------------------------------------------
$Tir_Time=([0-9])+([\:])([0-9])+;

#-----------------------------------------------
# Negative Number
# This was bad for dates: 12-04-90
#-----------------------------------------------
#$Tir_Negative_Number=[\-]([0-9])+;


#-----------------------------------------------
# Tir_Percent
#-----------------------------------------------
$Tir_Percent=([0-9])+([\%]);

#-----------------------------------------------
# Money Expression
# $8,000
#-----------------------------------------------
$Tir_Money_Expression=([\$€£])([0-9\,\.])*([0-9])+([bnm])*;

$Tir_Money=([\$€£]);


#-----------------------------------------------
# Measure
# 300mg
#-----------------------------------------------
$Tir_Measure = ([0-9])+(m(c)?g(s)?);

#-----------------------------------------------
# Punctuation
#-----------------------------------------------
$Tir_Punct = [\:\/\!\|\•\>\®\*\+\=\-];
$Tir_Punct_Sent = [\.\;\?\…];
$Tir_Punct_Comma = [\,];
$Tir_Punct_Quote = [\"\'\“\”\’\‘\«\»];
$Tir_Punct_Open = [\(\{\[];
$Tir_Punct_Close = [\)\}\]];
$Tir_Hyphen = [—-];
$Tir_Colon = [\:];

#-----------------------------------------------
# For things like
# sh!t
#-----------------------------------------------
$Tir_Char_PlaceHolder = [\!\*];

#-----------------------------------------------
# Text Separators : ======= -------- /////////
#-----------------------------------------------
$Tir_Separators = [\=\-\/\#\*\+][\=\-\/\#\*\+][\=\-\/\#\*\+]([\=\-\/\#\*\+])+;

#-----------------------------------------------
# Text Suffix : c++ c#
#-----------------------------------------------
$Tir_Suffix = ([\+\#])+;


# ABBREVIATIONS -------------------------------------------------
# Acronyms:
# Uppercase alpha chars separated by period and optionally followed by a period
# $Abbreviation = [A-Z0-9](\.[A-Z0-9])+(\.)*;
$Abbreviation = ([A-Z0-9])+(\.)(([A-Z0-9])+(\.))+;
# Initials
# $Tir_Init = [\p{whitespace}][A-Z](\.);
# Common Abbbreviations
$Tir_Co = (Co\.);
$Tir_Corp = (Corp\.);
$Tir_Dr = (Dr\.);
$Tir_Inc = (Inc\.);
$Tir_Mr = (Mr\.);
$Tir_Mrs = (Mrs\.);
$Tir_Ms = (Ms\.);
$Tir_Nov = (Nov\.);
$Tir_St = (St\.);
$Tir_Phd = (Ph\.D);

#-----------------------------------------------
# Email address: sequence of letters, digits and punctuation followed by @ and followed by another sequence
#-----------------------------------------------
$EmailAddress = [A-Za-z0-9_\-\.]+\@[A-Za-z][A-Za-z0-9_\-]+\.[a-z]+(\.[a-z]+)?(\.[a-z]+)?;



# XML markup: A run begins with < and ends with the first matching >
$XmlMarkup = \<[^\>]+\>;


#===============================================================
# Custom - no chain
# Note to myself: to break a token, use \
# Note to myself: http://userguide.icu-project.org/boundaryanalysis#TOC-Forward-Reverse-Safe-Point-rules
#===============================================================

#-----------------------------------------------
# Saxon genitive: John 's
#-----------------------------------------------
$Tir_no_contraction = (ve|ll|d|re|m)([a-z])+;

#-----------------------------------------------
# Saxon genitive: John 's
#-----------------------------------------------
$Tir_Genitive = [\'\’]s;

# CONTRACTIONS -------------------------------------------------


# Negations
# ain’t
$Tir_aint = ((A|a)in)[\p{Quotation_Mark}]t;
# aren’t
$Tir_arent = ((A|a)ren)[\p{Quotation_Mark}]t;
# can't
$Tir_cant = ((c|C)an)[\p{Quotation_Mark}]t;
# couldn't
$Tir_couldnt = ((C|c)ouldn)[\p{Quotation_Mark}]t;
# doesn't
$Tir_doesnt = ((D|d)oesn)[\p{Quotation_Mark}]t;
# don't
$Tir_dont = ((D|d)on)[\p{Quotation_Mark}]t;
# didn't
$Tir_didnt = ((D|d)idn)[\p{Quotation_Mark}]t;
# hasn't
$Tir_hasnt = ((H|h)asn)[\p{Quotation_Mark}]t;
# haven't
$Tir_havent = ((H|h)aven)[\p{Quotation_Mark}]t;
# haven't
$Tir_hadnt = ((H|h)adn)[\p{Quotation_Mark}]t;
# isn't
$Tir_isnt = ((I|i)sn)[\p{Quotation_Mark}]t;
# shouldn't
$Tir_shouldnt = ((S|s)houldn)[\p{Quotation_Mark}]t;
# wasn't
$Tir_wasnt = ((W|w)asn)[\p{Quotation_Mark}]t;
# weren't
$Tir_werent = ((W|w)eren)[\p{Quotation_Mark}]t;
# won’t
$Tir_wont = ((W|w)on)[\p{Quotation_Mark}]t;
# wouldn’t
$Tir_wouldnt = ((W|w)ouldn)[\p{Quotation_Mark}]t;
#mustn’t
$Tir_mustnt = ((M|m)ustn)[\p{Quotation_Mark}]t;

$Tir_Proper = [A-Z]([\p{Lower}])+;
$Tir_Acron = ([A-Z])+;
$Tir_Dot_Acron = [A-Z](\.)([A-Z](\.))+;

# O'Connor
$Tir_Irish_Name = O[\'\’][A-Z]([a-z]|[ß-ü])+;

#-----------------------------------------------
# Internet Addresses: http://www.foo.com(/bar)
#-----------------------------------------------
$InternetAddress = http(s)?\:\/\/[a-z0-9]+(\.[a-z0-9]+)+(\/([A-Za-z0-9][A-Za-z0-9\.]+)?)*;

#-----------------------------------------------
# www.tdameritrade.com.
#-----------------------------------------------
$wwwAddress = www(\.[a-z0-9]+)+(\/([A-Za-z0-9][A-Za-z0-9\.]+)?)*;

#-----------------------------------------------
# Let's
#-----------------------------------------------
$Tir_lets = (let)[\'\’]s;




$NumericEx {100};
$ALetterEx {200};
$KatakanaEx {300};       # note:  these status values override those from rule 5
$HiraganaEx {300};       #        by virtual of being numerically larger.
$IdeographicEx {400};    #

#
# rule 5
#    Do not break between most letters.
#
$ALetterEx $ALetterEx {200};
#$ALetterEx ($MidLetterEx | $MidNumLetEx) $ALetterEx {200};
#$ALetterEx $MidLetterEx $ALetterEx {200};
$NumericEx $NumericEx {100};
$ALetterEx $NumericEx {200};
$NumericEx $ALetterEx {200};
$NumericEx ($MidNumEx | $MidNumLetEx) $NumericEx {100};
$KatakanaEx  $KatakanaEx {300};
$ALetterEx      $ExtendNumLetEx {200};    #  (13a)
$NumericEx      $ExtendNumLetEx {100};    #  (13a)
$KatakanaEx     $ExtendNumLetEx {300};    #  (13a)
$ExtendNumLetEx $ExtendNumLetEx {200};    #  (13a)
$ExtendNumLetEx $ALetterEx  {200};    #  (13b)
$ExtendNumLetEx $NumericEx  {100};    #  (13b)
$ExtendNumLetEx $KatakanaEx {300};    #  (13b)
$ALetterEx ($Tir_Char_PlaceHolder)+ $ALetterEx {200};
$ALetterEx $Tir_Suffix {610};


# Custom : WORD BREAKS
$EmailAddress / $Tir_Colon {520};
# Custom word breaks



# This is a trick to separate single quote from words like 'receive'
# sample: "They're 'receiving' food"
# keep 're together and 'receiving appart

# This is to split quotaion marks from the word 'receiving to ' receiving
[\p{Quotation_Mark}] / $Tir_no_contraction {200};

# As the rule above will split quotes followed by Tir no contraction, put these back together
# rule above : They're -> They ' re
# this rule They ' re  -> They 're
[\u0027|\u2018|\u2019] (re|ve|ll|d|m) {200};


$EmailAddress {520};
$InternetAddress {621};
$wwwAddress {621};


#Proper
$Tir_Proper {600};
$Tir_Irish_Name {600};
$Tir_Acron {600};
$Tir_Dot_Acron {600};

#Numeric
$Tir_Time {100};
#$Tir_Negative_Number {100};
$Tir_Percent {100};
$Tir_Measure {100};
# Change this eventually!
$Tir_Money {514};
$Tir_Money_Expression {514};

$Tir_Punct {500};
$Tir_Punct_Sent {501};
$Tir_Punct_Comma {502};
$Tir_Punct_Quote {503};
$Tir_Punct_Open {504};
$Tir_Punct_Close {505};
$Tir_Separators {500};
$Tir_Hyphen {500};


$Abbreviation {510};
$XmlMarkup {512};
$Tir_Genitive {513};

# Common Abbreviations
$Tir_Co {510};
$Tir_Corp {510};
$Tir_Nov {510};
$Tir_Mr {510};
$Tir_Mrs {510};
$Tir_Ms {510};
$Tir_Dr {510};
$Tir_Inc {510};
$Tir_St {510};
$Tir_Phd {510};


#Contractions
$Tir_aint {525};
$Tir_arent {525};
$Tir_cant {525};
$Tir_couldnt {525};
$Tir_doesnt {525};
$Tir_dont {525};
$Tir_didnt {525};
$Tir_hadnt {525};
$Tir_hasnt {525};
$Tir_havent {525};
$Tir_isnt {525};
$Tir_shouldnt {525};
$Tir_wasnt  {525};
$Tir_werent  {525};
$Tir_wont {525};
$Tir_wouldnt {525};
$Tir_mustnt {525};
$Tir_lets {525};


