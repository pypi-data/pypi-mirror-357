/**
 * @file SuperpositionOfAtomicPotentials.cpp
 *
 * @date   Aug 9, 2019
 * @author Jan Unsleber
 * @copyright \n
 *  This file is part of the program Serenity.\n\n
 *  Serenity is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of
 *  the License, or (at your option) any later version.\n\n
 *  Serenity is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.\n\n
 *  You should have received a copy of the GNU Lesser General
 *  Public License along with Serenity.
 *  If not, see <http://www.gnu.org/licenses/>.\n
 */

/* Include Class Header*/
#include "scf/initialGuess/SuperpositionOfAtomicPotentials.h"
/* Include Serenity Internal Headers */
#include "data/ElectronicStructure.h"
#include "data/OrbitalController.h"
#include "data/grid/BasisFunctionOnGridControllerFactory.h"
#include "data/grid/ScalarOperatorToMatrixAdder.h"
#include "geometry/Geometry.h"
#include "integrals/OneElectronIntegralController.h"
#include "math/Matrix.h"
#include "settings/Settings.h"
#include "system/SystemController.h"

namespace Serenity {

std::unique_ptr<ElectronicStructure<RESTRICTED>>
SuperpositionOfAtomicPotentials::calculateInitialGuess(const std::shared_ptr<SystemController> system) {
  // Get the small grid
  auto grid = system->getGridController(Options::GRID_PURPOSES::SMALL);
  const unsigned int nPoints = grid->getNGridPoints();

  // Get atom information
  auto geometry = system->getGeometry();
  const unsigned int nAtoms = geometry->getNAtoms();
  auto coords = geometry->getCoordinates();
  auto elements = geometry->getAtomSymbols();

  // Setup path to stored files
  std::string pathToGuessDensities;
  if (const char* env_p = std::getenv("SERENITY_RESOURCES")) {
    pathToGuessDensities = env_p;
  }
  else {
    throw SerenityError("ERROR Environment variable SERENITY_RESOURCES not set.");
  }
  pathToGuessDensities += "/initialGuess/potentials/NR_CAPX/";

  // Setup map for loaded potentials
  std::map<std::string, std::pair<std::vector<double>, std::vector<double>>> potentials;
  for (const auto& type : elements) {
    potentials[type] = std::pair<std::vector<double>, std::vector<double>>();
  }

  // Read all required potentials
  for (auto& x : potentials) {
    const auto& type = x.first;
    auto& potential = x.second;
    std::string line;
    std::ifstream file(pathToGuessDensities + "v_" + type + ".dat");
    while (getline(file, line)) {
      std::istringstream lineStream(line);
      double distance, value;
      lineStream >> distance >> value;
      potential.first.push_back(distance);
      potential.second.push_back(value);
    }
    file.close();
  }

  // Sum the potentials generated by each atom
  GridPotential<RESTRICTED> potential(grid);
  auto points = grid->getGridPoints();
  for (unsigned int atom = 0; atom < nAtoms; atom++) {
    const auto type = elements[atom];
    const auto& atomPot = potentials[type];
    const auto position = coords.row(atom);
#pragma omp for schedule(dynamic)
    for (unsigned int point = 0; point < nPoints; point++) {
      const double distance = (points.col(point).transpose() - position).norm();
      if (distance > atomPot.first.back()) {
        potential[point] += atomPot.second.back() / distance;
        continue;
      }
      auto lower = std::lower_bound(atomPot.first.begin(), atomPot.first.end(), distance);
      unsigned int n = lower - atomPot.first.begin();
      auto v = atomPot.second[n - 1] + (atomPot.second[n] - atomPot.second[n - 1]) * (distance - atomPot.first[n - 1]) /
                                           (atomPot.first[n] - atomPot.first[n - 1]);
      potential[point] += v / distance;
    }
  }

  // Map real space grid potential to matrix in basis representation
  auto basis = system->getBasisController();
  auto settings = system->getSettings();
  FockMatrix<RESTRICTED> fock(basis);
  fock = system->getOneElectronIntegralController()->getOneElectronIntegrals();
  fock -= system->getOneElectronIntegralController()->getECPIntegrals();
  auto bfOnGrid = BasisFunctionOnGridControllerFactory::produce(settings, basis, grid);
  ScalarOperatorToMatrixAdder<RESTRICTED> potToMatrix(bfOnGrid, settings.grid.blockAveThreshold);
  potToMatrix.addScalarOperatorToMatrix(fock, potential);

  // Construct ElectronicStructure
  auto orbitals = std::make_shared<OrbitalController<RESTRICTED>>(basis, system->getNCoreElectrons() / 2);
  auto es = std::make_unique<ElectronicStructure<RESTRICTED>>(orbitals, system->getOneElectronIntegralController(),
                                                              system->getNOccupiedOrbitals<RESTRICTED>());

  // Diagonalize Fock matrix to get MO orbitals
  orbitals->setCanOrthTh(settings.scf.canOrthThreshold);
  orbitals->updateOrbitals(fock, system->getOneElectronIntegralController());

  return es;
}

} /* namespace Serenity */
