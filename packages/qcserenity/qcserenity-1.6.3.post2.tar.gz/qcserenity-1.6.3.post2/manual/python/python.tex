\chapter{Python Input}
\label{sec:python}
Serenity features a Python wrapper.
The wrapper is written with \textsc{pybind11}\cite{pybind11} and should allow for easy access of \serenity s functionality from Python.
The wrapper is named \texttt{serenipy} and comes in the form of a shared library named \texttt{serenipy.so}. It is built when the flag \texttt{SERENITY\_PYTHON\_BINDINGS} is set to \texttt{ON} during the \texttt{CMake} configuration, and of course it is installed if \serenity is installed via \texttt{pip}. If built from source, sourcing \texttt{serenity.sh} will set the path to the shared library into the \texttt{PYTHONPATH} environment variable.

This library can directly be imported into Python with either of the following lines:
\begin{lstlisting}[language=Python]
import qcserenity.serenipy
from qcserenity.serenipy import *
\end{lstlisting}
While this manual contains a rough outline of the functionality of the Python wrapper the doc-strings can be accessed via the
\texttt{help()} function of Python. For example :
\begin{lstlisting}[language=Python]
import qcserenity.serenipy as spy
help(spy)
\end{lstlisting}
This will display the automated documentation including both the links to C++ generated by \textsc{pybind11} and the additionally written doc-strings.
\section{Wrapped Systems and Settings}
A system inside the wrapper is generated for a set of \ttt{Settings},
the settings are essentially the same as described in Section~\ref{sec:system}.
Each block is a member of the settings and each keyword is a member of the block.
A small example of altering the settings can look like this:
\begin{lstlisting}[language=Python]
import qcserenity.serenipy as spy

settings = spy.Settings()
settings.basis.label = 'def2-TZVP'
settings.name = 'Hans'
settings.dft.functional = spy.PBE0
\end{lstlisting}

\section{Wrapped Tasks}
Most of the tasks in that exist in Serenity should be wrapped and also exist as classes inside the Python wrapper.
They can be built by constructing a task object with a given set of systems.
The amount of systems (active and environment) accepted can be seen in Section~\ref{sec:tasks}.
Afterwards, the task's settings can be accessed via the task object, exactly like the normal settings.
There is one special thing to note, while the tasks in general have the same names as in the C++ code, or the
normal input, the specification of a restricted or unrestricted task has to be given via the object name.
Restricted tasks are called \ttt{<usual-task-name>\_R} and unrestricted ones \ttt{<usual-task-name>\_U}.
This is due to the fact that restricted and unrestricted tasks are actually different classes, because they are templates.
Another limitation to note is that some settings have to be given with their full name, as there are other settings with values of the same name. For example, the Hartree--Fock method has to be set by writing
\begin{lstlisting}[language=Python]
  from qcserenity.serenipy import *
  settings = Settings()
  settings.method = ELECTRONIC_STRUCTURE_THEORIES.HF
\end{lstlisting}
instead of simply \ttt{settings.method = HF}.
Here is a minimal example for a SCF calculation with all default settings:
\begin{lstlisting}[language=Python]
from qcserenity.serenipy import *

settings = Settings()
settings.geometry = "test.xyz"
system = System(settings)
task = ScfTask_R(system)
task.run()
\end{lstlisting}
\section{Other Wrapper Features}
Some utility scripts reside directly in the \texttt{qcserenity} module.
In addition to the tasks, systems and settings other important classes of \serenity are exposed to Python.
For example it is possible to get the results of a gradient calculation and also specific energies.
\begin{lstlisting}[language=Python]
from qcserenity.serenipy import *
import numpy as np
...
gradients = system.getGeometry().getGradients()
print(gradients)
print(system.getEnergy())
print(system.getEnergy(KS_DFT_ELECTRON_ELECTRON_EXCHANGE))
\end{lstlisting}
All matrices are mapped to numpy-arrays.
As an example, a density matrix can be accessed as:
\begin{lstlisting}[language=Python]
dMat = system.getElectronicStructure_R().getDensityMatrix()
print(dMat.total())
\end{lstlisting}
Furthermore, it is possible to access Libint as integrated into the C++ library.
Using the AO overlap as an example:
\begin{lstlisting}[language=Python]
libint = Libint()
S_AO = libint.compute(OVERLAP, system.getBasis())
print(S_AO)
\end{lstlisting}
If you want to use additional features via python please use the \ttt{help()} function to explore the package
and or write an e-mail to one of the developers.
