.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man v6.0.2 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Required to disable full justification in groff 1.23.0.
.if n .ds AD l
.\" ========================================================================
.\"
.IX Title "IPC::Open3 3"
.TH IPC::Open3 3 2025-05-28 "perl v5.41.13" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
IPC::Open3 \- open a process for reading, writing, and error handling using open3()
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\&    use Symbol \*(Aqgensym\*(Aq; # vivify a separate handle for STDERR
\&    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
\&                    \*(Aqsome\*(Aq, \*(Aqcmd\*(Aq, \*(Aqand\*(Aq, \*(Aqargs\*(Aq);
\&    # or pass the command through the shell
\&    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
\&                    \*(Aqsome cmd and args\*(Aq);
\&
\&    # read from parent STDIN
\&    # send STDOUT and STDERR to already open handle
\&    open my $outfile, \*(Aq>>\*(Aq, \*(Aqoutput.txt\*(Aq or die "open failed: $!";
\&    my $pid = open3([\*(Aq&\*(Aq, *STDIN], [\*(Aq&\*(Aq, $outfile], undef,
\&                    \*(Aqsome\*(Aq, \*(Aqcmd\*(Aq, \*(Aqand\*(Aq, \*(Aqargs\*(Aq);
\&
\&    # write to parent STDOUT and STDERR
\&    my $pid = open3(my $chld_in, [\*(Aq&\*(Aq, *STDOUT], [\*(Aq&\*(Aq, *STDERR],
\&                    \*(Aqsome\*(Aq, \*(Aqcmd\*(Aq, \*(Aqand\*(Aq, \*(Aqargs\*(Aq);
\&
\&    # reap zombie and retrieve exit status
\&    waitpid( $pid, 0 );
\&    my $child_exit_status = $? >> 8;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Extremely similar to \f(CW\*(C`open2\*(C'\fR from IPC::Open2, \f(CW\*(C`open3\*(C'\fR spawns the given
command and provides filehandles for interacting with the command\*(Aqs standard
I/O streams.
.PP
.Vb 1
\&    my $pid = open3($chld_in, $chld_out, $chld_err, @command_and_args);
.Ve
.PP
It connects \f(CW$chld_in\fR for writing to the child\*(Aqs standard input, \f(CW$chld_out\fR
for reading from the child\*(Aqs standard output, and \f(CW$chld_err\fR for reading from
the child\*(Aqs standard error stream.  If \f(CW$chld_err\fR is false, or the same file
descriptor as \f(CW$chld_out\fR, then \f(CW\*(C`STDOUT\*(C'\fR and \f(CW\*(C`STDERR\*(C'\fR of the child are on
the same filehandle.  This means that you cannot pass an uninitialized variable
for \f(CW$chld_err\fR and have \f(CW\*(C`open3\*(C'\fR auto\-generate a filehandle for you, but
gensym from Symbol can be used to vivify a new glob reference; see
"SYNOPSIS".  The \f(CW$chld_in\fR handle will have autoflush turned on.
.PP
By default, the filehandles you pass in are used as output parameters.
\&\f(CW\*(C`open3\*(C'\fR internally creates three pipes.  The write end of the first pipe and
the read ends of the other pipes are connected to the command\*(Aqs standard
input/output/error, respectively.  The corresponding read and write ends are
placed in the first three argument to \f(CW\*(C`open3\*(C'\fR.
.PP
The filehandle arguments can take the following forms:
.IP \(bu 4
An uninitialized variable (technically, either \f(CW\*(C`undef\*(C'\fR or the empty string
will work):  \f(CW\*(C`open3\*(C'\fR generates a fresh filehandle and assigns it to the
argument, which must be a modifiable variable for this work (otherwise an
exception will be raised).
.Sp
This does not work for \f(CW$chld_err\fR, however:  If the \f(CW$chld_err\fR argument is
a false value, the child\*(Aqs error stream is automatically redirected to its
standard output.
.IP \(bu 4
An existing handle in the form of a typeglob like \f(CW*STDIN\fR or \f(CW*FOO\fR or a
reference to such:  \f(CW\*(C`open3\*(C'\fR places the filehandle in the \f(CW\*(C`IO\*(C'\fR slot of the
typeglob, which means the corresponding bareword filehandle (like \f(CW\*(C`STDIN\*(C'\fR or
\&\f(CW\*(C`FOO\*(C'\fR) can be used for I/O from/to the child process.  (If the handle is
already open, it is automatically closed first.)
.IP \(bu 4
A string containing the name of a bareword handle (like \f(CW\*(AqSTDIN\*(Aq\fR or
\&\f(CW\*(AqFOO\*(Aq\fR):  Such strings are resolved to typeglobs at runtime and then act like
the case described above.
.PP
However, it is possible to make \f(CW\*(C`open3\*(C'\fR use an existing handle directly (as an
input argument) and skip the creation of a pipe.  To do this, the filehandle
argument must have one of the following two forms:
.IP \(bu 4
An array reference like \f(CW\*(C`[\*(Aq&\*(Aq, $fh]\*(C'\fR, i.e. the first element is the string
\&\f(CW\*(Aq&\*(Aq\fR and the second element is the existing handle to use in the child
process.
.IP \(bu 4
A string of the form \f(CW\*(Aq<&FOO\*(Aq\fR or \f(CW\*(Aq>&FOO\*(Aq\fR, i.e. a string starting
with the two characters \f(CW\*(C`<&\*(C'\fR (for input) or \f(CW\*(C`>&\*(C'\fR (for output),
followed by the name of a bareword filehandle.  (The string form cannot be used
with handles stored in variables.)
.PP
If you use this form for \f(CW$chld_in\fR, the filehandle will be closed in the
parent process.
.PP
The filehandles may also be integers, in which case they are understood
as file descriptors.
.PP
\&\f(CW\*(C`open3\*(C'\fR returns the process ID of the child process.  It doesn\*(Aqt return on
failure: it just raises an exception matching \f(CW\*(C`/^open3:/\*(C'\fR.  However,
\&\f(CW\*(C`exec\*(C'\fR failures in the child (such as no such file or permission denied),
are just reported to \f(CW$chld_err\fR under Windows and OS/2, as it is not possible
to trap them.
.PP
If the child process dies for any reason, the next write to \f(CW$chld_in\fR is
likely to generate a SIGPIPE in the parent, which is fatal by default,
So you may wish to handle this signal.
.PP
Note: if you specify \f(CW\*(C`\-\*(C'\fR as the command, in an analogous fashion to
\&\f(CW\*(C`open(my $fh, "\-|")\*(C'\fR the child process will just be the forked Perl
process rather than an external command.  This feature isn\*(Aqt yet
supported on Win32 platforms.
.PP
\&\f(CW\*(C`open3\*(C'\fR does not wait for and reap the child process after it exits.
Except for short programs where it\*(Aqs acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as
simple as calling \f(CW\*(C`waitpid $pid, 0\*(C'\fR when you\*(Aqre done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See "waitpid" in perlfunc for more information.
.PP
If you try to read from the child\*(Aqs stdout writer and their stderr
writer, you\*(Aqll have problems with blocking, which means you\*(Aqll want
to use \f(CW\*(C`select\*(C'\fR or IO::Select, which means you\*(Aqd best use
\&\f(CW\*(C`sysread\*(C'\fR instead of \f(CW\*(C`readline\*(C'\fR for normal stuff.
.PP
This is very dangerous, as you may block forever.  \f(CW\*(C`open3\*(C'\fR assumes it\*(Aqs
going to talk to something like \fBbc\fR\|(1), both writing to it and reading
from it.  This is presumably safe because you "know" that commands
like \fBbc\fR\|(1) will read a line at a time and output a line at a time.
Programs like \fBsort\fR\|(1) that read their entire input stream first,
however, are quite apt to cause deadlock.
.PP
The big problem with this approach is that if you don\*(Aqt have control
over source code being run in the child process, you can\*(Aqt control
what it does with pipe buffering.  Thus you can\*(Aqt just open a pipe to
\&\f(CW\*(C`cat \-v\*(C'\fR and continually read and write a line from it.
.SH "See Also"
.IX Header "See Also"
.IP IPC::Open2 4
.IX Item "IPC::Open2"
Like IPC::Open3 but without \f(CW\*(C`STDERR\*(C'\fR capture.
.IP IPC::Run 4
.IX Item "IPC::Run"
This is a CPAN module that has better error handling and more facilities
than IPC::Open3.
.SH WARNING
.IX Header "WARNING"
The order of arguments differs from that of \f(CW\*(C`open2\*(C'\fR.
