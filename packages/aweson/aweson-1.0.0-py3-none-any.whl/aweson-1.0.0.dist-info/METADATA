Metadata-Version: 2.4
Name: aweson
Version: 1.0.0
Summary: Traversing and manipulating hierarchical info sets (JSON) using pythonic JSON Path-like expressions
Author-email: Ferenc Dosa-Racz <dosarf@gmail.com>
License-Expression: MIT
Project-URL: Homepage, https://github.com/dosarf/aweson
Project-URL: Issues, https://github.com/dosarf/aweson/issues
Keywords: JSON,Path
Classifier: Programming Language :: Python :: 3.10
Classifier: Operating System :: OS Independent
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Provides-Extra: test
Requires-Dist: pytest; extra == "test"
Provides-Extra: develop
Requires-Dist: build; extra == "develop"
Requires-Dist: twine; extra == "develop"
Dynamic: license-file

# aweson
Traversing and manipulating hierarchical data (JSON) using pythonic JSON Path-like expressions

## Import the necessary stuff

>>> from aweson import JP, find_all

## Iterating over hierarchical data

>>> content = {"employees": [{"name": "Doe, John", "age": 32}, {"name": "Doe, Jane", "age": -23}, {"name": "Deer, Jude", "age": 42}, ]}
>>> list(find_all(content, JP.employees[:].name))
['Doe, John', 'Doe, Jane', 'Deer, Jude']

Note that the JSON Path-like expression is _not_ a string, it's a Python expression, i.e. your
IDE will be of actual help.

Furthermore, to address all items in a list, Pythonic slice expression `[:]` is used. Naturally,
other indexing and slice expressions also work in the conventional Pythonic way:

>>> list(find_all(content, JP.employees[-1].name))
['Deer, Jude']

>>> list(find_all(content, JP.employees[:2].name))
['Doe, John', 'Doe, Jane']

You may be interested in the actual path of an item being returned, just like
you get an index alongside items when using `enumerate()`. For instance, you may want to verify
ages being non-negative, and report accurately the path of failure items:

>>> path, item = next(t for t in find_all(content, JP.employees[:].age, enumerate=True) if t[1] < 0)
>>> item
-23

Note, if argument `enumerate=True` is passed, `find_all()` returns tuples instead of single
items: the first items being JSON Path-like expression (a pointer to data, just
like an _index_ of `enumerate()`) and the second items the value itself.

The offending path, then, in human-readable format:

>>> str(path)
'.employees[1].age'

The enclosing record, using `.parent` attribute of the path obtained for the offending age:

>>> next(find_all(content, path.parent))
{'name': 'Doe, Jane', 'age': -23}
