"""
Command to generate type stub files (.pyi) from provider configurations.

This allows developers to have full static typing support without writing boilerplate.

Usage:
    smart-api-integrations generate-type-stubs
    smart-api-integrations generate-type-stubs --provider github
    smart-api-integrations generate-type-stubs --output-dir ./typings
"""

import os
import sys
import yaml
import argparse
from pathlib import Path
from typing import Dict, Any, List


def register_command(subparsers):
    """Register the command with the given subparsers."""
    parser = subparsers.add_parser(
        'generate-type-stubs',
        help='Generate type stub files (.pyi) from provider configurations',
        description='Generate type stub files (.pyi) from provider configurations'
    )
    
    parser.add_argument(
        '--provider',
        type=str,
        help='Generate stubs for specific provider (default: all providers)'
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default='src/typings',
        help='Output directory for type stub files'
    )
    parser.add_argument(
        '--providers-dir',
        type=str,
        default=os.environ.get('SMART_API_INTEGRATIONS_PROVIDERS_DIR', './providers'),
        help='Directory containing provider configurations'
    )
    
    parser.set_defaults(func=command_handler)
    return parser


def command_handler(args):
    """Handle the generate-type-stubs command."""
    try:
        provider_name = args.provider
        output_dir = Path(args.output_dir)
        providers_dir = Path(args.providers_dir)
        
        if provider_name:
            generate_stub_for_provider(provider_name, output_dir, providers_dir)
        else:
            generate_all_stubs(output_dir, providers_dir)
        
        return 0
    except Exception as e:
        print(f"Error generating type stubs: {str(e)}")
        return 1


def generate_all_stubs(output_dir: Path, providers_dir: Path):
    """Generate type stubs for all providers."""
    if not providers_dir.exists():
        print(f"Providers directory not found: {providers_dir}")
        return
    
    for provider_dir in providers_dir.iterdir():
        if provider_dir.is_dir() and (provider_dir / 'config.yaml').exists():
            provider_name = provider_dir.name
            generate_stub_for_provider(provider_name, output_dir, providers_dir)


def generate_stub_for_provider(provider_name: str, output_dir: Path, providers_dir: Path):
    """Generate type stub for a specific provider."""
    config_path = providers_dir / provider_name / 'config.yaml'
    
    if not config_path.exists():
        print(f"Config not found: {config_path}")
        return
    
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        
        stub_content = generate_stub_content(provider_name, config)
        
        # Write stub file
        stub_path = output_dir / f'{provider_name}.pyi'
        output_dir.mkdir(parents=True, exist_ok=True)
        
        with open(stub_path, 'w') as f:
            f.write(stub_content)
        
        print(f"Generated type stub: {stub_path}")
        
    except Exception as e:
        print(f"Error generating stub for {provider_name}: {e}")


def generate_stub_content(provider_name: str, config: Dict[str, Any]) -> str:
    """Generate the content of a type stub file."""
    class_name = f"{provider_name.title()}APIClient"
    
    # Header
    stub_lines = [
        f'"""',
        f'Type stubs for {class_name} - provides static typing without boilerplate.',
        f'',
        f'This file is automatically generated from the provider configuration.',
        f'IDEs will use these type hints for autocomplete and type checking.',
        f'"""',
        f'',
        f'from typing import Optional, List, Dict, Any',
        f'from ..core.schema import APIResponse',
        f'from ..clients.universal import UniversalAPIClient',
        f'',
        f'',
        f'class {class_name}(UniversalAPIClient):',
        f'    """{ config.get("description", f"{provider_name.title()} API Client")} with full type support."""',
        f'    ',
        f'    def __init__(self, token_value: Optional[str] = None) -> None: ...',
        f'    ',
    ]
    
    # Generate method stubs from endpoints
    endpoints = config.get('endpoints', {})
    
    for endpoint_name, endpoint_config in endpoints.items():
        method_stub = generate_method_stub(endpoint_name, endpoint_config)
        stub_lines.extend(method_stub)
        stub_lines.append('    ')
    
    # Add mapped methods if any client defines them
    # This is a placeholder - in practice, you'd read METHOD_MAPPING from the client class
    stub_lines.extend([
        '    # Mapped methods (add custom mappings here)',
        '    # Example:',
        '    # def custom_method_name(self, **kwargs: Any) -> APIResponse: ...',
    ])
    
    return '\n'.join(stub_lines)


def generate_method_stub(endpoint_name: str, endpoint_config: Dict[str, Any]) -> List[str]:
    """Generate a method stub for a single endpoint."""
    method = endpoint_config.get('method', 'GET').upper()
    path = endpoint_config.get('path', '')
    description = endpoint_config.get('description', f'Call {endpoint_name} endpoint')
    parameters = endpoint_config.get('parameters', [])
    
    # Analyze parameters
    required_params = []
    optional_params = []
    body_params = []
    
    # Handle parameters as list (newer format) or dict (older format)
    if isinstance(parameters, list):
        for param in parameters:
            param_name = param.get('name', '')
            param_location = param.get('location', 'query')
            param_required = param.get('required', False)
            
            if param_location == 'body':
                body_params.append(param_name)
            elif param_required:
                required_params.append(param_name)
            else:
                optional_params.append(param_name)
    else:
        # Handle as dictionary (older format)
        for param_name, param_def in parameters.items():
            param_location = param_def.get('in', 'query')
            param_required = param_def.get('required', False)
            
            if param_location == 'body':
                body_params.append(param_name)
            elif param_required:
                required_params.append(param_name)
            else:
                optional_params.append(param_name)
    
    # Build method signature
    method_lines = [
        f'    def {endpoint_name}(',
        f'        self,',
        f'        *,',
    ]
    
    # Add parameter hints
    if required_params or optional_params:
        if required_params:
            param_comment = f'  # {", ".join(required_params)} (required)'
            if optional_params:
                param_comment += f', {", ".join(optional_params)}'
        else:
            param_comment = f'  # {", ".join(optional_params)}'
        
        method_lines.append(f'        params: {"Dict[str, Any]" if required_params else "Optional[Dict[str, Any]] = None"},{param_comment}')
    
    # Add body parameters for POST/PUT/PATCH
    if method in ['POST', 'PUT', 'PATCH'] and body_params:
        body_comment = f'  # {", ".join(body_params)}'
        
        # Check if any body parameters are required
        has_required_body = False
        if isinstance(parameters, list):
            has_required_body = any(param.get('required', False) for param in parameters 
                                   if param.get('location') == 'body')
        else:
            has_required_body = any(param_def.get('required', False) for param_def in parameters.values() 
                                   if param_def.get('in') == 'body')
        
        if has_required_body:
            method_lines.append(f'        json_data: Dict[str, Any],{body_comment}')
        else:
            method_lines.append(f'        json_data: Optional[Dict[str, Any]] = None,{body_comment}')
        
        # Add alternative parameter names
        method_lines.extend([
            f'        json: Optional[Dict[str, Any]] = None,  # Alternative parameter name',
            f'        body: Optional[Dict[str, Any]] = None,  # Alternative parameter name',
        ])
    
    method_lines.extend([
        f'    ) -> APIResponse:',
        f'        """{method} {path} - {description}"""',
        f'        ...',
    ])
    
    return method_lines


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Generate type stub files (.pyi) from provider configurations'
    )
    register_command(parser.add_subparsers())
    args = parser.parse_args()
    
    if hasattr(args, 'func'):
        sys.exit(args.func(args))
    else:
        parser.print_help()
        sys.exit(1)
