# task1.py
"""Модуль с решениями первых задач билетов 1-20 (код + теория с интегралами)"""

SOLUTIONS = {
    'эллипс': {
        'code': """
# Билет 1: Две точки в эллипсе (Метод Монте-Карло)
from sympy import *
from sympy.stats import Binomial, variance, skewness
from scipy.stats import *
from scipy.spatial import distance
from scipy import integrate
from scipy.special import comb
from itertools import *
from fractions import Fraction
import numpy as np
import math
import random
init_printing()

def point():
    while True:
        u = random.uniform(-13, 13)
        v = random.uniform(-9, 9)
        if (u / 13) ** 2 + (v / 9) ** 2 <= 1:
            return [u, v]

counter_A = 0
for i in range(10**6):
    point1 = point()
    point2 = point()
    counter_A += distance.euclidean(point1, point2) < 5.2

print(counter_A / 10 ** 6)


counter_B, counter_A = 0, 0
for i in range(10**6):
    point1 = point()
    point2 = point()
    if all(map(lambda x: x < 0, point1 + point2)):
        counter_B += 1
        counter_A += distance.euclidean(point1, point2) < 5.2

print(counter_A / counter_B)
""",
        'theory': """
В области, ограниченной эллипсом  (u13)2+(v9)2=1 , случайным образом выбираются две точки. Пусть  A  и  B  – события, состоящие в том, что:  A  – расстояние между выбранными точками меньше 5,2;  B  – все координаты обеих точек меньше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность  P(A) ; 2) условную вероятность  P(A|B) . Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):

1. Совместная плотность распределения двух точек в эллипсе:
   f(x₁,y₁,x₂,y₂) = (1/(πab))² = 1/(9π²·13)

2. Вероятность P(ρ < 5.2):
   P = ∫∫∫∫_{D} f(x₁,y₁,x₂,y₂) dx₁dy₁dx₂dy₂
   где D = {(x₁,y₁,x₂,y₂) | √[(x₂-x₁)²+(y₂-y₁)²] < 5.2}

3. Условная вероятность P(A|B):
   P = ∫∫∫∫_{D∩B} f(x₁,y₁,x₂,y₂) dx₁dy₁dx₂dy₂ / ∫∫∫∫_{B} f(x₁,y₁,x₂,y₂) dx₁dy₁dx₂dy₂
   где B = {x₁<0, y₁<0, x₂<0, y₂<0}
"""
    },
    
    'прямоугольник': {
        'code': """
# Билет 3: Две точки в прямоугольнике
import random
from math import sqrt

def length(point1, point2):
    return sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)

N = 100000
cnt_A = 0
cnt_B = 0

for i in range(N):
    point1 = random.uniform(-20, 20), random.uniform(-12, 12)
    point2 = random.uniform(-20, 20), random.uniform(-12, 12)
    if np.abs(point1[0] - point2[0]) < 14:
        cnt_B += 1
    if length(point1, point2) < 6.4:
        cnt_A += 1

pstat_A = cnt_A / N
pstatA_B = cnt_A / cnt_B
print(pstat_A)
print(pstatA_B)
""",
        'theory': """
В прямоугольной области, заданной ограничениями  |x|<20  и  |y|<12 , случайным образом выбираются две точки:  (x1,y1)  и  (x2,y2) . Пусть  A  и  B  — события, состоящие в том, что:
A  — расстояние между выбранными точками меньше 6,4;
B  — модуль разности  |x1−x2|  меньше 14.
Найдите приближенно, методом Монте-Карло:
1) вероятность  P(A) ;
2) условную вероятность  P(A|B) .
Указание: получите в заданной прямоугольной области 100000 пар точек и, используя все эти точки, найдите ответы, округляя их до одного знака после запятой.
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):

1. Совместная плотность в прямоугольнике:
   f(x₁,y₁,x₂,y₂) = (1/960)² = 1/921600

2. Вероятность P(ρ < 6.4):
   P = ∫_{-20}^{20} ∫_{-12}^{12} ∫_{-20}^{20} ∫_{-12}^{12} 
       I[√[(x₂-x₁)²+(y₂-y₁)²] < 6.4] f(x₁,y₁,x₂,y₂) dy₂dx₂dy₁dx₁

3. Условная вероятность:
   P = ∫∫∫∫_{|x₁-x₂|<14} I[ρ < 6.4] f(x₁,y₁,x₂,y₂) dx₁dy₁dx₂dy₂ / 
       P(|x₁-x₂| < 14)
"""
    },
    
    'банки': {
        'code': """
# Билет 4: Проблемные банки
def union(A, B):
  return {a + b for a in A for b in B}

def Omega(group, k):
  return [' '.join(comb) for comb in combinations(group, k)]

group = np.array(list(union('N', '123456789abс') | union('P', '123456789abcв')))
omega = Omega(group, 3)

A = [x for x in omega if x.count('P') >= 1]
P = len(A) / len(omega)
print(P)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 4):
В группе региональных банков имеется 12 банков, у которых нет проблем с выполнением нормативных показателей, и 13 банков, у которых такие проблемы имеются. Для проверки случайным образом отобраны три банка. Найдите:

вероятность того, что в число отобранных банков попадет хотя бы один проблемный.
Комбинаторное решение без интегралов:
P = 1 - C(12,3)/C(25,3) = 1 - 220/2300 ≈ 0.904
"""
    },
    
    'вагоны': {
        'code': """
# Билет 5: Люди в вагонах
w = [str(i) for i in range(1, 12)]
omega = list(product(w, repeat=4))
P = [x for x in omega if len(set(x)) < 4]  # Все случаи, где хотя бы двое в одном вагоне
probability = round(len(P) / len(omega), 3)
print(probability)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 5):
Независимо друг от друга 4 человека садятся в поезд, содержащий 11 вагонов.

Найдите вероятность того, что по крайней мере двое из них окажутся в одном вагоне
Комбинаторное решение:
P = 1 - 11×10×9×8/11⁴ = 1 - 7920/14641 ≈ 0.459
"""
    },
    
    'шары': {
        'code': """
# Билет 7: Вероятность белого шара
n1 = 28 # общее кол-во шаров в 1-ой корзине
w1 = 13 # белые 1-ая корзина
c1 = 5 # извелкаются из 1-ой корзины

n2 = 37 # общее кол-во шаров в 2-ой корзине
w2 = 17 # белые 2-ая корзина
c2 = 10 # извелкаются из 2-ой корзины

total_white = np.zeros((c1 + 1, c2 + 1))
for i in range(c1 + 1):
  for j in range(c2 + 1):
    if i <= w1 and j <= w2:
      prob1 = hypergeom.pmf(i, n1, w1, c1)
      prob2 = hypergeom.pmf(j, n2, w2, c2)
      total_white[i, j] = prob1 * prob2

P_A = sum(total_white[i, j] * (i + j) for i in range(c1 + 1) for j in range(c2 + 1)) / 15
print(P_A)

P_H = c1 / (c1 + c2)
P_A_given_H = sum(total_white[i, j] * (i / c1) for i in range(c1 + 1) for j in range(c2 + 1))
res = (P_A_given_H * P_H) / P_A
print(res)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 7):
Имеется две корзины с белыми и чёрными шарами. В первой корзине количество белых — 13, количество чёрных — 15. Во второй корзине количество белых — 17, количество чёрных — 20. Из первой корзины случайным образом, без возвращения, извлекаются 5 шаров, а из второй — 10 шаров. Отобранные из обеих корзин шары перекладываются в третью корзину.

Какова вероятность  P(A) , что случайно вынутый из третьей корзины шар окажется белым (событие  A )?
Найдите условную вероятность  P(H|A) , что случайно вынутый из третьей корзины шар изначально находился в первой корзине (событие  H ), при условии, что он белый (событие  A )?
1. Вероятность вынуть белый из 1-й корзины:
   P₁ = C(13,1)/C(28,1) = 13/28
   Ожидаемое число белых при выборе 5 шаров: 5*(13/28) ≈ 2.32

2. Вероятность вынуть белый из 2-й корзины:
   P₂ = C(17,1)/C(37,1) = 17/37
   Ожидаемое число белых при выборе 10 шаров: 10*(17/37) ≈ 4.59

3. Итоговая вероятность:
   P = (2.32 + 4.59)/15 ≈ 0.461
   P(из 1-й|белый) = 2.32/(2.32 + 4.59) ≈ 0.336
"""
    },
    
    'треугольник': {
        'code': """
# Билет 8: Остроугольные треугольники (Монте-Карло)
import numpy as np
from scipy.spatial import distance

n_acute = 0
r_count = 0
s_count = 0

while n_acute < 100000:
    points = np.random.rand(3, 3)
    a = distance.euclidean(points[1], points[2])
    b = distance.euclidean(points[0], points[2])
    c = distance.euclidean(points[0], points[1])
    if a + b > c and a + c > b and b + c > a:
        angles = np.degrees(np.arccos([
            (b**2 + c**2 - a**2) / (2 * b * c),
            (a**2 + c**2 - b**2) / (2 * a * c),
            (a**2 + b**2 - c**2) / (2 * a * b)
        ]))
        if np.all(angles < 90):
            n_acute += 1
            min_angle = np.min(angles)
            max_angle = np.max(angles)

            if min_angle < 35.6:
                r_count += 1
            if max_angle < 68.4:
                s_count += 1

p_r_given_t = r_count / n_acute
p_s_given_t = s_count / n_acute

print(f"P(R|T) ≈ {p_r_given_t:.2f}")
print(f"P(S|T) ≈ {p_s_given_t:.2f}")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 8):
В кубе объема 3 случайным образом выбираются точки  A ,  B  и  C . Пусть  R ,  S  и  T  — события, состоящие в том, что:

R  — в треугольнике  ABC  найдется угол меньше  35,6∘ ;

S  — все углы в треугольнике  ABC  меньше  68,4∘ ;

T  — треугольник  ABC  остроугольный.

Найдите приближенно, методом Монте-Карло:

условную вероятность  P(R|T) ;
условную вероятность  P(S|T′) .
Указание: получите 100000 остроугольных треугольников  ABC  и, используя все эти треугольники, найдите ответы, округляя их до одного знака после запятой.
1. Объем куба: V = 3 → ребро a = 3^(1/3) ≈ 1.442

2. Вероятность для остроугольного треугольника:
   P = ∫∫∫_{T} I[все углы <90°] dx₁dy₁dz₁dx₂dy₂dz₂dx₃dy₃dz₃ / V³
   где T - пространство всех треугольников

3. Условные вероятности вычисляются через отношение объемов
"""
    },
    
    'бином': {
        'code': """
# Билет 12: Биномиальное распределение шаров
P_X1 = {k: binom.pmf(k, 7, 0.3) for k in range(8)} # range(8) = n + 1 = 7 + 1
P_X2 = {k: binom.pmf(k, 5, 0.5) for k in range(6)} # range(6) = n + 1 = 5 + 1

b1 = 12
b2 = 6
N = b1 + b2

P_A = sum(P_X1[k1] * P_X2[k2] * (k1 + k2) / N for k1, k2 in product(P_X1.keys(), P_X2.keys()))
P_A_H = sum(P_X1[k1] * k1 / b1 for k1 in P_X1.keys())

# P(H) - вероятность выбора шара из первой корзины
P_H = b1 / (b1 + b2)

# Условная вероятность P(H|A)
P_H_A = (P_A_H * P_H) / P_A

# Вывод результатов
print(P_A)
print(P_H_A)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 12):
Имеется две корзины с белыми и черными шарами.

В первой корзине всего 12 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами  n=7  и  p=0,3 .
Во второй корзине имеется всего 6 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами  n=5  и  p=0,5 .
Из обеих корзин все шары перекладываются в третью корзину.

Какова вероятность  P(A) , что случайно вынутый из третьей корзины шар окажется белым (событие  A )?
Найдите условную вероятность  P(H|A) , того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие  H ), при условии, что он белый (событие  A )?
1. Ожидаемое число белых в 1-й корзине:
   E = 7*0.3 = 2.1

2. Ожидаемое число белых во 2-й корзине:
   E = 5*0.5 = 2.5

3. Итоговая вероятность:
   P = (2.1 + 2.5)/18 ≈ 0.256
   P(из 1-й|белый) = 2.1/(2.1 + 2.5) ≈ 0.457
"""
    }
}

def show_solution(ticket_number:str):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution('эллипс')
    show_solution('прямоугольник')
    show_solution('банки')
    show_solution('вагоны')
    show_solution('шары')
    show_solution('треугольник')
    show_solution('бином')