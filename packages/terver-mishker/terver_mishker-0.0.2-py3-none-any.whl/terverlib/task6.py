# task6.py
"""Модуль с решениями шестых задач билетов 1-3 (код + теория)"""

SOLUTIONS = {
    1: {
        'code': """
# Билет 1: Суммарный ущерб от страховых случаев
import numpy as np
from scipy.stats import poisson, uniform

def solve_ticket1():
    \"\"\"Вычисляет:
    1) Мат. ожидание суммарного ущерба за год
    2) Стандартное отклонение суммарного ущерба
    \"\"\"
    # Параметры распределений
    lambda_ = 16/5  # Интенсивность Пуассона (случаев/год)
    max_damage = 3.4  # Максимальный ущерб (млн руб)
    
    # 1) Математическое ожидание
    E_N = lambda_
    E_X = max_damage / 2  # Для равномерного распределения
    E_total = E_N * E_X
    
    # 2) Стандартное отклонение
    Var_N = lambda_
    Var_X = max_damage**2 / 12  # Для равномерного распределения
    Var_total = E_N * Var_X + Var_N * E_X**2
    std_total = np.sqrt(Var_total)
    
    return round(E_total, 3), round(std_total, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):

1. Суммарный ущерб S = Σ_{i=1}^N X_i, где:
   - N ~ Poisson(λ=16/5) - число страховых случаев
   - X_i ~ Uniform(0, 3.4) - размер ущерба

2. Математическое ожидание:
   E[S] = E[N] * E[X] = λ * (a+b)/2 = 3.2 * 1.7 = 5.44

3. Дисперсия (по формуле для сложного пуассоновского процесса):
   Var(S) = E[N]*Var(X) + Var(N)*E[X]^2 = λ*(b-a)^2/12 + λ*( (a+b)/2 )^2
   = 3.2*(3.4^2)/12 + 3.2*(1.7)^2 ≈ 3.2*0.9633 + 3.2*2.89 ≈ 3.0826 + 9.248 = 12.3306
   σ_S = √12.3306 ≈ 3.511
"""
    },
    
    2: {
        'code': """
# Билет 2: Бросание несимметричных монет
from scipy.stats import binom

def solve_ticket2():
    \"\"\"Вычисляет:
    1) E[Var(Y2|Y1)]
    2) Var(E[Y2|Y1])
    \"\"\"
    n = 115  # Число монет
    p = 0.4  # Вероятность орла
    
    # 1) Условная дисперсия: Var(Y2|Y1=k) = k*p*(1-p)
    # E[Var(Y2|Y1)] = E[Y1]*p*(1-p) = n*p * p*(1-p) = n*p^2*(1-p)
    evar = n * p**2 * (1 - p)
    
    # 2) Дисперсия условного мат. ожидания: Var(E[Y2|Y1]) = Var(Y1*p) = p^2*Var(Y1)
    vare = p**2 * n * p * (1 - p)
    
    return round(evar, 3), round(vare, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2):

1. Y1 ~ Binomial(n=115, p=0.4) - число орлов в первом броске
   Y2|Y1=k ~ Binomial(k, p=0.4) - число орлов во втором броске

2. По формуле полной дисперсии:
   Var(Y2) = E[Var(Y2|Y1)] + Var(E[Y2|Y1])

3. Вычисляем компоненты:
   - E[Var(Y2|Y1)] = E[Y1*p*(1-p)] = n*p * p*(1-p) = 115*0.4*0.4*0.6 = 11.04
   - Var(E[Y2|Y1]) = Var(Y1*p) = p²*Var(Y1) = 0.16*115*0.4*0.6 = 4.416
"""
    },
    
    3: {
        'code': """
# Билет 3: Распределение случайного вектора
import numpy as np

def solve_ticket3():
    \"\"\"Вычисляет вероятности и условные ожидания для (X,Y)\"\"\"
    # Совместное распределение
    joint = {
        (2,9): 0.30, (4,9): 0.04, (7,9): 0.30,
        (2,11): 0.16, (4,11): 0.09, (7,11): 0.11
    }
    
    # 1-2) Вероятности P(Y=9) и P(Y=11)
    p1 = sum(v for (x,y), v in joint.items() if y == 9)
    p2 = sum(v for (x,y), v in joint.items() if y == 11)
    
    # 3) E[X|Y=9]
    e3 = sum(x*v for (x,y), v in joint.items() if y == 9) / p1
    
    # 4) E[X|Y=11]
    e4 = sum(x*v for (x,y), v in joint.items() if y == 11) / p2
    
    # 5) E[E[X|Y]]
    e5 = e3*p1 + e4*p2
    
    return {
        'P(Y=9)': round(p1, 3),
        'P(Y=11)': round(p2, 3),
        'E[X|Y=9]': round(e3, 3),
        'E[X|Y=11]': round(e4, 3),
        'E[E[X|Y]]': round(e5, 3)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):

1. Вероятности маргинального распределения Y:
   P(Y=9) = 0.30 + 0.04 + 0.30 = 0.64
   P(Y=11) = 0.16 + 0.09 + 0.11 = 0.36

2. Условные распределения:
   P(X|Y=9):
     X=2: 0.30/0.64 = 0.46875
     X=4: 0.04/0.64 = 0.0625
     X=7: 0.30/0.64 = 0.46875
   E[X|Y=9] = 2*0.46875 + 4*0.0625 + 7*0.46875 ≈ 4.531

   P(X|Y=11):
     X=2: 0.16/0.36 ≈ 0.444
     X=4: 0.09/0.36 = 0.25
     X=7: 0.11/0.36 ≈ 0.306
   E[X|Y=11] ≈ 2*0.444 + 4*0.25 + 7*0.306 ≈ 4.03

3. Полное мат. ожидание:
   E[X] = E[E[X|Y]] = 4.531*0.64 + 4.03*0.36 ≈ 4.34
"""
    }
}

def show_solution(ticket_number):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution(1)
    show_solution(2)
    show_solution(3)