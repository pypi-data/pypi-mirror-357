"""Модуль с решениями третьих задач билетов 1-20 (код + теория)"""

SOLUTIONS = {
    'шары': {
        'code': """
# Билет 1: Ковариация количества красных и синих шаров
from scipy.stats import hypergeom

def solve_ticket1():
    \"\"\"Вычисляет Cov(X,Y) для гипергеометрического распределения\"\"\"
    N = 63   # всего шаров
    K_red = 18  # красные шары
    K_blue = 6   # синие шары
    n = 24      # количество извлечений
    
    # Формула ковариации для гипергеометрического распределения
    cov = -n * (K_red/N) * (K_blue/N) * (N - n)/(N - 1)
    return round(cov, 4)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):

Для гипергеометрического распределения:
Cov(X,Y) = -n * (K₁/N) * (K₂/N) * (N - n)/(N - 1)

Где:
N = 63 (общее количество шаров)
K₁ = 18 (количество красных шаров)
K₂ = 6 (количество синих шаров)
n = 24 (количество извлечений)

Ковариация отрицательна, так как увеличение количества 
одного цвета уменьшает вероятность появления другого.
"""
    },
    
    'акции': {
        'code': """
# Билет 2: Минимальная дисперсия портфеля акций
import numpy as np

def solve_ticket2():
    \"\"\"Вычисляет оптимальные веса акций для минимальной дисперсии\"\"\"
    returns = np.array([0.02, 0.03, 0.04])  # доходности A, B, C
    stds = np.array([0.03, 0.05, 0.06])     # стандартные отклонения
    
    # Матрица ковариаций (предполагаем независимость)
    cov_matrix = np.diag(stds**2)
    
    # Решение задачи оптимизации
    ones = np.ones(3)
    inv_cov = np.linalg.inv(cov_matrix)
    w = inv_cov @ ones / (ones.T @ inv_cov @ ones)
    
    expected_return = w @ returns
    portfolio_variance = 1 / (ones.T @ inv_cov @ ones)
    
    return {
        'weights': np.round(w, 4),
        'expected_return': round(expected_return, 4),
        'std': round(np.sqrt(portfolio_variance), 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2):

Для портфеля с минимальной дисперсией при независимых акциях:
1. Матрица ковариаций Σ = diag(σ₁², σ₂², σ₃²)
2. Оптимальные веса: w = Σ⁻¹·1 / (1ᵀ·Σ⁻¹·1)
3. Ожидаемая доходность: μ = wᵀ·r
4. Дисперсия портфеля: σ² = 1 / (1ᵀ·Σ⁻¹·1)

Где:
r = [2%, 3%, 4%] - вектор доходностей
σ = [3%, 5%, 6%] - стандартные отклонения
"""
    },
    
    'портфель': {
        'code': """
# Билет 3: Стандартное отклонение портфеля
def solve_ticket3():
    \"\"\"Вычисляет стандартное отклонение портфеля\"\"\"
    w_A = 10/11  # доля акций A (в 10 раз больше B)
    w_B = 1/11    # доля акций B
    
    mean_A, mean_B = 0.01, 0.05
    std_A, std_B = 0.03, 0.08
    rho = 0.4
    
    portfolio_variance = (w_A**2 * std_A**2 + w_B**2 * std_B**2 + 
                         2 * w_A * w_B * rho * std_A * std_B)
    return round(np.sqrt(portfolio_variance), 4)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):

Формула дисперсии портфеля из двух активов:
σ² = w₁²σ₁² + w₂²σ₂² + 2w₁w₂ρσ₁σ₂

Где:
w₁ = 10/11, w₂ = 1/11 (доли акций)
σ₁ = 3%, σ₂ = 8% (стандартные отклонения)
ρ = 0.4 (корреляция)
"""
    },
    
    'монеты': {
        'code': """
# Билет 4: Монеты и количество бросков
import numpy as np
from scipy.stats import binom

def solve_ticket4():
    \"\"\"Вычисляет характеристики для бросков монет\"\"\"
    n = 15       # количество монет
    p = 0.4      # вероятность орла
    k = 7        # целевое количество орлов
    
    # 1) Мат. ожидание числа бросков до первого появления 7 орлов
    # Используем отрицательное биномиальное распределение
    mean_X = k / (n * p)
    
    # 2) Стандартное отклонение X
    std_X = np.sqrt(k * (1 - p) / (n**2 * p**2))
    
    # 3) Коэффициент корреляции между X и Y
    # Y = X + геометрическое, поэтому корреляция близка к 1
    rho = np.sqrt(k / (k + (1-p)/p))
    
    # 4) Мат. ожидание XY (приближенно)
    mean_XY = mean_X * (mean_X + 1/(n*p))
    
    return {
        'E[X]': round(mean_X, 4),
        'std(X)': round(std_X, 4),
        'ρ(X,Y)': round(rho, 4),
        'E[XY]': round(mean_XY, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 4):

1. X ~ Отрицательное биномиальное распределение:
   E[X] = k/(n*p)
   Var(X) = k*(1-p)/(n²*p²)

2. Y = X + дополнительное время до последнего успеха:
   Корреляция ρ(X,Y) ≈ sqrt(k/(k + (1-p)/p))

3. E[XY] ≈ E[X]·E[Y] + Cov(X,Y)
"""
    },

    'семена': {
        'code': """
# Билет 5: Прорастание семян
import numpy as np

def solve_ticket5():
    \"\"\"Вычисляет параметры для проросших семян\"\"\"
    n1, p1 = 290, 0.91  # первая партия
    n2, p2 = 160, 0.92  # вторая партия
    
    # 1) Стандартное отклонение S
    var_S = n1*p1*(1-p1) + n2*p2*(1-p2)
    std_S = np.sqrt(var_S)
    
    # 2) Асимметрия S (используем свойство аддитивности)
    skew_S = (n1*p1*(1-p1)*(1-2*p1) + n2*p2*(1-p2)*(1-2*p2)) / (var_S**1.5)
    
    return {
        'std(S)': round(std_S, 4),
        'As(S)': round(skew_S, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 5):

Для суммы независимых биномиальных случайных величин:
1. Дисперсия: Var(S) = Σ nᵢpᵢ(1-pᵢ)
2. Асимметрия: γ₁ = [Σ nᵢpᵢ(1-pᵢ)(1-2pᵢ)] / Var(S)^(3/2)
"""
    },

    'случайные величины': {
        'code': """
# Билет 6: Случайные величины с тремя значениями
import numpy as np

def solve_ticket6():
    \"\"\"Вычисляет ковариацию и дисперсию суммы\"\"\"
    # Вероятности значений
    p0, p1 = 0.4, 0.3
    p5 = 1 - p0 - p1
    
    # 1) Ковариация между Xi и Xj (i ≠ j)
    # Известно: P(Xi + Xj = 2) = 0.12 и т.д.
    # Можно составить систему уравнений
    cov = 0.12 - p1**2  # из P(Xi=1 & Xj=1) = 0.12
    
    # 2) Дисперсия суммы S = X1 + ... + X11
    EX = 0*p0 + 1*p1 + 5*p5
    EX2 = 0*p0 + 1*p1 + 25*p5
    var_xi = EX2 - EX**2
    
    var_S = 11*var_xi + 11*10*cov
    
    return {
        'Cov(Xi,Xj)': round(cov, 4),
        'Var(S)': round(var_S, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 6):

1. Ковариация:
   Cov(Xi,Xj) = E[XiXj] - E[Xi]E[Xj]
   Из P(Xi+Xj=2) = P(Xi=1,Xj=1) = 0.12

2. Дисперсия суммы:
   Var(S) = n·Var(Xi) + n(n-1)·Cov(Xi,Xj)
"""
    },

    'акции2': {
        'code': """
# Билет 7: Оптимальный портфель акций
import numpy as np

def solve_ticket7():
    \"\"\"Вычисляет оптимальные доли акций\"\"\"
    mean_A, mean_B = 0.01, 0.02  # доходности
    std_A, std_B = 0.03, 0.05    # риски
    rho = 0.31                    # корреляция
    
    # Минимизация дисперсии портфеля
    cov = rho * std_A * std_B
    cov_matrix = np.array([
        [std_A**2, cov],
        [cov, std_B**2]
    ])
    
    inv_cov = np.linalg.inv(cov_matrix)
    ones = np.ones(2)
    w = inv_cov @ ones / (ones.T @ inv_cov @ ones)
    
    # Ожидаемая доходность и риск портфеля
    mean_port = w[0]*mean_A + w[1]*mean_B
    var_port = 1 / (ones.T @ inv_cov @ ones)
    
    return {
        'weights': np.round(w, 4),
        'expected_return': round(mean_port, 4),
        'std_dev': round(np.sqrt(var_port), 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 7):

Формулы для портфеля с минимальной дисперсией:
1. Веса: w = Σ⁻¹·1 / (1ᵀ·Σ⁻¹·1)
2. Доходность: μ = wᵀ·r
3. Дисперсия: σ² = 1/(1ᵀ·Σ⁻¹·1)

Где Σ - матрица ковариаций активов
"""
    },

    'номера шаров': {
        'code': """
# Билет 9: Сумма номеров шаров
import numpy as np

def solve_ticket9():
    \"\"\"Вычисляет мат. ожидание и дисперсию суммы номеров\"\"\"
    N = 35       # всего шаров
    n = 20       # извлекаем шаров
    mean = (N + 1)/2  # мат. ожидание одного шара
    
    # 1) Мат. ожидание суммы
    E_S = n * mean
    
    # 2) Дисперсия суммы
    var_one = (N**2 - 1)/12  # дисперсия одного шара
    cov = -var_one/(N - 1)   # ковариация (без возвращения)
    var_S = n*var_one + n*(n-1)*cov
    
    return {
        'E[S]': round(E_S, 4),
        'Var(S)': round(var_S, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 9):

Для выборки без возвращения:
1. E[S] = n·(N+1)/2
2. Var(S) = n·Var(X₁) + n(n-1)·Cov(X₁,X₂)
   где Var(X₁) = (N²-1)/12
   Cov(X₁,X₂) = -Var(X₁)/(N-1)
"""
    },

    'пуассон': {
        'code': """
# Билет 12: Пуассоновские случайные величины
import numpy as np
from scipy.stats import poisson

def solve_ticket12():
    \"\"\"Вычисляет параметры суммы пуассоновских величин\"\"\"
    # Из стандартных отклонений находим параметры
    lambda_x = 1.5**2  # σ² = λ для Пуассона
    lambda_y = 1.3**2
    lambda_z = 1.3**2
    
    lambda_s = lambda_x + lambda_y + lambda_z
    
    # 1) P(S = 7)
    p7 = poisson.pmf(7, lambda_s)
    
    # 2) Наиболее вероятное значение
    mode = int(lambda_s)
    
    # 3) Стандартное отклонение
    std_s = np.sqrt(lambda_s)
    
    # 4) Асимметрия и эксцесс
    skew = 1/np.sqrt(lambda_s)
    kurtosis = 1/lambda_s
    
    return {
        'P(S=7)': round(p7, 4),
        'Mode(S)': mode,
        'std(S)': round(std_s, 4),
        'As(S)': round(skew, 4),
        'Ex(S)': round(kurtosis, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 12):

Для суммы независимых пуассоновских величин:
1. S ~ Poisson(λ₁ + λ₂ + λ₃)
2. Мода: floor(λ)
3. Асимметрия: γ₁ = λ^(-1/2)
4. Эксцесс: γ₂ = λ^(-1)
"""
    },

    'пуассон2': {
        'code': """
# Билет 15: Независимые пуассоновские случайные величины
from scipy.stats import poisson
import numpy as np

def solve_ticket15():
    \"\"\"Вычисляет характеристики суммы пуассоновских величин\"\"\"
    # Находим параметры по заданным стандартным отклонениям
    lambda_x = 1.5**2  # σ² = λ для Пуассона
    lambda_y = 1.3**2
    lambda_z = 1.3**2
    
    # Сумма имеет распределение Пуассона(λ_x + λ_y + λ_z)
    total_lambda = lambda_x + lambda_y + lambda_z
    
    # 1) P(S=7)
    p7 = poisson.pmf(7, total_lambda)
    
    # 2) Наиболее вероятное значение (целая часть λ)
    mode = int(total_lambda)
    
    # 3) Стандартное отклонение
    sigma = np.sqrt(total_lambda)
    
    # 4) Асимметрия (1/√λ)
    skewness = 1/np.sqrt(total_lambda)
    
    # 5) Эксцесс (1/λ)
    kurtosis = 1/total_lambda
    
    return {
        'P(S=7)': round(p7, 4),
        'Mode': mode,
        'σ': round(sigma, 4),
        'As': round(skewness, 4),
        'Ex': round(kurtosis, 4)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 15):

Для независимых пуассоновских величин:
1. S = X + Y + Z ~ Poisson(λ_x + λ_y + λ_z)
2. Параметры находим из σ² = λ:
   λ_x = 1.5² = 2.25
   λ_y = λ_z = 1.3² = 1.69
3. Общий параметр: λ = 2.25 + 1.69 + 1.69 = 5.63

Характеристики распределения:
1. P(S=7) = e^{-λ}·λ^7/7!
2. Мода: ⌊λ⌋ = 5
3. σ = √λ ≈ 2.3727
4. Асимметрия: 1/√λ ≈ 0.4215
5. Эксцесс: 1/λ ≈ 0.1776
"""
    }
}


def show_solution(ticket_number):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution('шары')
    show_solution('монеты')
    show_solution('портфель')
    show_solution('акции')
    show_solution('акции2')
    show_solution('пуассон')
    show_solution('пуассон2')
    show_solution('семена')
    show_solution('номера шаров')
    show_solution('случайные величины')

