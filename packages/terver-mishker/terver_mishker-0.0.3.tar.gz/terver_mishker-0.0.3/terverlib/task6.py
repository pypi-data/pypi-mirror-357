# task6.py
"""Модуль с решениями шестых задач билетов 1-3 (код + теория)"""

SOLUTIONS = {
    1: {
        'code': """
# Билет 1: Суммарный ущерб от страховых случаев
import numpy as np
from scipy.stats import poisson, uniform

def solve_ticket1():
    \"\"\"Вычисляет:
    1) Мат. ожидание суммарного ущерба за год
    2) Стандартное отклонение суммарного ущерба
    \"\"\"
    # Параметры распределений
    lambda_ = 16/5  # Интенсивность Пуассона (случаев/год)
    max_damage = 3.4  # Максимальный ущерб (млн руб)
    
    # 1) Математическое ожидание
    E_N = lambda_
    E_X = max_damage / 2  # Для равномерного распределения
    E_total = E_N * E_X
    
    # 2) Стандартное отклонение
    Var_N = lambda_
    Var_X = max_damage**2 / 12  # Для равномерного распределения
    Var_total = E_N * Var_X + Var_N * E_X**2
    std_total = np.sqrt(Var_total)
    
    return round(E_total, 3), round(std_total, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):
Максимальный ущерб от страхового случая составляет 3,4 млн. руб. Предполагается, что фактический ущерб
распределен равномерно от 0 до максимального ущерба, а число страховых случаев за год - по закону Пуассона.
Также известно, что за 5 лет в среднем происходит 16 страховых случаев. Найдите: 1) математическое ожидание
суммарного ущерба от всех страховых случаев за один год; 2) стандартное отклонение суммарного ущерба от
страховых случаев за год.
1. Суммарный ущерб S = Σ_{i=1}^N X_i, где:
   - N ~ Poisson(λ=16/5) - число страховых случаев
   - X_i ~ Uniform(0, 3.4) - размер ущерба

2. Математическое ожидание:
   E[S] = E[N] * E[X] = λ * (a+b)/2 = 3.2 * 1.7 = 5.44

3. Дисперсия (по формуле для сложного пуассоновского процесса):
   Var(S) = E[N]*Var(X) + Var(N)*E[X]^2 = λ*(b-a)^2/12 + λ*( (a+b)/2 )^2
   = 3.2*(3.4^2)/12 + 3.2*(1.7)^2 ≈ 3.2*0.9633 + 3.2*2.89 ≈ 3.0826 + 9.248 = 12.3306
   σ_S = √12.3306 ≈ 3.511
"""
    },
    
    2: {
        'code': """
# Билет 2: Бросание несимметричных монет
from scipy.stats import binom

def solve_ticket2():
    \"\"\"Вычисляет:
    1) E[Var(Y2|Y1)]
    2) Var(E[Y2|Y1])
    \"\"\"
    n = 115  # Число монет
    p = 0.4  # Вероятность орла
    
    # 1) Условная дисперсия: Var(Y2|Y1=k) = k*p*(1-p)
    # E[Var(Y2|Y1)] = E[Y1]*p*(1-p) = n*p * p*(1-p) = n*p^2*(1-p)
    evar = n * p**2 * (1 - p)
    
    # 2) Дисперсия условного мат. ожидания: Var(E[Y2|Y1]) = Var(Y1*p) = p^2*Var(Y1)
    vare = p**2 * n * p * (1 - p)
    
    return round(evar, 3), round(vare, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2):
В первом броске участвуют 115 несимметричных монет. Во втором броске участвуют только те монеты, на которых в первом
броске выпал "орел". Известно, что вероятность выпадения "орла" для данных несимметричных монет равна 0,4. Найдите: 1)
математическое ожидание условной дисперсии числа "орлов", выпавших во втором броске, относительно числа "орлов",
выпавших в первом броске; 2) дисперсию условного математического ожидания числа "орлов", выпавших во втором броске,
относительно числа "орлов", выпавших в первом броске.

1. Y1 ~ Binomial(n=115, p=0.4) - число орлов в первом броске
   Y2|Y1=k ~ Binomial(k, p=0.4) - число орлов во втором броске

2. По формуле полной дисперсии:
   Var(Y2) = E[Var(Y2|Y1)] + Var(E[Y2|Y1])

3. Вычисляем компоненты:
   - E[Var(Y2|Y1)] = E[Y1*p*(1-p)] = n*p * p*(1-p) = 115*0.4*0.4*0.6 = 11.04
   - Var(E[Y2|Y1]) = Var(Y1*p) = p²*Var(Y1) = 0.16*115*0.4*0.6 = 4.416
"""
    },

    3: {
        'code': """
# Билет 7: Бросание несимметричных монет
import numpy as np

# Параметры задачи
n_coins = 56  # количество монет
p = 0.6       # вероятность "орла"

# 1) Математическое ожидание числа "орлов" во втором броске
# E[Y] = E[E[Y|X]] = E[0.6 * X] = 0.6 * E[X] = 0.6 * (n_coins * p)
E_X = n_coins * p
E_Y = p * E_X
print(f"1) Математическое ожидание числа 'орлов' во втором броске: {E_Y:.3f}")

# 2) Матожидание условной дисперсии Var(Y|X)
# Var(Y|X) = X * p * (1 - p) = X * 0.24
# E[Var(Y|X)] = 0.24 * E[X] = 0.24 * (n_coins * p)
E_conditional_var = 0.24 * E_X
print(f"2) Матожидание условной дисперсии: {E_conditional_var:.4f}")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 7):
В первом броске участвуют 56 несимметричных монет. Во втором броске участвуют только те монеты, на которых в первом броске
выпал "орел". Известно, что вероятность выпадения "орла" для данных несимметричных монет равна 0,6. Найдите: 1) математическое
ожидание числа "орлов", выпавших во втором броске; 2) математическое ожидание условной дисперсии числа "орлов", выпавших во
втором броске, относительно числа "орлов", выпавших в первом броске.
# 1) Математическое ожидание числа "орлов" во втором броске:
#    - В первом броске X ~ Binomial(n=56, p=0.6)
#    - E[X] = n*p = 56*0.6 = 33.6
#    - Во втором броске участвуют X монет, каждая снова с p=0.6
#    - Y|X ~ Binomial(X, 0.6) ⇒ E[Y|X] = 0.6*X
#    - По свойству полного матожидания:
#      E[Y] = E[E[Y|X]] = E[0.6*X] = 0.6*E[X] = 0.6*33.6 = 20.16
#
# 2) Мат. ожидание условной дисперсии:
#    - Условная дисперсия Var(Y|X) = X*p*(1-p) = X*0.6*0.4 = 0.24*X
#    - E[Var(Y|X)] = E[0.24*X] = 0.24*E[X] = 0.24*33.6 = 8.064
#
# Результаты:
# 1) E[Y] = 20.160
# 2) E[Var(Y|X)] = 8.0640


"""
    },

    4: {
        'code': """
# Билет 15: Для случайной цены Y известны вероятности
import numpy as np

# Параметры распределения
y_values = np.array([9, 18])
p_y = np.array([0.4, 0.6])

# 1) Вычисление E[X]
E_Y = np.sum(y_values * p_y)  # E[Y] = 14.4
E_X = 3 * E_Y                 # E[X] = 43.2

# 2) Вычисление Cov(X,Y)
E_Y2 = np.sum(y_values**2 * p_y)  # E[Y²] = 226.8
E_XY = 3 * E_Y2                   # E[XY] = 680.4
cov_XY = E_XY - E_X * E_Y          # Cov(X,Y) = 58.32

print(f"1) Математическое ожидание E[XY] = {E_XY:.1f}")
print(f"2) Ковариация Cov(X,Y) = {cov_XY:.4f}")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 15):
Для случайной цены Y известны вероятности: P(Y = 9) = 0, 4 и P(Y = 18) = 0, 6. При условии, что ,
распределение выручки является равномерным на отрезке 0, 6y. Найдите: 1) математическое ожидание E_XY ; 2)
ковариацию cov_XY.
# 1) Находим E[X]:
#    - Для равномерного распределения:
#      E[X|Y=y] = (0 + 6y)/2 = 3y
#    - По формуле полного матожидания:
#      E[X] = E[E[X|Y]] = E[3Y] = 3E[Y]
#    - Вычисляем E[Y]:
#      E[Y] = 9*0.4 + 18*0.6 = 3.6 + 10.8 = 14.4
#    - Тогда E[X] = 3*14.4 = 43.2
#
# 2) Находим Cov(X,Y):
#    - Cov(X,Y) = E[XY] - E[X]E[Y]
#    - Находим E[XY]:
#      E[XY|Y=y] = y*E[X|Y=y] = y*3y = 3y²
#      E[XY] = E[E[XY|Y]] = E[3Y²] = 3E[Y²]
#    - Вычисляем E[Y²]:
#      E[Y²] = 9²*0.4 + 18²*0.6 = 81*0.4 + 324*0.6 = 32.4 + 194.4 = 226.8
#    - Тогда E[XY] = 3*226.8 = 680.4
#    - Ковариация:
#      Cov(X,Y) = 680.4 - 43.2*14.4 = 680.4 - 622.08 = 58.32
#
# Результаты:
# 1) E[X] = 43.2
# 2) Cov(X,Y) = 58.3200

"""
    },
    
    5: {
        'code': """
# Билет 3: Распределение случайного вектора
import numpy as np

def solve_ticket3():
    \"\"\"Вычисляет вероятности и условные ожидания для (X,Y)\"\"\"
    # Совместное распределение
    joint = {
        (2,9): 0.30, (4,9): 0.04, (7,9): 0.30,
        (2,11): 0.16, (4,11): 0.09, (7,11): 0.11
    }
    
    # 1-2) Вероятности P(Y=9) и P(Y=11)
    p1 = sum(v for (x,y), v in joint.items() if y == 9)
    p2 = sum(v for (x,y), v in joint.items() if y == 11)
    
    # 3) E[X|Y=9]
    e3 = sum(x*v for (x,y), v in joint.items() if y == 9) / p1
    
    # 4) E[X|Y=11]
    e4 = sum(x*v for (x,y), v in joint.items() if y == 11) / p2
    
    # 5) E[E[X|Y]]
    e5 = e3*p1 + e4*p2
    
    return {
        'P(Y=9)': round(p1, 3),
        'P(Y=11)': round(p2, 3),
        'E[X|Y=9]': round(e3, 3),
        'E[X|Y=11]': round(e4, 3),
        'E[E[X|Y]]': round(e5, 3)
    }
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):

1. Вероятности маргинального распределения Y:
   P(Y=9) = 0.30 + 0.04 + 0.30 = 0.64
   P(Y=11) = 0.16 + 0.09 + 0.11 = 0.36

2. Условные распределения:
   P(X|Y=9):
     X=2: 0.30/0.64 = 0.46875
     X=4: 0.04/0.64 = 0.0625
     X=7: 0.30/0.64 = 0.46875
   E[X|Y=9] = 2*0.46875 + 4*0.0625 + 7*0.46875 ≈ 4.531

   P(X|Y=11):
     X=2: 0.16/0.36 ≈ 0.444
     X=4: 0.09/0.36 = 0.25
     X=7: 0.11/0.36 ≈ 0.306
   E[X|Y=11] ≈ 2*0.444 + 4*0.25 + 7*0.306 ≈ 4.03

3. Полное мат. ожидание:
   E[X] = E[E[X|Y]] = 4.531*0.64 + 4.03*0.36 ≈ 4.34
"""
    },

    6: {
        'code': """
# Билет 17: Игральная кость и 25 монет подбрасываются до тех пор
def f():
    n_coins = 25
    target_heads = 15
    p_head = 0.5
    p_success = comb(n_coins, target_heads) * (p_head ** n_coins)
    E_N = 1 / p_success
    Var_N = (1 - p_success) / (p_success ** 2)
    E_dice = 3.5
    count_sides = 6
    Var_dice = (count_sides ** 2 - 1) / 12
    E_S = E_N * E_dice
    Var_S = E_N * Var_dice + (E_dice ** 2) * Var_N
    sigma_S = np.sqrt(Var_S)
    print(f"1) {E_S:.4f}")
    print(f"2) {sigma_S:.4f}")
result = f()
print(result)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):
Игральная кость и 25 монет подбрасываются до тех пор, пока в очередном броске не выпадет ровно 15 "орлов". Пусть S –
суммарное число очков, выпавших на игральной кости при всех бросках. Найдите: 1) математическое ожидание E(S) ; 2)
стандартное отклонение q(s).
# 1. Определение случайных величин:
#    - N - число бросков 25 монет до первого появления ровно 15 "орлов"
#    - X_i - очки на игральной кости в i-м броске (равномерное распределение от 1 до 6)
#    - S = X_1 + X_2 + ... + X_N - сумма очков за все броски

# 2. Распределение N:
#    - Вероятность успеха p = C(25,15)*(0.5)^25 ≈ 0.0974166
#    - N имеет геометрическое распределение: N ~ Geom(p)
#    - E[N] = 1/p ≈ 10.266
#    - Var(N) = (1-p)/p^2 ≈ 99.33

# 3. Распределение X_i:
#    - E[X_i] = 3.5 (среднее значение для игральной кости)
#    - Var(X_i) = 35/12 ≈ 2.9167 (дисперсия для игральной кости)

# 4. Математическое ожидание S:
#    E[S] = E[N]*E[X_i] ≈ 10.266*3.5 ≈ 35.9282

# 5. Дисперсия и стандартное отклонение S:
#    Var(S) = E[N]*Var(X_i) + Var(N)*(E[X_i])^2 
#           ≈ 10.266*2.9167 + 99.33*12.25 ≈ 1194.9
#    σ_S = sqrt(Var(S)) ≈ sqrt(1194.9) ≈ 34.5691

"""
    }
}

def show_solution(ticket_number):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution(1)
    show_solution(2)
    show_solution(3)
    show_solution(4)
    show_solution(5)
    show_solution(6)