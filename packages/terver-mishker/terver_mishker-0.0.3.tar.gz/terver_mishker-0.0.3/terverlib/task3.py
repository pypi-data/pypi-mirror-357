"""Модуль с решениями третьих задач билетов 1-20 (код + теория)"""

SOLUTIONS = {
    'шары': {
        'code': """
# Билет 1: Ковариация количества красных и синих шаров
from scipy.stats import hypergeom

N = 63  # общее количество шаров
K = 18  # количество красных шаров
L = 6   # количество синих шаров
n = 24  # количество извлечённых шаров

cov_xy_formula = -n * K * (L / N ** 2) * (N - n) / (N - 1)
print(cov_xy_formula)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):
Корзина содержит 63 шара, среди которых 18 — красных и 6 — синих. Из корзины случайным образом, без возвращения извлекаются 24 шара. Пусть  X  и  Y  обозначают количество красных и синих шаров среди извлечённых соответственно. Найдите ковариацию  Cov(X,Y) .
Для гипергеометрического распределения:
Cov(X,Y) = -n * (K₁/N) * (K₂/N) * (N - n)/(N - 1)

Где:
N = 63 (общее количество шаров)
K₁ = 18 (количество красных шаров)
K₂ = 6 (количество синих шаров)
n = 24 (количество извлечений)

Ковариация отрицательна, так как увеличение количества 
одного цвета уменьшает вероятность появления другого.
"""
    },
    
    'акции': {
        'code': """
# Билет 2: Минимальная дисперсия портфеля акций
returns = np.array([0.02, 0.03, 0.04])  # Ожидаемые доходности A, B, C (%)
volatilities = np.array([0.03, 0.05, 0.06])  # Стандартные отклонения A, B, C (%)

# 1) Оптимальные веса для минимальной дисперсии (независимые активы)
weights = 1 / volatilities**2
weights /= weights.sum()  # Нормировка

# Ожидаемая доходность портфеля
portfolio_return = np.dot(weights, returns)
otv= portfolio_return * 100

print(f"1) {otv:.3f}")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2):
Ожидаемая доходность и стандартное отклонение доходности за период для акций компаний  A ,  B ,  C  составляют:

2%, 3%, 4%
3%, 5%, 6%
Предполагая независимость доходностей акций  A ,  B  и  C , найдите (в %) ожидаемую доходность портфеля, составленного из этих акций так, что дисперсия его доходности близка к минимальной.
Для портфеля с минимальной дисперсией при независимых акциях:
1. Матрица ковариаций Σ = diag(σ₁², σ₂², σ₃²)
2. Оптимальные веса: w = Σ⁻¹·1 / (1ᵀ·Σ⁻¹·1)
3. Ожидаемая доходность: μ = wᵀ·r
4. Дисперсия портфеля: σ² = 1 / (1ᵀ·Σ⁻¹·1)

Где:
r = [2%, 3%, 4%] - вектор доходностей
σ = [3%, 5%, 6%] - стандартные отклонения
"""
    },
    
    'портфель': {
        'code': """
# Билет 3: Стандартное отклонение портфеля
w_A = 10 / (10 + 1)  # Доля акций A (10 частей из 11)
w_B = 1 / (10 + 1)    # Доля акций B (1 часть из 11)
E_A, E_B = 0.01, 0.05  # Ожидаемые доходности (%)
sigma_A, sigma_B = 0.03, 0.08  # Стандартные отклонения (%)
rho = 0.4  # Коэффициент корреляции

# Расчет ковариации
cov = rho * sigma_A * sigma_B

# Стандартное отклонение портфеля
sigma_portfolio = np.sqrt(w_A**2 * sigma_A**2 + w_B**2 * sigma_B**2 + 2 * w_A * w_B * cov)
otv = sigma_portfolio * 100
print(f"1) {otv:.6f}")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):
Инвестор сформировал портфель из акций компаний  A  и  B , затратив на приобретение акций  A  в 10 раз больше средств, чем на покупку акций  B . Ожидаемая доходность за период владения акциями  A  и  B  составляет 1% и 5%, при этом стандартное отклонение доходности равно 3% и 8% соответственно.

Найдите (в %) стандартное отклонение доходности портфеля инвестора, если известно, что коэффициент корреляции доходностей акций  A  и  B  равен 0,4.
Формула дисперсии портфеля из двух активов:
σ² = w₁²σ₁² + w₂²σ₂² + 2w₁w₂ρσ₁σ₂

Где:
w₁ = 10/11, w₂ = 1/11 (доли акций)
σ₁ = 3%, σ₂ = 8% (стандартные отклонения)
ρ = 0.4 (корреляция)
"""
    },
    
    'монеты': {
        'code': """
# Билет 4: Монеты и количество бросков
import numpy as np
from scipy.stats import binom

n_coins = 15
k_success = 7
total_successes = 20

p_success = binomial(n_coins, k_success) / (2 ** n_coins)
p = Rational(p_success)
E_X = 1 / p
var_X = (1 - p) / p**2
sigma_X = np.sqrt(float(var_X))
cov_XY = var_X
var_Y = total_successes * (1 - p) / p**2
rho_XY = cov_XY / np.sqrt(float(var_X * var_Y))
E_Y = total_successes / p
E_XY = float(cov_XY + E_X * E_Y)

print(E_X)
print(sigma_X)
print(rho_XY, 3)
print(E_XY, 1)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 4):
Монеты в количестве 15 штук подбрасываются до тех пор, пока 20 раз не выпадет 7 гербов. Пусть  X  — число бросков до первого появления 7 гербов, а  Y  — число бросков до последнего появления 7 гербов ( Y  — общее число бросков). Найдите:

Математическое ожидание  E(X) ;
Стандартное отклонение  X ;
Коэффициент корреляции между  X  и  Y ;
Математическое ожидание  E(XY) .
1. X ~ Отрицательное биномиальное распределение:
   E[X] = k/(n*p)
   Var(X) = k*(1-p)/(n²*p²)

2. Y = X + дополнительное время до последнего успеха:
   Корреляция ρ(X,Y) ≈ sqrt(k/(k + (1-p)/p))

3. E[XY] ≈ E[X]·E[Y] + Cov(X,Y)
"""
    },

    'семена': {
        'code': """
# Билет 5: Прорастание семян
n1, p1 = 290, 0.91
n2, p2 = 160, 0.92

X = Binomial('X', n1, p1)
Y = Binomial('Y', n2, p2)
S = X + Y

asymm = skewness(S)
var = variance(S)

print(var ** 0.5)
print(asymm.evalf(), 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 5):
Селекционер отобрал для проращивания семена из двух партий: 290 — из первой партии и 160 — из второй. Известно, что семена из первой партии прорастают с вероятностью 0,91, а из второй — с вероятностью 0,92. Пусть  S  — суммарное количество проросших семян в обеих партиях. Предполагая независимость процессов прорастания, найдите:

Стандартное отклонение  S ;
Асимметрию  S .
Указание: Используйте свойство аддитивности третьего центрального момента.
Для суммы независимых биномиальных случайных величин:
1. Дисперсия: Var(S) = Σ nᵢpᵢ(1-pᵢ)
2. Асимметрия: γ₁ = [Σ nᵢpᵢ(1-pᵢ)(1-2pᵢ)] / Var(S)^(3/2)
"""
    },

    'случайные величины': {
        'code': """
# Билет 6: Случайные величины с тремя значениями
vals = [0, 1, 5]
probs = [0.4, 0.3, 0.3]
X = rv_discrete(name='X', values=(vals, probs))

E_X = X.expect()
VarE_X = X.var()

probs_sum = [0.12, 0.15, 0.1]
E_Xi_Xj = (vals[1] * probs_sum[0] + vals[2] * probs_sum[1] + vals[2] ** 2 * probs_sum[2])
Cov_Xi_Xj = E_Xi_Xj - E_X ** 2
print(Cov_Xi_Xj)

n = 11
Var_S = n * VarE_X + n * (n - 1) * Cov_Xi_Xj
print(Var_S)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 6):
Случайные величины  X1,…,X11  могут принимать только три значения: 0, 1 и 5. Известны вероятности:

P(Xi=0)=0,4 ;
P(Xi=1)=0,3  для  i=1,…,11 .
Кроме того, известны:

P(Xi+Xj=2)=0,12 ;
P(Xi+Xj=6)=0,15 ;
P(Xi+Xj=10)=0,10  для  1≤i<j≤11 .
Пусть  S=X1+…+X11 . Найдите:

Ковариацию  Cov(Xi,Xj)  для  i≠j ;
Дисперсию  Var(S) .
1. Ковариация:
   Cov(Xi,Xj) = E[XiXj] - E[Xi]E[Xj]
   Из P(Xi+Xj=2) = P(Xi=1,Xj=1) = 0.12

2. Дисперсия суммы:
   Var(S) = n·Var(Xi) + n(n-1)·Cov(Xi,Xj)
"""
    },

    'акции2': {
        'code': """
# Билет 7: Оптимальный портфель акций
E_A, E_B = 0.01, 0.02  # Мат. ожидания доходностей
sigma_A, sigma_B = 0.03, 0.05  # Стандартные отклонения
rho = 0.31  # Коэффициент корреляции

# 1) Доли акций A и B в портфеле с минимальной дисперсией
cov = rho * sigma_A * sigma_B  # Ковариация
w_A = (sigma_B**2 - cov) / (sigma_A**2 + sigma_B**2 - 2*cov)
w_B = 1 - w_A

# 2) Ожидаемая доходность и стандартное отклонение портфеля
E_portfolio = w_A * E_A + w_B * E_B
sigma_portfolio = np.sqrt(w_A**2 * sigma_A**2 + w_B**2 * sigma_B**2 + 2*w_A*w_B*cov)

print(f"1) Доля A = {w_A:.3f}; Доля B = {w_B:.3f}")
print(f"2) Ожидаемая доходность = {E_portfolio:.4f}%; Стандартное отклонение = {sigma_portfolio:.5f}%")
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 7):
Математическое ожидание доходности акций компаний  A  и  B  составляет 1% и 2%, при этом стандартное отклонение доходности равно 3% и 5% соответственно. Также известен коэффициент корреляции доходностей акций  A  и  B :  ρAB=0,31 .
Найдите (краткие пояснения допускаются):

Доли акций  A  и  B  в портфеле с минимальной дисперсией доходности;
Ожидаемую доходность и стандартное отклонение доходности такого портфеля.
Формулы для портфеля с минимальной дисперсией:
1. Веса: w = Σ⁻¹·1 / (1ᵀ·Σ⁻¹·1)
2. Доходность: μ = wᵀ·r
3. Дисперсия: σ² = 1/(1ᵀ·Σ⁻¹·1)

Где Σ - матрица ковариаций активов
"""
    },

    'номера шаров': {
        'code': """
# Билет 9: Сумма номеров шаров
xk = np.arange(1, 36)
pxk = [1/35] * 35
X = rv_discrete(name='X', values=(xk, pxk))

n = 35
k = 20
print(k * X.mean())
print((k * (n + 1) / 12) * (n - k))
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 9):
Корзина содержит 35 пронумерованных шаров с номерами  1,2,…,35 . Из корзины без возвращения извлекаются  20<35  шаров. Пусть  S  обозначает сумму номеров извлечённых шаров.

Найдите математическое ожидание  E(S) .
Найдите дисперсию  Var(S) .
Для выборки без возвращения:
1. E[S] = n·(N+1)/2
2. Var(S) = n·Var(X₁) + n(n-1)·Cov(X₁,X₂)
   где Var(X₁) = (N²-1)/12
   Cov(X₁,X₂) = -Var(X₁)/(N-1)
"""
    },

    'пуассон': {
        'code': """
# Билет 12: Пуассоновские случайные величины
sigma1 = 1.5
sigma2 = 1.3
sigma3 = 1.3
total = sigma1 ** 2 + sigma2 ** 2 + sigma3 ** 2
prob_X7 = poisson.pmf(7, total)
most_val = int(total)
std = round(np.sqrt(total), 3)
asymm = 1 / std
excess = 1 / total
print(prob_X7)
print(most_val)
print(std)
print(asymm)
print(excess, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 12):
Независимые пуассоновские случайные величины  X ,  Y ,  Z  имеют следующие стандартные отклонения:

σX=1,5 ;
σY=1,3 ;
σZ=1,3 .
Пусть  S=X+Y+Z . Найдите:

Вероятность  P(S=7) ;
Наиболее вероятное значение суммы  S ;
Стандартное отклонение  σS ;
Асимметрию  As(S) ;
Эксцесс  Ex(S) .
Для независимых пуассоновских величин:
1. S = X + Y + Z ~ Poisson(λ_x + λ_y + λ_z)
2. Параметры находим из σ² = λ:
   λ_x = 1.5² = 2.25
   λ_y = λ_z = 1.3² = 1.69
3. Общий параметр: λ = 2.25 + 1.69 + 1.69 = 5.63

Характеристики распределения:
1. P(S=7) = e^{-λ}·λ^7/7!
2. Мода: ⌊λ⌋ = 5
3. σ = √λ ≈ 2.3727
4. Асимметрия: 1/√λ ≈ 0.4215
5. Эксцесс: 1/λ ≈ 0.1776
"""
    },

    'шары2': {
        'code': """
total_balls = 47
balls_1 = 19
balls_4 = 8
balls_6 = 20
n_draws = 14

E_1 = hypergeom.mean(total_balls, balls_1, n_draws)
E_4 = hypergeom.mean(total_balls, balls_4, n_draws)
E_6 = hypergeom.mean(total_balls, balls_6, n_draws)

Var_1 = hypergeom.var(total_balls, balls_1, n_draws)
Var_4 = hypergeom.var(total_balls, balls_4, n_draws)
Var_6 = hypergeom.var(total_balls, balls_6, n_draws)

cov_1_4 = -n_draws * (balls_1 / total_balls) * (balls_4 / total_balls) * (total_balls - n_draws) / (total_balls - 1)
cov_1_6 = -n_draws * (balls_1 / total_balls) * (balls_6 / total_balls) * (total_balls - n_draws) / (total_balls - 1)
cov_4_6 = -n_draws * (balls_4 / total_balls) * (balls_6 / total_balls) * (total_balls - n_draws) / (total_balls - 1)

E_S = 1 * E_1 + 4 * E_4 + 6 * E_6
Var_S = (1**2) * Var_1 + (4**2) * Var_4 + (6**2) * Var_6 + 2 * (1 * 4 * cov_1_4 + 1 * 6 * cov_1_6 + 4 * 6 * cov_4_6)
print(E_S)
print(Var_S)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 16):
Корзина содержит 47 шаров, на которых изображены цифры 1, 4 и 6. Известно, что всего имеется:

19 шаров с цифрой 1,
8 шаров с цифрой 4,
20 шаров с цифрой 6.
Из корзины без возвращения извлекаются 14 шаров. Цифра на первом извлечённом шаре обозначается  X1 , на втором —  X2 , на третьем —  X3 , и так далее.
Пусть  S=X1+…+X14 . Найдите:

Математическое ожидание  E(S) ;
Дисперсию  Var(S) .
# Теоретическое решение:

# 1. Математическое ожидание E(S):
# - Используем линейность мат.ожидания: E(S) = sum(E(X_i)) для i=1..14
# - E(X_i) = (19*1 + 8*4 + 20*6)/47 = 171/47
# - E(S) = 14 * 171/47 = 2394/47

# 2. Дисперсия Var(S):
# - Для зависимых испытаний (выборка без возвращения):
#   Var(S) = n*Var(X_1) + n(n-1)*Cov(X_1,X_2)
# - Var(X_1) = E(X^2) - [E(X)]^2 
#   = (19*1 + 8*16 + 20*36)/47 - (171/47)^2 = 11508/2209
# - Cov(X_1,X_2) = -Var(X_1)/(N-1) = -11508/(2209*46)
# - Итого:
#   Var(S) = 14*11508/2209 + 14*13*(-11508/(2209*46)) = 5318496/101614

# Ответ:
# E(S) = 2394/47 ≈ 50.936
# Var(S) = 5318496/101614 ≈ 52.339
"""
    }
}


def show_solution(ticket_number):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution('шары')
    show_solution('монеты')
    show_solution('портфель')
    show_solution('акции')
    show_solution('акции2')
    show_solution('пуассон')
    show_solution('пуассон2')
    show_solution('семена')
    show_solution('номера шаров')
    show_solution('случайные величины')

