# task2.py
"""Модуль с решениями вторых задач билетов 1-20 (код + теория с интегралами)"""

SOLUTIONS = {
    'индикаторы': {
        'code': """
# Билет 1: События A, B, C и индикаторы
p_a = 0.1
p_b = 0.4
p_c = 0.3

E_u = 3 * p_a + 7 * p_b + 2 * p_c


Var_x = p_a * (1 - p_a)
Var_y = p_b * (1 - p_b)
Var_z = p_c * (1 - p_c)

Var_u = 9 * Var_x + 49 * Var_y + 4 * Var_z # квадраты коэффициентов

print(f'E(u) = {E_u}')
print(f'Var(u) = {Var_u}')
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):
P(A)=0.1,P(B)=0.4,P(C)=0,3,U=3X+7Y+2Z 

E(U)=?,Var(U)=?
1. Математическое ожидание:
   E(U) = 3E(X) + 7E(Y) + 2E(Z) = 3P(A) + 7P(B) + 2P(C) = 3*0.1 + 7*0.4 + 2*0.3

2. Дисперсия:
   Var(U) = 9Var(X) + 49Var(Y) + 4Var(Z) 
   = 9P(A)(1-P(A)) + 49P(B)(1-P(B)) + 4P(C)(1-P(C))
   (ковариации = 0 из-за попарной независимости)
"""
    },
    
    'контракты': {
        'code': """
# Билет 2: Доход по контрактам
def solve_ticket2():
    \"\"\"Вычисляет:
    1) E(среднего дохода по 9 контрактам)
    2) Var(среднего дохода по 9 контрактам)
    \"\"\"
    # Находим недостающую вероятность P(X=8) = 1 - (0.2+0.2+0.3+0.1) = 0.2
    x = [5, 8, 9, 10, 11]
    p = [0.2, 0.2, 0.2, 0.3, 0.1]
    
    e_x = sum(xi*pi for xi, pi in zip(x, p))
    e_x2 = sum(xi**2*pi for xi, pi in zip(x, p))
    var_x = e_x2 - e_x**2
    
    # Для среднего по 9 контрактам
    e_avg = e_x
    var_avg = var_x / 9
    
    return round(e_avg, 3), round(var_avg, 3)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2):

1. Находим P(X=8) = 1 - Σ других вероятностей = 0.2

2. Мат. ожидание:
   E(X) = Σ x_i*p_i = 5*0.2 + 8*0.2 + 9*0.2 + 10*0.3 + 11*0.1

3. Дисперсия:
   Var(X) = E(X²) - [E(X)]² 
   = 25*0.2 + 64*0.2 + 81*0.2 + 100*0.3 + 121*0.1 - E(X)²

4. Для среднего по 9 контрактам:
   E(avg) = E(X)
   Var(avg) = Var(X)/9
"""
    },
    
    'акции': {
        'code': """
# Билет 4: Цена акции после 150 дней
start_price = 1000
E_r = 0.05 * 0.1 + 0.003 * 0.4 + (-0.01) * 0.5
E_S150 = start_price * (1 + E_r) ** 150

print(f'E(S150) = {E_S150}')

import numpy as np

r1 = np.log(1 + 0.05)
r2 = np.log(1 + 0.003)
r3 = np.log(1 - 0.01)

E_yi = r1 * 0.1 + r2 * 0.4 + r3 * 0.5
E_yi2 = (r1 ** 2) * 0.1 + (r2 ** 2) * 0.4 + (r3 ** 2) * 0.5
Var_yi = E_yi2 - (E_yi ** 2)

E_y = 150 * E_yi # тк 150 дней
Var_y = 150 * Var_yi

E_ln = np.log(start_price) + E_y

Var_150 = (np.exp(Var_y) - 1) * np.exp(2 * E_ln + Var_y)
SD = np.sqrt(Var_150)
print(f'SD = {SD}')
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 4):
Вероятность повышения цены акции (от закрытия торгов в предыдущий рабочий день до текущего закрытия) на 5% равна 0.1; вероятность повышения на 0.3% равна 0.4; а вероятность понижения на 1% равна 0.5. Пусть  S150  – цена акции после 150 рабочих дней. Предполагая, что начальная цена акции составляет  S0=1000  рублей, а относительные изменения цены за различные рабочие дни (от закрытия до закрытия) – независимые случайные величины, найдите:

математическое ожидание цены  S150 
стандартное отклонение цены  S150
1. Модель геометрического броуновского движения:
   S_t = S0 * exp(Σ log(1 + R_i))

2. Мат. ожидание:
   E[S150] = S0 * exp(n*μ + n*σ²/2), где n=150

3. Дисперсия:
   Var(S150) = S0² * exp(2nμ + nσ²) * (exp(nσ²) - 1)
"""
    },
    
    'квантили': {
        'code': """
# Билет 5: Квантили для Y = |X - 17.5|
X_values = np.arange(1, 41)
Y_values = np.abs(X_values - 17.5)

unique_Y, counts = np.unique(Y_values, return_counts=True)
prob_Y = counts / 40
Y = rv_discrete(name='Y', values=(unique_Y, prob_Y))

# 1. Q1Min: P(Y <= q) >= 0.25 (первый квартиль)
Q1min = Y.ppf(0.25)

# 2. Q1Max: Наибольшее q, где P(Y >= q) >= 0.75
P_geq = Y.sf(unique_Y) + Y.pmf(unique_Y)
valid_Q1Max = unique_Y[np.isclose(P_geq, 0.75, atol=1e-4) | (P_geq >= 0.75)]
Q1max = valid_Q1Max.max() if valid_Q1Max.size > 0 else np.nan

# 3. Q3Min: P(Y <= q) >= 0.75 (третий квартиль)
Q3min = Y.ppf(0.75)

# 4. Q3Max: Наибольшее q, где P(Y >= q) >= 0.25
P_geq = Y.sf(unique_Y) + Y.pmf(unique_Y)
valid_Q3Max = unique_Y[np.isclose(P_geq, 0.25, atol=1e-4) | (P_geq >= 0.25)]
Q3max = valid_Q3Max.max() if valid_Q3Max.size > 0 else np.nan

round(Q1min, 1), round(Q1max, 1), round(Q3min, 1), round(Q3max, 1)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 5):
Случайная величина  X  с равной вероятностью принимает все целые значения от 1 до 40. Пусть
Y=|X−17,5| 

Найдите:

наименьшее число  Q1Min , для которого  P(Y<Q1Min)>0,25 ;
наибольшее число  Q1Max , для которого  P(Y>Q1Max)>0,75 ;
наименьшее число  Q3Min , для которого  P(Y<Q3Min)>0,75 ;
наибольшее число  Q3Max , для которого  P(Y>Q3Max)>0,25 .
1. X ~ Uniform(1, 2, ..., 40)
   Y = |X - 17.5|

2. Квантили находятся по точным значениям:
   - Q1Min: минимальное y, где P(Y ≤ y) ≥ 0.25
   - Q1Max: максимальное y, где P(Y ≥ y) ≥ 0.75
   - Q3Min: минимальное y, где P(Y ≤ y) ≥ 0.75
   - Q3Max: максимальное y, где P(Y ≥ y) ≥ 0.25
"""
    },
    
    'попадание': {
        'code': """
# Билет 6: Попадание в фигуры (треугольник и круг)
P_xi = 0.44
P_yi = 0.4
P_xyi = 0.20

P_z0 = 1 - (P_xi + P_yi - P_xyi) # точка не принадлежит ни треугольнику, ни кругу
P_z1 = (P_xi - P_xyi) + (P_yi - P_xyi) # точка принадлежит только треугольнику или только кругу.
P_z2 = P_xyi # точка принадлежит пересечению (обеим фигурам).

E_z = 0 * P_z0 + 1 * P_z1 + 2 * P_z2
E_z2 = 0 ** 2 * P_z0 + 1 ** 2 * P_z1 + 2 ** 2 * P_z2
Var_z = E_z2 - E_z ** 2

E_u = E_z * 3
Var_u = Var_z * 3

E_v = E_z ** 3
E_v2 = E_z2 ** 3
Var_v = E_v2 - E_v ** 2

print(f'E(u) = {E_u}')
print(f'Var(u) = {Var_u}')
print(f'E(v) = {E_v}')
print(f'Var(v) = {Var_v}')
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 6):
В квадрате площадью 100 расположены треугольник и круг. Площади этих фигур: треугольник — 44, круг — 40. Также известно, что площадь пересечения треугольника и круга равна 20. В квадрате случайным и независимым образом выбираются точки  w1,…,w3 . Определим случайные величины:

Xi — индикатор попадания wi в треугольник, 

Yi — индикатор попадания wi в круг, 

Zi=Xi+Yi,i=1,…,3. 

Также определим сумму  U=Z1+⋯+Z3  и произведение  V=Z1…Z3 .

Требуется найти:

Математическое ожидание  E(U) 
Дисперсию  Var(U) 
Математическое ожидание  E(V) 
Дисперсию  Var(V)
1. Вероятности для Z:
   P(Z=0) = P(не попал ни в одну фигуру)
   P(Z=1) = P(попал только в треугольник или только в круг)
   P(Z=2) = P(попал в обе фигуры)

2. U = ΣZi:
   E[U] = 3E[Zi]
   Var(U) = 3Var(Zi)

3. V = ΠZi:
   E[V] = E[Z1]^3
   Var(V) = E[V^2] - E[V]^2
"""
    },

    'случай': {
        'code': """
# Билет 8: Характеристики Y = |X - 10|
def solve_ticket8():
    \"\"\"Вычисляет:
    1) E(X), E(Y), E(XY)
    2) Var(X), Var(Y)
    \"\"\"
    x = [2, 6, 9, 13, 15]
    p = [0.1, 0.2, 0.2, 0.3, 0.2]
    
    e_x = sum(xi*pi for xi, pi in zip(x, p))
    e_x2 = sum(xi**2*pi for xi, pi in zip(x, p))
    var_x = e_x2 - e_x**2
    
    y = [abs(xi - 10) for xi in x]
    e_y = sum(yi*pi for yi, pi in zip(y, p))
    e_y2 = sum(yi**2*pi for yi, pi in zip(y, p))
    var_y = e_y2 - e_y**2
    
    e_xy = sum(xi*yi*pi for xi, yi, pi in zip(x, y, p))
    
    return (round(e_x, 3), round(e_y, 3), round(e_xy, 3), 
            round(var_x, 3), round(var_y, 3))
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 8):
Распределение случайной величины  X  задано таблицей

( X )	2	6	9	13	15
( P )	0,1	0,2	0,2	0,3	0,2
Пусть  Y  – такая случайная величина, что  Y=|X−10| . Найдите:

математическое ожидание  E(X) ;
математическое ожидание  E(Y) ;
математическое ожидание  E(XY) ;
дисперсию  Var(X) ;
дисперсию  Var(Y) .
1. Мат. ожидания:
   E[X] = Σx_i*p_i
   E[Y] = Σ|x_i - 10|*p_i
   E[XY] = Σx_i*|x_i - 10|*p_i

2. Дисперсии:
   Var(X) = E[X²] - E[X]²
   Var(Y) = E[Y²] - E[Y]²
"""
    },
    

}

def show_solution(ticket_number:str):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    for ticket in sorted(SOLUTIONS.keys()):
        show_solution(ticket)