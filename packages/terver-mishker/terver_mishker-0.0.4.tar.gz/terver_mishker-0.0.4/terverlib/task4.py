# task4.py
"""Модуль с решениями четвертых задач билетов 1-20 (код + теория)"""

SOLUTIONS = {
    'нормальный вектор': {
        'code': """
# Билет 1: Вероятность для нормального случайного вектора
from scipy.stats import multivariate_normal

def solve_ticket1():
    \"\"\"Вычисляет P((X-4)(Y-3) < 0) для (X,Y) ~ N(-7,17,81,16,0.6)\"\"\"
    mean = [-7, 17]
    cov = [[81, 0.6*9*4], [0.6*9*4, 16]]
    rv = multivariate_normal(mean, cov)
    
    # P = P(X<4,Y>3) + P(X>4,Y<3)
    p1 = rv.cdf([4, float('inf')]) - rv.cdf([4, 3])
    p2 = rv.cdf([float('inf'), 3]) - rv.cdf([4, 3])
    return round(p1 + p2, 4)
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 1):
Для нормального случайного вектора  (X,Y)∼N(−7;17;81;16;0,6)  найдите вероятность  P((X−4)(Y−3)<0) .
1. Вектор (X,Y) имеет нормальное распределение с параметрами:
   μ_x = -7, μ_y = 17
   σ_x² = 81, σ_y² = 16
   ρ = 0.6

2. P((X-4)(Y-3) < 0) = P(X<4,Y>3) + P(X>4,Y<3)

3. Вычисляем через функцию распределения двумерного нормального закона
"""
    },

    'случайная величина': {
        'code': """
# Билет 2: Математическое ожидание и параметры для Y = f(X)
a, b = (5, 7)

def EY(X):
  if (a <= X <= b):
    return (1 + 6*X ** 0.5 + 3*X ** 0.7 + 8*X ** 0.9) ** 1.1 * (1/(b - a))
  return 0
E_Y = integrate.quad(EY, a, b)[0]
print(f'{E_Y:.1f}')

def Var(X):
  if (a <= X <= b):
    return (((1 + 6*X ** 0.5 + 3*X ** 0.7 + 8*X ** 0.9) ** 1.1) ** 2 * (1/(b - a)))
  return 0
std_Y = np.sqrt(integrate.quad(Var, a, b)[0] - E_Y ** 2)
print(f'{std_Y:.2f}')

def As(X):
  if (a <= X <= b):
    return (((1 + 6*X ** 0.5 + 3*X ** 0.7 + 8*X ** 0.9) ** 1.1 - E_Y) ** 3 * (1/(b - a)))
  return 0
asymm_Y = (1 / std_Y ** 3) * integrate.quad(As, a, b)[0]
print(f'{asymm_Y:.4f}')

X = symbols('X')
X_08 = a + 0.8*(b - a)
Y_08 = float(((1 + 6*X ** 0.5 + 3*X ** 0.7 + 8*X ** 0.9) ** 1.1).subs(X, X_08).evalf())
print(f'{Y_08:.4f}')
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 2, задание 4):
лучайная величина  X  равномерно распределена на отрезке  [5,7] . Случайная величина  Y  выражается через  X  следующим образом:
Y=(1+6X0.5+3X0.7+8X0.9)1.1 .
Найдите:

Математическое ожидание  E(Y) ;
Стандартное отклонение  σY ;
Асимметрию  As(Y) ;
Квантиль уровня  0,8  распределения  Y .
1. X ~ Uniform[5,7], плотность f_X(x) = 1/2

2. Y = 1 + 6X^0.5 + 3X^0.7 + 8X^0.9

3. Математическое ожидание:
   E[Y] = ∫[5,7] (1 + 6x^0.5 + 3x^0.7 + 8x^0.9) * (1/2) dx

4. Дисперсия:
   Var(Y) = E[Y^2] - (E[Y])^2
   где E[Y^2] = ∫[5,7] (1 + 6x^0.5 + ...)^2 * (1/2) dx

5. Асимметрия:
   As(Y) = E[((Y-μ)/σ)^3]

6. Медиана (квантиль 0.5):
   Находим y такое, что P(Y ≤ y) = 0.5
"""
    },

    'плотность': {
        'code': """
# Билет 3: Плотность распределения случайного вектора
import numpy as np
from fractions import Fraction

Sigma_inv = np.array([[20, 24], [24, 45]]) # 10 и 45/2 домножены на 2
Sigma = np.linalg.inv(Sigma_inv)

# Математические ожидания
mu = Sigma @ np.array([5, 6])
E_X, E_Y = mu

# Дисперсии и ковариация
Var_X = Sigma[0, 0]
Var_Y = Sigma[1, 1]
Cov_XY = Sigma[0, 1]

# Коэффициент корреляции
rho = Cov_XY / np.sqrt(Var_X * Var_Y)

# Функция для преобразования в дробь с ограниченным знаменателем
def to_fraction(x, limit=1000):
    return Fraction(x).limit_denominator(limit)

print(f"1) E(X) = {to_fraction(E_X)}")
print(f"2) E(Y) = {to_fraction(E_Y)}")
print(f"3) Var(X) = {to_fraction(Var_X)}")
print(f"4) Var(Y) = {to_fraction(Var_Y)}")
print(f"5) Cov(X, Y) = {to_fraction(Cov_XY)}")
print(f"6) ρ(X, Y) = {to_fraction(rho)}") 
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 3):
Случайный вектор  (X,Y)  имеет плотность распределения:
fXY(x,y)=9e(−10x2−24xy+5x+45y22+6y−58)π. 

Найдите:

Математическое ожидание  E(X) ;
Математическое ожидание  E(Y) ;
Дисперсию  Var(X) ;
Дисперсию  Var(Y) ;
Ковариацию  Cov(X,Y) ;
Коэффициент корреляции  ρ(X,Y) .
# Теоретическое решение для двумерного нормального распределения:

# Дана плотность распределения:
# f(x,y) = (9/π) * exp(-(10x² - 24xy + 5x + (45y²)/2 + 6y - 58))

# 1. Приводим к стандартному виду двумерного нормального распределения:
# f(x,y) = (1/(2π|Σ|^1/2)) * exp(-1/2 * (X-μ)^T * Σ^-1 * (X-μ))

# 2. Выделяем матрицу Σ^-1 и вектор μ:
# Σ^-1 = [[20, -24], 
#         [-24, 45]]
# μ^T * Σ^-1 = [-5, -6] ⇒ μ = -Σ * [5, 6]

# 3. Находим матрицу ковариаций Σ:
# Σ = (Σ^-1)^-1 = [[45/324, 24/324], 
#                  [24/324, 20/324]] = [[5/36, 2/27], 
#                                      [2/27, 5/81]]

# 4. Находим математические ожидания:
# E(X) = μ_X = -(45*5 + 24*6)/324 = -41/36
# E(Y) = μ_Y = -(24*5 + 20*6)/324 = -20/27

# 5. Находим дисперсии и ковариацию:
# Var(X) = 5/36
# Var(Y) = 5/81
# Cov(X,Y) = 2/27

# 6. Коэффициент корреляции:
# ρ = Cov(X,Y)/√(Var(X)*Var(Y)) = (2/27)/√(5/36 * 5/81) = 4/5

# Ответ:
# E(X) = -41/36 ≈ -1.1389
# E(Y) = -20/27 ≈ -0.7407
# Var(X) = 5/36 ≈ 0.1389
# Var(Y) = 5/81 ≈ 0.0617
# Cov(X,Y) = 2/27 ≈ 0.0741
# ρ(X,Y) = 4/5 = 0.8
"""
    },

    'непрерывная величина': {
        'code': """
# Билет 9: Константа для плотности распределения
def func(x):
  return (1 + 2*x ** 0.5 + 3*x ** 0.7 + 7*x ** 0.9) ** 1.5

a, b = (5, 7)
def f(x):
  if (a <= x <= b):
    return func(x)
  return 0
C = 1 / integrate.quad(f, a, b)[0]
print(f'{C:.5f}')

def EX(x):
  if (a <= x <= b):
    return C * x * func(x)
  return 0
E_X = integrate.quad(EX, a, b)[0]
print(f'{E_X:.3f}')

def Var(x):
  if (a <= x <= b):
    return C * (x - E_X) ** 2 * func(x)
  return 0
std_X = np.sqrt(integrate.quad(Var, a, b)[0])
print(f'{std_X:.3f}')

class distr(rv_continuous):
  def _pdf(self, x):
    return C * f(x)
X = distr()
Q1 = X.ppf(0.8)
print(f'{Q1:.3f}')
""",
        'theory': """
ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ (Билет 9):
Абсолютно непрерывная случайная величина  X  может принимать значения только на отрезке  [5,7] . На этом отрезке плотность распределения случайной величины  X  имеет вид:
f(x)=C(1+2x0.5+3x0.7+7x0.8)15, 

где  C  — положительная константа. Найдите:

Константу  C ;
Математическое ожидание  E(X) ;
Стандартное отклонение  σX ;
Квантиль уровня  0,8  распределения  X .
1. Плотность имеет вид:
   f(x) = C*(1 + 2√x + 3x^0.7 + 7x^0.9)^1.5, x ∈ [5,7]

2. Константа C находится из условия нормировки:
   ∫₅⁷ f(x) dx = 1 ⇒ C = 1 / ∫₅⁷ (1 + 2√x + 3x^0.7 + 7x^0.9)^1.5 dx

3. Интеграл вычисляется численно
"""
    }
}

def show_solution(ticket_number:str):
    """Выводит полное решение для билета"""
    if ticket_number not in SOLUTIONS:
        print(f"Решение для билета {ticket_number} не найдено")
        return
    
    print(f"\n{'='*60}\nБИЛЕТ {ticket_number}\n{'='*60}")
    print("\n[ТЕОРЕТИЧЕСКОЕ РЕШЕНИЕ]:")
    print(SOLUTIONS[ticket_number]['theory'])
    print("\n[PYTHON-КОД ДЛЯ ВЫЧИСЛЕНИЙ]:")
    print(SOLUTIONS[ticket_number]['code'])
    print("="*60)

# Автоматический вывод при импорте
if __name__ != "__main__":
    print("\nДОСТУПНЫЕ РЕШЕНИЯ ДЛЯ БИЛЕТОВ:", list(SOLUTIONS.keys()))
    print("Используйте show_solution(номер_билета) для просмотра\n")

# Пример использования:
if __name__ == "__main__":
    show_solution('нормальный вектор')
    show_solution('случайная величина')
    show_solution('плотность')
    show_solution('непрерывная величина')