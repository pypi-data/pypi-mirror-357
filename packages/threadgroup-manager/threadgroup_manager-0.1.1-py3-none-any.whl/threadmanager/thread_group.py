import time
import uuid
import logging
import threading
from threadmanager.threadutils import wait_for_condition

from threadmanager._utils import generate_random_string
from threadmanager.thread import Thread
from threadmanager.thread_events import ThreadEventsController

logger = logging.getLogger(__name__)


class ThreadSafeQueue(list):
    def __init__(self):
        self._thread_lock = threading.Lock()
        super(ThreadSafeQueue, self).__init__()

    def __len__(self):
        with self._thread_lock:
            return super(ThreadSafeQueue, self).__len__()

    def append(self, obj):
        with self._thread_lock:
            super(ThreadSafeQueue, self).append(obj)

    def pop(self, index=0):
        with self._thread_lock:
            try:
                return super(ThreadSafeQueue, self).pop(index)
            except IndexError:
                return None

    def clear(self):
        with self._thread_lock:
            super(ThreadSafeQueue, self).clear()


class ThreadSafeInt:
    def __init__(self):
        self._thread_lock = threading.Lock()
        self._value = 0

    def increment(self, by):
        with self._thread_lock:
            self._value = self._value + by
            return self._value

    def increment_if_less_than(self, max_value):
        with self._thread_lock:
            if self._value < max_value:
                self._value += 1
                return True
            return False

    def equals(self, compare_with):
        with self._thread_lock:
            return compare_with == self._value

    def value(self):
        with self._thread_lock:
            return self._value


class ThreadGroup:
    """
    A thread group management class to handle concurrent tasks using threads.
    This class ensures tasks are executed in parallel, with control over the maximum number of concurrent threads,
    task queuing, exception handling, and thread synchronization.

    Attributes:
        _threads (ThreadHolder): Manages the collection of active threads in the group.
        return_values (dict): Stores the return values of completed tasks, indexed by task IDs.
        _current_running_cnt (ThreadSafeInt): Tracks the number of currently running threads in the group.
        _task_count (int): Total count of tasks added to the group.
        _all_threads_count (ThreadSafeInt): Total number of threads created by the group.
        exceptions (dict): Stores exceptions raised during task execution, indexed by task IDs.
        _queued_tasks (ThreadSafeQueue): Queue of pending tasks awaiting execution.
        tg_uuid (UUID): Unique identifier for the thread group.
        group_name (str): Name of the thread group.
        parent_name (str): Name of the parent thread that created this group.
        _tg_joined (bool): Indicates whether the group has completed its execution and been joined.
        event_controller (ThreadEventsController): Singleton controller to manage thread group events.
    """

    def __init__(self, group_name="", max_concurrent_threads=32):
        """
        Initializes a ThreadGroup instance with optional name and concurrency limits.

        Args:
            group_name (str, optional): Name of the thread group. Defaults to a generated name.
            max_concurrent_threads (int, optional): Maximum number of threads that can run concurrently. Defaults to 32.
        """
        self._threads = ThreadHolder()
        self.return_values = dict()
        self._current_running_cnt = ThreadSafeInt()
        self._task_count = 0
        self._all_threads_count = ThreadSafeInt()
        self.exceptions = dict()
        self._queued_tasks = ThreadSafeQueue()
        if not hasattr(self, 'tg_uuid'):
            # Initialize on first instantiation
            self.tg_uuid = uuid.uuid4()
            self.print_name = "Thread"
            self.group_name = group_name if group_name else \
                f"{self.print_name}Pool-{generate_random_string(3)}"
            self._maximum_concurrent_threads = max_concurrent_threads
            self.parent_name = threading.current_thread().name
        self.event_controller = ThreadEventsController.get_instance()
        self.event_controller.register_event_for_thread_group(self.tg_uuid)
        self._tg_joined = False

    def add_task(self, target, args=None, kwargs=None, task_id=None):
        """
        Adds a new task to the thread group for execution.

        Args:
            target (callable): The function to execute as a task.
            args (list, optional): Positional arguments for the target function. Defaults to an empty list.
            kwargs (dict, optional): Keyword arguments for the target function. Defaults to an empty dict.
            task_id (str, optional): Custom task identifier. Defaults to an autogenerated ID.

        Returns:
            str: The task ID for the added task.
        """
        if self._tg_joined:
            self.__init__()
        self._task_count += 1
        kwargs = kwargs or {}
        args = args or []
        task_id = task_id or f"{self._task_count}"
        logging_name = f"{self.group_name} - {task_id}"
        if threading.current_thread().ident != threading.main_thread().ident:
            logging_name = f"{self.parent_name} : {logging_name}"
        self._queued_tasks.append((task_id, target, args, kwargs, logging_name))  # TODO: Make tasks objects
        if self._current_running_cnt.increment_if_less_than(self._maximum_concurrent_threads):
            thread_name = f"{self.group_name}-{self._all_threads_count.increment(1)}"
            logger.debug(f"Adding new thread - {thread_name}")
            t = Thread(target=self._thread_runner, name=thread_name, tg_uuid=self.tg_uuid)
            logger.debug(f"Starting {self.print_name} - {t.name}")
            t.start()
            self._threads.append_thread(t)
        else:
            logger.debug(f"Max thread count reached. Added task {task_id} to queue.")
        return task_id

    def _thread_runner(self):
        """
        Executes tasks in the thread group's queue. Handles task completion and exceptions.
        """
        try:
            while True:
                task_info = self._queued_tasks.pop()
                if not task_info:
                    break
                task_id, target, args, kwargs, logging_name = task_info
                threading.current_thread().name = logging_name
                kwargs = kwargs or {}
                args = args or []
                try:
                    result = target(*args, **kwargs)
                    self.return_values[task_id] = result
                except Exception as err:
                    self.exceptions[task_id] = err
        finally:
            self._current_running_cnt.increment(-1)

    def join(self, timeout, ignore_exception=False):
        """
        Waits for all threads in the group to complete execution or for the timeout to expire.

        Args:
            timeout (float): Maximum time (in seconds) to wait for all threads to finish.
            ignore_exception (bool): If True, suppresses exceptions raised during task execution.

        Returns:
            dict: A dictionary of task return values.

        Raises:
            Exception: If exceptions occurred during task execution and ignore_exception is False.
        """
        end_time = time.time() + timeout
        try:
            if self._threads.are_threads_active():
                logger.info(f"Waiting for {self.group_name} threads to complete")
                for thread in self._threads.get_all_threads():
                    thread.join(max(0.0, end_time - time.time()))
                logger.info(f"{self.group_name} threads completed")
            self._handle_exceptions(ignore_exception=ignore_exception)
            return self.return_values
        finally:
            self._tg_joined = True
            self.event_controller.remove_thread_group(self.tg_uuid)

    def clear_pending_tasks_in_queue(self):
        """
        Clears all pending tasks in the thread group's queue.
        """
        self._queued_tasks.clear()

    def _handle_exceptions(self, ignore_exception=False):
        """
        Handles exceptions encountered during task execution.

        Args:
            ignore_exception (bool): If True, ignores exceptions and logs them.

        Raises:
            Exception: If multiple exceptions occurred and ignore_exception is False.
        """
        if not ignore_exception:
            if len(self.exceptions) > 1:
                raise Exception(f"There were exceptions in multiple threads: {self.exceptions}")
            elif len(self.exceptions) > 0:
                raise Exception(list(self.exceptions.values())[0])
        else:
            logger.info("Ignoring exceptions encountered in thread execution.")

    def wait_for_condition(self, expression, timeout, sleep_interval=0.1):
        wait_for_condition(expression, timeout, sleep_interval, event=self.event_controller.get_event(self.tg_uuid))

    def set_event_for_child_tasks(self):
        self.event_controller.set_events_for_thread_group(self.tg_uuid)


class ThreadHolder:
    """
    Manages a collection of threads, tracking their status and activity.
    """

    def __init__(self):
        """
        Initializes an empty ThreadHolder.
        """
        self._threads = []

    def append_thread(self, thread):
        """
        Adds a thread to the holder.

        Args:
            thread (Thread): The thread to add.
        """
        self._threads.append(thread)

    def refresh_active_threads(self):
        """
        Removes threads that are no longer active from the holder.
        """
        self._threads = [t for t in self._threads if t.is_alive()]

    def are_threads_active(self):
        """
        Checks if there are any active threads in the holder.

        Returns:
            bool: True if there are active threads, False otherwise.
        """
        self.refresh_active_threads()
        return bool(self._threads)

    def get_all_threads(self):
        """
        Retrieves all threads currently in the holder.

        Returns:
            list: A list of Thread objects.
        """
        return self._threads
