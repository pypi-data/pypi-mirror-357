const d=new Error("request for lock canceled");var f=function(u,e,t,i){function o(r){return r instanceof t?r:new t(function(n){n(r)})}return new(t||(t=Promise))(function(r,n){function h(s){try{c(i.next(s))}catch(a){n(a)}}function l(s){try{c(i.throw(s))}catch(a){n(a)}}function c(s){s.done?r(s.value):o(s.value).then(h,l)}c((i=i.apply(u,e||[])).next())})};class p{constructor(e,t=d){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((i,o)=>{const r={resolve:i,reject:o,weight:e,priority:t},n=_(this._queue,h=>t<=h.priority);n===-1&&e<=this._value?this._dispatchItem(r):this._queue.splice(n+1,0,r)})}runExclusive(e){return f(this,arguments,void 0,function*(t,i=1,o=0){const[r,n]=yield this.acquire(i,o);try{return yield t(r)}finally{n()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(i=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),w(this._weightedWaiters[e-1],{resolve:i,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(i=>i.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const i=this._weightedWaiters[t-1];if(!i)continue;const o=i.findIndex(r=>r.priority<=e);(o===-1?i:i.splice(0,o)).forEach(r=>r.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function w(u,e){const t=_(u,i=>e.priority<=i.priority);u.splice(t+1,0,e)}function _(u,e){for(let t=u.length-1;t>=0;t--)if(e(u[t]))return t;return-1}var v=function(u,e,t,i){function o(r){return r instanceof t?r:new t(function(n){n(r)})}return new(t||(t=Promise))(function(r,n){function h(s){try{c(i.next(s))}catch(a){n(a)}}function l(s){try{c(i.throw(s))}catch(a){n(a)}}function c(s){s.done?r(s.value):o(s.value).then(h,l)}c((i=i.apply(u,e||[])).next())})};class m{constructor(e){this._semaphore=new p(1,e)}acquire(){return v(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}export{m as M};
