#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
TABLE SPLITTER EXAMPLE
======================

Code m·∫´u ƒë·ªÉ split 1 b·∫£ng 4 c·ªôt th√†nh 2 b·∫£ng:
- B·∫£ng 1: C·ªôt 1 + 2 + 3 (STT + H·ªç t√™n + ƒê·ªìng √Ω)
- B·∫£ng 2: C·ªôt 1 + 2 + 4 (STT + H·ªç t√™n + Kh√¥ng ƒë·ªìng √Ω)

Input:  table_input.jpg (4 c·ªôt)
Output: table_dong_y.jpg (3 c·ªôt), table_khong_dong_y.jpg (3 c·ªôt)
"""

import cv2
import numpy as np
from PIL import Image
import os
from scipy import signal
from scipy.ndimage import gaussian_filter1d
from typing import Tuple, List, Optional
from itertools import combinations

class TableSplitter:
    def __init__(self, input_path: str, output_dir: str = "output"):
        """
        Kh·ªüi t·∫°o Table Splitter
        
        Args:
            input_path (str): ƒê∆∞·ªùng d·∫´n file ·∫£nh b·∫£ng input (4 c·ªôt)
            output_dir (str): Th∆∞ m·ª•c l∆∞u k·∫øt qu·∫£
        """
        self.input_path = input_path
        self.output_dir = output_dir
        self.img = None
        self.gray = None
        self.height = 0
        self.width = 0
        
        # T·∫°o th∆∞ m·ª•c output
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            
    def load_and_validate_image(self) -> bool:
        """
        Load ·∫£nh v√† validate
        
        Returns:
            bool: True n·∫øu load th√†nh c√¥ng
        """
        print(f"üìÇ ƒêang load ·∫£nh: {self.input_path}")
        
        if not os.path.exists(self.input_path):
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y file: {self.input_path}")
            return False
            
        self.img = cv2.imread(self.input_path)
        if self.img is None:
            print(f"‚ùå Kh√¥ng th·ªÉ ƒë·ªçc ·∫£nh t·ª´ {self.input_path}")
            return False
        
        self.height, self.width = self.img.shape[:2]
        self.gray = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)
        
        print(f"‚úÖ Load th√†nh c√¥ng! K√≠ch th∆∞·ªõc: {self.width} x {self.height}")
        return True
        
    def preprocess_image(self) -> np.ndarray:
        """
        Ti·ªÅn x·ª≠ l√Ω ·∫£nh ƒë·ªÉ detect c·ªôt t·ªët h∆°n
        
        Returns:
            np.ndarray: ·∫¢nh binary ƒë√£ x·ª≠ l√Ω
        """
        print("üîß ƒêang ti·ªÅn x·ª≠ l√Ω ·∫£nh...")
        
        # Blur ƒë·ªÉ gi·∫£m noise
        blurred = cv2.GaussianBlur(self.gray, (3, 3), 0)
        
        # TƒÉng contrast
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        enhanced = clahe.apply(blurred)
        
        # Threshold adaptive
        binary = cv2.adaptiveThreshold(enhanced, 255, 
                                     cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                     cv2.THRESH_BINARY_INV, 15, 2)
        
        print("‚úÖ Ti·ªÅn x·ª≠ l√Ω ho√†n th√†nh")
        return binary
    
    def detect_column_separators(self, binary: np.ndarray) -> List[int]:
        """
        Detect 3 ƒë∆∞·ªùng ph√¢n c√°ch c·ªôt (ƒë·ªÉ t·∫°o 4 c·ªôt)
        S·ª≠ d·ª•ng 4 ph∆∞∆°ng ph√°p k·∫øt h·ª£p
        
        Args:
            binary: ·∫¢nh binary
            
        Returns:
            List[int]: 3 v·ªã tr√≠ x c·ªßa ƒë∆∞·ªùng ph√¢n c√°ch
        """
        print("üîç ƒêang detect c·ªôt...")
        
        # Method 1: Hough Lines
        hough_lines = self._detect_hough_lines(binary)
        
        # Method 2: Vertical Projection
        projection_peaks = self._detect_projection_peaks(binary)
        
        # Method 3: Morphological
        morph_lines = self._detect_morphological_lines(binary)
        
        # Method 4: Text Gaps
        text_gaps = self._detect_text_gaps(binary)
        
        print(f"  üîç Hough lines: {hough_lines}")
        print(f"  üìä Projection peaks: {projection_peaks}")
        print(f"  üî≤ Morphological lines: {morph_lines}")
        print(f"  üìù Text gaps: {text_gaps}")
        
        # Combine results v·ªõi weighted approach
        candidates = self._combine_weighted(hough_lines, projection_peaks, 
                                          morph_lines, text_gaps)
        
        # Optimize ƒë·ªÉ c√≥ ƒë√∫ng 3 v·ªã tr√≠
        final_positions = self._optimize_positions(candidates)
        
        print(f"‚úÖ V·ªã tr√≠ c·ªôt cu·ªëi c√πng: {final_positions}")
        return final_positions
    
    def _detect_hough_lines(self, binary: np.ndarray) -> List[int]:
        """Detect ƒë∆∞·ªùng th·∫≥ng d·ªçc b·∫±ng Hough Transform"""
        edges = cv2.Canny(binary, 50, 150, apertureSize=3)
        lines = cv2.HoughLines(edges, 1, np.pi/180, threshold=int(self.height*0.3))
        
        vertical_lines = []
        if lines is not None:
            for rho, theta in lines[:, 0]:
                if abs(theta) < 0.1 or abs(theta - np.pi) < 0.1:
                    x = int(rho / np.cos(theta)) if abs(np.cos(theta)) > 0.01 else None
                    if x is not None and 10 < x < self.width - 10:
                        vertical_lines.append(x)
        
        return sorted(list(set(vertical_lines)))
    
    def _detect_projection_peaks(self, binary: np.ndarray) -> List[int]:
        """Detect peaks trong vertical projection"""
        projection = np.sum(binary, axis=0)
        smoothed = gaussian_filter1d(projection, sigma=2)
        
        median_val = np.median(smoothed)
        mad = np.median(np.abs(smoothed - median_val))
        threshold = median_val + 2 * mad
        
        peaks, _ = signal.find_peaks(smoothed, 
                                   height=threshold,
                                   distance=max(20, self.width//20),
                                   prominence=mad)
        
        return peaks.tolist()
    
    def _detect_morphological_lines(self, binary: np.ndarray) -> List[int]:
        """Detect ƒë∆∞·ªùng k·∫ª b·∫±ng morphological operations"""
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, self.height//10))
        vertical_lines = cv2.morphologyEx(binary, cv2.MORPH_OPEN, vertical_kernel)
        
        contours, _ = cv2.findContours(vertical_lines, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        line_positions = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            if h > self.height * 0.5 and w <= 10:
                line_positions.append(x + w//2)
        
        return sorted(line_positions)
    
    def _detect_text_gaps(self, binary: np.ndarray) -> List[int]:
        """Detect gaps gi·ªØa text regions"""
        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (self.width//50, 1))
        dilated = cv2.dilate(binary, horizontal_kernel, iterations=2)
        
        contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        text_regions = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            if w > 30 and h > 10:
                text_regions.append((x, x + w))
        
        text_regions.sort()
        gaps = []
        
        if len(text_regions) > 1:
            for i in range(len(text_regions) - 1):
                gap_start = text_regions[i][1]
                gap_end = text_regions[i + 1][0]
                if gap_end - gap_start > 10:
                    gaps.append((gap_start + gap_end) // 2)
        
        return gaps
    
    def _combine_weighted(self, hough: List[int], projection: List[int], 
                         morph: List[int], text: List[int]) -> List[int]:
        """Combine k·∫øt qu·∫£ v·ªõi tr·ªçng s·ªë"""
        all_candidates = []
        
        # Weighted contribution
        for line in hough:
            all_candidates.extend([line] * 3)  # Weight 3
        for peak in projection:
            all_candidates.extend([peak] * 2)  # Weight 2
        for line in morph:
            all_candidates.extend([line] * 2)  # Weight 2
        for gap in text:
            all_candidates.append(gap)         # Weight 1
        
        if not all_candidates:
            raise RuntimeError("‚ùå Kh√¥ng detect ƒë∆∞·ª£c c·ªôt n√†o!")
        
        # Clustering
        all_candidates.sort()
        clusters = []
        current_cluster = [all_candidates[0]]
        
        for candidate in all_candidates[1:]:
            if candidate - current_cluster[-1] <= 15:
                current_cluster.append(candidate)
            else:
                clusters.append(int(np.mean(current_cluster)))
                current_cluster = [candidate]
        
        if current_cluster:
            clusters.append(int(np.mean(current_cluster)))
        
        # Filter bi√™n
        clusters = [c for c in clusters if 20 < c < self.width - 20]
        return sorted(clusters)
    
    def _optimize_positions(self, candidates: List[int]) -> List[int]:
        """Optimize ƒë·ªÉ c√≥ ƒë√∫ng 3 v·ªã tr√≠ t·∫°o 4 c·ªôt c√¢n ƒë·ªëi"""
        if len(candidates) < 3:
            raise RuntimeError(f"‚ùå Ch·ªâ detect ƒë∆∞·ª£c {len(candidates)} c·ªôt, c·∫ßn √≠t nh·∫•t 3!")
        
        if len(candidates) == 3:
            return candidates
        
        # Ch·ªçn 3 v·ªã tr√≠ t·ªëi ∆∞u b·∫±ng CV minimization
        best_score = float('inf')
        best_positions = candidates[:3]
        
        for combo in combinations(candidates, 3):
            combo = sorted(combo)
            
            # T√≠nh 4 sections
            sections = [
                combo[0],                    # Section 1
                combo[1] - combo[0],         # Section 2
                combo[2] - combo[1],         # Section 3
                self.width - combo[2]        # Section 4
            ]
            
            # Coefficient of variation
            mean_section = np.mean(sections)
            std_section = np.std(sections)
            cv = std_section / mean_section if mean_section > 0 else float('inf')
            
            if cv < best_score:
                best_score = cv
                best_positions = combo
        
        print(f"  üéØ Optimization CV score: {best_score:.3f}")
        return list(best_positions)
    
    def create_debug_visualization(self, column_positions: List[int]) -> str:
        """T·∫°o ·∫£nh debug ƒë·ªÉ ki·ªÉm tra"""
        debug_img = self.img.copy()
        
        # V·∫Ω 3 ƒë∆∞·ªùng ph√¢n c√°ch
        colors = [(0, 255, 0), (255, 0, 0), (0, 0, 255)]  # Green, Blue, Red
        for i, pos in enumerate(column_positions):
            color = colors[i]
            cv2.line(debug_img, (pos, 0), (pos, self.height), color, 3)
            cv2.putText(debug_img, f"Sep {i+1}: {pos}", 
                       (pos + 5, 30 + i*25), cv2.FONT_HERSHEY_SIMPLEX, 
                       0.7, color, 2)
        
        # Hi·ªÉn th·ªã 4 sections
        sections = [
            column_positions[0],
            column_positions[1] - column_positions[0],
            column_positions[2] - column_positions[1], 
            self.width - column_positions[2]
        ]
        
        cv2.putText(debug_img, f"4 Sections: {sections}", 
                   (10, self.height - 20), cv2.FONT_HERSHEY_SIMPLEX, 
                   0.6, (255, 255, 255), 2)
        
        debug_path = os.path.join(self.output_dir, "debug_column_detection.jpg")
        cv2.imwrite(debug_path, debug_img)
        
        print(f"üíæ Debug ·∫£nh: {debug_path}")
        return debug_path
    
    def split_table(self) -> Tuple[str, str]:
        """
        Main function: Split b·∫£ng th√†nh 2 ·∫£nh
        
        Returns:
            Tuple[str, str]: (path_table_1, path_table_2)
        """
        print("üöÄ B·∫Øt ƒë·∫ßu split b·∫£ng...")
        print("=" * 50)
        
        # Step 1: Load ·∫£nh
        if not self.load_and_validate_image():
            raise RuntimeError("‚ùå Kh√¥ng th·ªÉ load ·∫£nh!")
        
        # Step 2: Preprocess
        binary = self.preprocess_image()
        
        # Step 3: Detect 3 ƒë∆∞·ªùng ph√¢n c√°ch c·ªôt
        column_positions = self.detect_column_separators(binary)
        
        # Step 4: T·∫°o debug visualization
        debug_path = self.create_debug_visualization(column_positions)
        
        # Step 5: Split th√†nh 2 ·∫£nh
        print("‚úÇÔ∏è ƒêang split ·∫£nh...")
        
        # Convert sang PIL ƒë·ªÉ x·ª≠ l√Ω
        img_rgb = cv2.cvtColor(self.img, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(img_rgb)
        
        # T·∫°o B·∫£ng 1: C·ªôt 1 + 2 + 3 (STT + H·ªç t√™n + ƒê·ªìng √Ω)
        # Crop t·ª´ ƒë·∫ßu ƒë·∫øn v·ªã tr√≠ ph√¢n c√°ch th·ª© 3
        table1_pil = pil_img.crop((0, 0, column_positions[2], self.height))
        
        # T·∫°o B·∫£ng 2: C·ªôt 1 + 2 + 4 (STT + H·ªç t√™n + Kh√¥ng ƒë·ªìng √Ω)
        # Gh√©p c·ªôt 1+2 v·ªõi c·ªôt 4
        left_part = pil_img.crop((0, 0, column_positions[1], self.height))  # C·ªôt 1+2
        right_part = pil_img.crop((column_positions[2], 0, self.width, self.height))  # C·ªôt 4
        
        # T·∫°o ·∫£nh m·ªõi ƒë·ªÉ gh√©p
        table2_width = column_positions[1] + (self.width - column_positions[2])
        table2_pil = Image.new('RGB', (table2_width, self.height), 'white')
        table2_pil.paste(left_part, (0, 0))
        table2_pil.paste(right_part, (column_positions[1], 0))
        
        # L∆∞u k·∫øt qu·∫£
        table1_path = os.path.join(self.output_dir, "table_dong_y.jpg")
        table2_path = os.path.join(self.output_dir, "table_khong_dong_y.jpg")
        
        table1_pil.save(table1_path, quality=95, optimize=True)
        table2_pil.save(table2_path, quality=95, optimize=True)
        
        print(f"‚úÖ B·∫£ng 1 (C·ªôt 1+2+3): {table1_path}")
        print(f"   üìä K√≠ch th∆∞·ªõc: {table1_pil.size}")
        print(f"‚úÖ B·∫£ng 2 (C·ªôt 1+2+4): {table2_path}")
        print(f"   üìä K√≠ch th∆∞·ªõc: {table2_pil.size}")
        
        return table1_path, table2_path

def demo_example():
    """
    H√†m demo v·ªõi ·∫£nh m·∫´u
    """
    print("üéØ TABLE SPLITTER DEMO")
    print("=" * 40)
    
    # Input file - thay ƒë·ªïi t√™n file theo ·∫£nh c·ªßa b·∫°n
    input_file = "table_input.jpg"  # ·∫¢nh b·∫£ng 4 c·ªôt
    
    # Ki·ªÉm tra file input
    if not os.path.exists(input_file):
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y: {input_file}")
        print("\nüí° ƒê·ªÉ test, b·∫°n c·∫ßn:")
        print("   1. ƒê·∫∑t file ·∫£nh b·∫£ng 4 c·ªôt v√†o th∆∞ m·ª•c n√†y")
        print("   2. ƒê·ªïi t√™n th√†nh 'table_input.jpg' ho·∫∑c s·ª≠a t√™n trong code")
        print("   3. Ch·∫°y l·∫°i script")
        print("\nüìã Format b·∫£ng c·∫ßn:")
        print("   C·ªôt 1: STT")
        print("   C·ªôt 2: H·ªç v√† T√™n") 
        print("   C·ªôt 3: ƒê·ªìng √Ω")
        print("   C·ªôt 4: Kh√¥ng ƒë·ªìng √Ω")
        return
    
    try:
        # Kh·ªüi t·∫°o v√† ch·∫°y
        splitter = TableSplitter(input_file, output_dir="split_output")
        
        # Split b·∫£ng
        table1_path, table2_path = splitter.split_table()
        
        print("\nüéâ HO√ÄN TH√ÄNH!")
        print("=" * 40)
        print(f"üìÇ Th∆∞ m·ª•c output: split_output/")
        print(f"üìÑ B·∫£ng 1 (STT + H·ªç t√™n + ƒê·ªìng √Ω): {table1_path}")
        print(f"üìÑ B·∫£ng 2 (STT + H·ªç t√™n + Kh√¥ng ƒë·ªìng √Ω): {table2_path}")
        print(f"üîç Debug ·∫£nh: split_output/debug_column_detection.jpg")
        
        # H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng ti·∫øp
        print("\nüí° B·∫°n c√≥ th·ªÉ:")
        print("   - Ki·ªÉm tra debug ·∫£nh ƒë·ªÉ xem detect c√≥ ch√≠nh x√°c kh√¥ng")
        print("   - S·ª≠ d·ª•ng 2 ·∫£nh k·∫øt qu·∫£ cho m·ª•c ƒë√≠ch kh√°c")
        print("   - Ch·ªânh s·ª≠a code ƒë·ªÉ ph√π h·ª£p v·ªõi format b·∫£ng kh√°c")
        
    except Exception as e:
        print(f"‚ùå L·ªói: {e}")
        print("\nüîß C√≥ th·ªÉ kh·∫Øc ph·ª•c:")
        print("   - Ki·ªÉm tra ch·∫•t l∆∞·ª£ng ·∫£nh input")
        print("   - ƒê·∫£m b·∫£o ·∫£nh c√≥ ƒë∆∞·ªùng k·∫ª r√µ r√†ng")
        print("   - Th·ª≠ v·ªõi ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i cao h∆°n")

def custom_split_example():
    """
    V√≠ d·ª• s·ª≠ d·ª•ng v·ªõi custom input/output paths
    """
    print("\nüõ†Ô∏è CUSTOM EXAMPLE")
    print("=" * 30)
    
    # Custom paths
    input_path = "my_table.png"      # ƒê∆∞·ªùng d·∫´n ·∫£nh c·ªßa b·∫°n
    output_dir = "my_results"        # Th∆∞ m·ª•c l∆∞u k·∫øt qu·∫£
    
    if os.path.exists(input_path):
        try:
            splitter = TableSplitter(input_path, output_dir)
            table1, table2 = splitter.split_table()
            print(f"‚úÖ Success: {table1}, {table2}")
        except Exception as e:
            print(f"‚ùå Error: {e}")
    else:
        print(f"‚ÑπÔ∏è File kh√¥ng t·ªìn t·∫°i: {input_path}")
        print("   ƒê√¢y ch·ªâ l√† v√≠ d·ª• code")

if __name__ == "__main__":
    # Ch·∫°y demo
    demo_example()
    
    # Uncomment ƒë·ªÉ test custom
    # custom_split_example()
    
    print("\n" + "="*50)
    print("üöÄ Code ho√†n th√†nh! S·∫µn s√†ng s·ª≠ d·ª•ng!")
    print("="*50) 