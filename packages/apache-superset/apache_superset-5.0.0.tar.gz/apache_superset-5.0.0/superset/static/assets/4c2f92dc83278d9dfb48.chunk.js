(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[2213,3257,3897,3979],{50740:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>A});var n=o(2404),i=o.n(n),a=o(96540),r=o(35742),s=o(83505),l=o(70957),c=o(84193),d=o.n(c);function u(e,t,o=!0,n={}){if(!e.datasource)return;const i=new(d())("/"),a=function(e="base"){let t="/explore/";return["json","csv","query","results","samples"].includes(e)&&(t="/superset/explore_json/"),t}(t),r=i.search(!0);Object.keys(n).forEach((e=>{r[e]=n[e]})),r.form_data=function(e){const t=new Set;return JSON.stringify(e,((e,o)=>{if("object"==typeof o&&null!==o){if(t.has(o))try{return JSON.parse(JSON.stringify(o))}catch(e){return}t.add(o)}return o}))}(e),"standalone"===t&&(r.standalone="true");const s=i.directory(a).search(r).toString();return!o&&s.length>8e3?u({datasource:e.datasource,viz_type:e.viz_type},t,!1,{URL_IS_TOO_LONG_TO_SHARE:null}):s}var g=o(43979),p=o(44147),h=o(93897),f=o(22213),v=o(41937),m=o(17861),_=o(11743),x=o(62145),y=o(20901),P=o(71237);const S={deck_grid:g.getLayer,deck_screengrid:p.getLayer,deck_path:h.getLayer,deck_hex:f.getLayer,deck_scatter:v.getLayer,deck_geojson:m.getLayer,deck_arc:_.getLayer,deck_polygon:x.getLayer,deck_heatmap:y.getLayer,deck_contour:P.getLayer};var w=o(95490),C=o(2445);const b=e=>{const t=(0,a.useRef)(),o=(0,a.useCallback)((()=>{let t={...e.viewport};const o=[...(0,x.getPoints)(e.payload.data.features.deck_polygon||[]),...(0,h.getPoints)(e.payload.data.features.deck_path||[]),...(0,g.getPoints)(e.payload.data.features.deck_grid||[]),...(0,v.getPoints)(e.payload.data.features.deck_scatter||[]),...(0,P.getPoints)(e.payload.data.features.deck_contour||[]),...(0,y.getPoints)(e.payload.data.features.deck_heatmap||[]),...(0,f.getPoints)(e.payload.data.features.deck_hex||[]),...(0,_.getPoints)(e.payload.data.features.deck_arc||[]),...(0,m.getPoints)(e.payload.data.features.deck_geojson||[]),...(0,p.getPoints)(e.payload.data.features.deck_screengrid||[])];return e.formData&&(t=(0,w.A)(t,{width:e.width,height:e.height,points:o})),t.zoom<0&&(t.zoom=0),t}),[e]),[n,c]=(0,a.useState)(o()),[d,b]=(0,a.useState)({}),A=(0,a.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),L=(0,a.useCallback)(((t,n,i)=>{c(o()),b({}),n.data.slices.forEach((o=>{var n,i,a;const s=[...o.form_data.extra_filters||[],...t.extra_filters||[],...(null==(n=t.extra_form_data)?void 0:n.filters)||[]],l=[...t.adhoc_filters||[],...(null==(i=o.formData)?void 0:i.adhoc_filters)||[],...(null==(a=t.extra_form_data)?void 0:a.adhoc_filters)||[]],c={...o,form_data:{...o.form_data,extra_filters:s,adhoc_filters:l}},d=u(c.form_data,"json");d&&r.A.get({endpoint:d}).then((({json:t})=>{const o=S[c.form_data.viz_type](c.form_data,t,e.onAddFilter,A,e.datasource,[],e.onSelect);b((e=>({...e,[c.slice_id]:o})))})).catch((()=>{}))}))}),[e.datasource,e.onAddFilter,e.onSelect,A,o]),R=(0,s.Z)(e.formData.deck_slices);(0,a.useEffect)((()=>{const{formData:t,payload:o}=e;!i()(R,t.deck_slices)&&L(t,o)}),[L,R,e]);const{payload:T,formData:k,setControlValue:j,height:z,width:D}=e,M=Object.values(d);return(0,C.Y)(l.S,{ref:t,mapboxApiAccessToken:T.data.mapboxApiKey,viewport:n,layers:M,mapStyle:k.mapbox_style,setControlValue:j,onViewportChange:c,height:z,width:D})},A=(0,a.memo)(b)},11743:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>P,getLayer:()=>y,getPoints:()=>x});var n=o(75077),i=o(82101),a=o(23197),r=o(16704),s=o(77117);const l="uniform arcUniforms {\n  bool greatCircle;\n  bool useShortestPath;\n  float numSegments;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int widthUnits;\n} arc;\n",c={name:"arc",vs:l,fs:l,uniformTypes:{greatCircle:"f32",useShortestPath:"f32",numSegments:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",widthUnits:"i32"}},d=[0,0,0,255],u={getSourcePosition:{type:"accessor",value:e=>e.sourcePosition},getTargetPosition:{type:"accessor",value:e=>e.targetPosition},getSourceColor:{type:"accessor",value:d},getTargetColor:{type:"accessor",value:d},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class g extends n.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME arc-layer-vertex-shader\nin vec4 instanceSourceColors;\nin vec4 instanceTargetColors;\nin vec3 instanceSourcePositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions;\nin vec3 instanceTargetPositions64Low;\nin vec3 instancePickingColors;\nin float instanceWidths;\nin float instanceHeights;\nin float instanceTilts;\nout vec4 vColor;\nout vec2 uv;\nout float isValid;\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\nfloat deltaZ = targetZ - sourceZ;\nfloat dh = distance * instanceHeights;\nif (dh == 0.0) {\nreturn sourceZ + deltaZ * ratio;\n}\nfloat unitZ = deltaZ / dh;\nfloat p2 = unitZ * unitZ + 1.0;\nfloat dir = step(deltaZ, 0.0);\nfloat z0 = mix(sourceZ, targetZ, dir);\nfloat r = mix(ratio, 1.0 - ratio, dir);\nreturn sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nfloat getSegmentRatio(float index) {\nreturn smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));\n}\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\nfloat distance = length(source.xy - target.xy);\nfloat z = paraboloid(distance, source.z, target.z, segmentRatio);\nfloat tiltAngle = radians(instanceTilts);\nvec2 tiltDirection = normalize(target.xy - source.xy);\nvec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\nreturn vec3(\nmix(source.xy, target.xy, segmentRatio) + tilt,\nz * cos(tiltAngle)\n);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\nvec2 sourceRadians = radians(source);\nvec2 targetRadians = radians(target);\nvec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\nvec2 shd_sq = sin_half_delta * sin_half_delta;\nfloat a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\nreturn 2.0 * asin(sqrt(a));\n}\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\nvec2 lngLat;\nif(abs(angularDist - PI) < 0.001) {\nlngLat = (1.0 - t) * source.xy + t * target.xy;\n} else {\nfloat a = sin((1.0 - t) * angularDist);\nfloat b = sin(t * angularDist);\nvec3 p = source3D.yxz * a + target3D.yxz * b;\nlngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n}\nfloat z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\nreturn vec3(lngLat, z);\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nfloat segmentIndex = float(gl_VertexID / 2);\nfloat segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;\nfloat segmentRatio = getSegmentRatio(segmentIndex);\nfloat prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\nfloat nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));\nfloat indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\nisValid = 1.0;\nuv = vec2(segmentRatio, segmentSide);\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nvec4 curr;\nvec4 next;\nvec3 source;\nvec3 target;\nif ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nsource = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\ntarget = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\nfloat angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\nvec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\nvec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\nvec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\nif (abs(currPos.x - prevPos.x) > 180.0) {\nindexDir = -1.0;\nisValid = 0.0;\n} else if (abs(currPos.x - nextPos.x) > 180.0) {\nindexDir = 1.0;\nisValid = 0.0;\n}\nnextPos = indexDir < 0.0 ? prevPos : nextPos;\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nif (isValid == 0.0) {\nnextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\nfloat t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\ncurrPos = mix(currPos, nextPos, t);\nsegmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n}\nvec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\nvec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\ncurr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\nnext = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n} else {\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nif (arc.useShortestPath) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng > 180.) target_world.x -= 360.;\nif (deltaLng < -180.) source_world.x -= 360.;\n}\nsource = project_position(source_world, instanceSourcePositions64Low);\ntarget = project_position(target_world, instanceTargetPositions64Low);\nfloat antiMeridianX = 0.0;\nif (arc.useShortestPath) {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nantiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n}\nfloat thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\nif (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\nisValid = 0.0;\nindexDir = sign(segmentRatio - thresholdRatio);\nsegmentRatio = thresholdRatio;\n}\n}\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nvec3 currPos = interpolateFlat(source, target, segmentRatio);\nvec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\nif (arc.useShortestPath) {\nif (nextPos.x < antiMeridianX) {\ncurrPos.x += TILE_SIZE;\nnextPos.x += TILE_SIZE;\n}\n}\ncurr = project_common_position_to_clipspace(vec4(currPos, 1.0));\nnext = project_common_position_to_clipspace(vec4(nextPos, 1.0));\ngeometry.position = vec4(currPos, 1.0);\n}\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),\narc.widthMinPixels, arc.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(curr, geometry);\ngl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\nvColor = vec4(color.rgb, color.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME arc-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nin float isValid;\nout vec4 fragColor;\nvoid main(void) {\nif (isValid == 0.0) {\ndiscard;\n}\nfragColor = vColor;\ngeometry.uv = uv;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[i.A,a.A,c]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:d},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:d},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(e){super.updateState(e),e.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:e}){const{widthUnits:t,widthScale:o,widthMinPixels:n,widthMaxPixels:i,greatCircle:a,wrapLongitude:s,numSegments:l}=this.props,c={numSegments:l,widthUnits:r.p5[t],widthScale:o,widthMinPixels:n,widthMaxPixels:i,greatCircle:a,useShortestPath:s},d=this.state.model;d.shaderInputs.setProps({arc:c}),d.setVertexCount(2*l),d.draw(this.context.renderPass)}_getModel(){return new s.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-strip",isInstanced:!0})}}g.layerName="ArcLayer",g.defaultProps=u;const p=g;var h=o(95579),f=o(41857),v=o(47823),m=o(32548),_=o(2445);function x(e){const t=[];return e.forEach((e=>{t.push(e.sourcePosition),t.push(e.targetPosition)})),t}function y(e,t,o,n){const i=t.data.features,a=e.color_picker,r=e.target_color_picker;return new p({data:i,getSourceColor:e=>e.sourceColor||e.color||[a.r,a.g,a.b,255*a.a],getTargetColor:e=>e.targetColor||e.color||[r.r,r.g,r.b,255*r.a],id:`path-layer-${e.slice_id}`,getWidth:e.stroke_width?e.stroke_width:3,...(0,f.T)(e,n,(s=e,e=>{var t,o,n,i,a,r,l,c,d;return(0,_.FD)("div",{className:"deckgl-tooltip",children:[(0,_.Y)(m.A,{label:(0,h.t)("Start (Longitude, Latitude): "),value:`${null==(t=e.object)||null==(o=t.sourcePosition)?void 0:o[0]}, ${null==(n=e.object)||null==(i=n.sourcePosition)?void 0:i[1]}`}),(0,_.Y)(m.A,{label:(0,h.t)("End (Longitude, Latitude): "),value:`${null==(a=e.object)||null==(r=a.targetPosition)?void 0:r[0]}, ${null==(l=e.object)||null==(c=l.targetPosition)?void 0:c[1]}`}),s.dimension&&(0,_.Y)(m.A,{label:`${null==s?void 0:s.dimension}: `,value:`${null==(d=e.object)?void 0:d.cat_color}`})]})}))});var s}const P=(0,v.c)(y,x)},71237:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>p,getLayer:()=>u,getPoints:()=>g});var n=o(91059),i=o(95579),a=o(41857),r=o(25564),s=o(47823),l=o(32548),c=o(2445);function d(e){var t,o;return(0,c.FD)("div",{className:"deckgl-tooltip",children:[(0,c.Y)(l.A,{label:(0,i.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`}),(0,c.Y)(l.A,{label:(0,i.t)("Threshold: "),value:`${null==e||null==(t=e.object)||null==(o=t.contour)?void 0:o.threshold}`})]})}const u=function(e,t,o,i){const s=e,{aggregation:l="SUM",js_data_mutator:c,contours:u,cellSize:g="200"}=s;let p=t.data.features;const h=null==u?void 0:u.map((e=>{const{lowerThreshold:t,upperThreshold:o,color:n,strokeWidth:i}=e;return o?{threshold:[t,o],color:[n.r,n.g,n.b]}:{threshold:t,color:[n.r,n.g,n.b],strokeWidth:i}}));return c&&(p=(0,r.A)(s.js_data_mutator)(p)),new n.A({id:`contourLayer-${s.slice_id}`,data:p,contours:h,cellSize:Number(g||"200"),aggregation:l.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight||0,...(0,a.T)(s,i,d)})};function g(e){return e.map((e=>e.position))}const p=(0,s.y)(u,g)},17861:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>C,getLayer:()=>P,getPoints:()=>S});var n=o(96540),i=o(63947),a=o(25879),r=o.n(a),s=o(70957),l=o(49443),c=o(25564),d=o(41857),u=o(32548),g=o(95490),p=o(2445);const h={fillColor:"fillColor",color:"fillColor",fill:"fillColor","fill-color":"fillColor",strokeColor:"strokeColor","stroke-color":"strokeColor","stroke-width":"strokeWidth"},f=(e,t)=>{const o={};return Object.keys(e).forEach((t=>{t in h?o[h[t]]=e[t]:o[t]=e[t]})),"string"==typeof e.fillColor&&(o.fillColor=(0,l.hexToRGB)(e.fillColor)),"string"==typeof e.strokeColor&&(o.strokeColor=(0,l.hexToRGB)(e.strokeColor)),{...o,...t}};let v=[];const m=(e,t,o)=>{if(null!=e&&e.features&&e.features.forEach((n=>{m(n,t,e.extraProps||o)})),null!=e&&e.geometry){const n={...e,properties:f(e.properties,t)};n.extraProps||(n.extraProps=o),v.push(n)}};function _(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,p.Y)("div",{className:"deckgl-tooltip",children:Object.keys(e.object.extraProps).map(((t,o)=>{var n;return(0,p.Y)(u.A,{label:`${t}: `,value:`${null==(n=e.object.extraProps)?void 0:n[t]}`},`prop-${o}`)}))})}const x=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.fillColor},y=e=>{var t;return null==e||null==(t=e.properties)?void 0:t.strokeColor};function P(e,t,o,n){const a=e,r=a.fill_color_picker,s=a.stroke_color_picker,l=[r.r,r.g,r.b,255*r.a],u=[s.r,s.g,s.b,255*s.a],g={};l[3]>0&&(g.fillColor=l),u[3]>0&&(g.strokeColor=u),v=[],m(t.data,g);let p=v;return a.js_data_mutator&&(p=(0,c.A)(a.js_data_mutator)(v)),new i.A({id:`geojson-layer-${a.slice_id}`,data:p,extruded:a.extruded,filled:a.filled,stroked:a.stroked,getFillColor:x,getLineColor:y,getLineWidth:a.line_width||1,pointRadiusScale:a.point_radius_scale,lineWidthUnits:a.line_width_unit,...(0,d.T)(a,n,_)})}function S(e){return e.reduce(((e,t)=>{const o=r()(t);return o?[...e,[o[0],o[1]],[o[2],o[3]]]:e}),[])}const w=e=>{var t;const o=(0,n.useRef)(),i=(0,n.useCallback)((e=>{const{current:t}=o;t&&t.setTooltip(e)}),[]),{formData:a,payload:r,setControlValue:l,onAddFilter:c,height:d,width:u}=e,h=(0,n.useMemo)((()=>a.autozoom&&(S(r.data.features)||[]).length?(0,g.A)(e.viewport,{width:u,height:d,points:S(r.data.features)||[]}):e.viewport),[a.autozoom,d,null==r||null==(t=r.data)?void 0:t.features,e.viewport,u]),f=P(a,r,0,i);return(0,p.Y)(s.S,{ref:o,mapboxApiAccessToken:r.data.mapboxApiKey,viewport:h,layers:[f],mapStyle:a.mapbox_style,setControlValue:l,height:d,width:u})},C=(0,n.memo)(w)},43979:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>f,getLayer:()=>p,getPoints:()=>h});var n=o(13596),i=o(95579),a=o(94963),r=o(41857),s=o(25564),l=o(49443),c=o(47823),d=o(32548),u=o(2445);function g(e){return(0,u.FD)("div",{className:"deckgl-tooltip",children:[(0,u.Y)(d.A,{label:(0,i.t)("Longitude and Latitude")+": ",value:`${e.coordinate[0]}, ${e.coordinate[1]}`}),(0,u.Y)(d.A,{label:(0,i.t)("Height")+": ",value:`${e.object.elevationValue}`})]})}function p(e,t,o,i){const c=e,d=c.color_scheme,u=a.getScale(d).range().map((e=>(0,l.hexToRGB)(e)));let p=t.data.features;c.js_data_mutator&&(p=(0,s.A)(c.js_data_mutator)(p));const h=(0,r.g)(c.js_agg_function,(e=>e.weight));return new n.A({id:`grid-layer-${c.slice_id}`,data:p,cellSize:c.grid_size,extruded:c.extruded,colorRange:u,outline:!1,getElevationValue:h,getColorValue:h,...(0,r.T)(c,i,g)})}function h(e){return e.map((e=>e.position))}const f=(0,c.y)(p,h)},20901:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>f,getLayer:()=>p,getPoints:()=>h});var n=o(65476),i=o(95579),a=o(69161),r=o(41857),s=o(25564),l=o(49443),c=o(47823),d=o(32548),u=o(2445);function g(e){return(0,u.Y)("div",{className:"deckgl-tooltip",children:(0,u.Y)(d.A,{label:(0,i.t)("Centroid (Longitude and Latitude): "),value:`(${null==e?void 0:e.coordinate[0]}, ${null==e?void 0:e.coordinate[1]})`})})}const p=(e,t,o,i)=>{var c,d,u,p;const h=e,{intensity:f=1,radius_pixels:v=30,aggregation:m="SUM",js_data_mutator:_,linear_color_scheme:x}=h;let y=t.data.features;_&&(y=(0,s.A)(h.js_data_mutator)(y));const P=null==(c=(0,a.A)())||null==(d=c.get(x))?void 0:d.createLinearScale([0,6]),S=null==P||null==(u=P.range())||null==(p=u.map((e=>(0,l.hexToRGB)(e))))?void 0:p.reverse();return new n.A({id:`heatmap-layer-${h.slice_id}`,data:y,intensity:f,radiusPixels:v,colorRange:S,aggregation:m.toUpperCase(),getPosition:e=>e.position,getWeight:e=>e.weight?e.weight:1,...(0,r.T)(h,i,g)})};function h(e){return e.map((e=>e.position))}const f=(0,c.y)(p,h)},22213:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>f,getLayer:()=>p,getPoints:()=>h});var n=o(83206),i=o(95579),a=o(94963),r=o(41857),s=o(25564),l=o(49443),c=o(47823),d=o(32548),u=o(2445);function g(e){return(0,u.FD)("div",{className:"deckgl-tooltip",children:[(0,u.Y)(d.A,{label:(0,i.t)("Centroid (Longitude and Latitude): "),value:`(${e.coordinate[0]}, ${e.coordinate[1]})`}),(0,u.Y)(d.A,{label:(0,i.t)("Height")+": ",value:`${e.object.elevationValue}`})]})}function p(e,t,o,i){const c=e,d=c.color_scheme,u=a.getScale(d).range().map((e=>(0,l.hexToRGB)(e)));let p=t.data.features;c.js_data_mutator&&(p=(0,s.A)(c.js_data_mutator)(p));const h=(0,r.g)(c.js_agg_function,(e=>null==e?void 0:e.weight));return new n.A({id:`hex-layer-${c.slice_id}`,data:p,radius:c.grid_size,extruded:c.extruded,colorRange:u,outline:!1,getElevationValue:h,getColorValue:h,...(0,r.T)(c,i,g)})}function h(e){return e.map((e=>e.position))}const f=(0,c.y)(p,h)},93897:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>g,getLayer:()=>d,getPoints:()=>u});var n=o(91018),i=o(41857),a=o(25564),r=o(47823),s=o(32548),l=o(2445);function c(e){var t;return(null==(t=e.object)?void 0:t.extraProps)&&(0,l.Y)("div",{className:"deckgl-tooltip",children:Object.keys(e.object.extraProps).map(((t,o)=>(0,l.Y)(s.A,{label:`${t}: `,value:`${e.object.extraProps[t]}`},`prop-${o}`)))})}function d(e,t,o,r){const s=e,l=s.color_picker,d=[l.r,l.g,l.b,255*l.a];let u=t.data.features.map((e=>({...e,path:e.path,width:s.line_width,color:d})));return s.js_data_mutator&&(u=(0,a.A)(s.js_data_mutator)(u)),new n.A({id:`path-layer-${s.slice_id}`,getColor:e=>e.color,getPath:e=>e.path,getWidth:e=>e.width,data:u,rounded:!0,widthScale:1,widthUnits:s.line_width_unit,...(0,i.T)(s,r,c)})}function u(e){let t=[];return e.forEach((e=>{t=t.concat(e.path)})),t}const g=(0,r.y)(d,u)},41937:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>h,getLayer:()=>p,getPoints:()=>u});var n=o(33549),i=o(36770),a=o(95579),r=o(41857),s=o(47823),l=o(32548);const c=1609.34;var d=o(2445);function u(e){return e.map((e=>e.position))}function g(e,t){return o=>{var n,r,s,c,u,g,p,h,f;const v=(null==t?void 0:t[e.point_radius_fixed.value])||(0,i.A)(null==(n=e.point_radius_fixed)?void 0:n.value);return(0,d.FD)("div",{className:"deckgl-tooltip",children:[(0,d.Y)(l.A,{label:(0,a.t)("Longitude and Latitude")+": ",value:`${null==(r=o.object)||null==(s=r.position)?void 0:s[0]}, ${null==(c=o.object)||null==(u=c.position)?void 0:u[1]}`}),(null==(g=o.object)?void 0:g.cat_color)&&(0,d.Y)(l.A,{label:(0,a.t)("Category")+": ",value:`${null==(p=o.object)?void 0:p.cat_color}`}),(null==(h=o.object)?void 0:h.metric)&&(0,d.Y)(l.A,{label:`${v}: `,value:`${null==(f=o.object)?void 0:f.metric}`})]})}}function p(e,t,o,i,a){const s=e,l=t.data.features.map((e=>{let t=(o=s.point_unit,n=e.radius,("square_m"===o?Math.sqrt(n/Math.PI):"radius_m"===o?n:"radius_km"===o?1e3*n:"radius_miles"===o?n*c:"square_km"===o?1e3*Math.sqrt(n/Math.PI):"square_miles"===o?Math.sqrt(n/Math.PI)*c:null)||10);var o,n;if(s.multiplier&&(t*=s.multiplier),e.color)return{...e,radius:t};const i=s.color_picker||{r:0,g:0,b:0,a:1},a=[i.r,i.g,i.b,255*i.a];return{...e,radius:t,color:a}}));return new n.A({id:`scatter-layer-${s.slice_id}`,data:l,fp64:!0,getFillColor:e=>e.color,getRadius:e=>e.radius,radiusMinPixels:Number(s.min_radius)||void 0,radiusMaxPixels:Number(s.max_radius)||void 0,stroked:!1,...(0,r.T)(s,i,g(s,null==a?void 0:a.verboseMap))})}const h=(0,s.c)(p,u)},44147:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>D,getLayer:()=>j,getPoints:()=>T});var n=o(63950),i=o.n(n),a=o(96540),r=o(82101),s=o(1334),l=o(48928),c=o(12965),d=o(77117),u=o(83391),g=o(75077),p=o(23197),h=o(83102);const f={name:"screenGrid",vs:"uniform screenGridUniforms {\n  vec2 cellSizeClipspace;\n  vec2 gridSizeClipspace;\n  vec2 colorDomain;\n} screenGrid;\n",uniformTypes:{cellSizeClipspace:"vec2<f32>",gridSizeClipspace:"vec2<f32>",colorDomain:"vec2<f32>"}};class v extends g.A{getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec2 positions;\nin vec2 instancePositions;\nin float instanceWeights;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\nif (isnan(instanceWeights)) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;\npos.x = pos.x - 1.0;\npos.y = 1.0 - pos.y;\ngl_Position = vec4(pos, 0., 1.);\nvColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);\nvColor.a *= layer.opacity;\npicking_setPickingColor(instancePickingColors);\n}\n",fs:"#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[p.A,f]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceWeights:{size:1,type:"float32",accessor:"getWeight"}}),this.state.model=this._getModel()}updateState(e){super.updateState(e);const{props:t,oldProps:o,changeFlags:n}=e,i=this.state.model;if(o.colorRange!==t.colorRange){this.state.colorTexture?.destroy(),this.state.colorTexture=(0,h.cp)(this.context.device,t.colorRange,t.colorScaleType);const e={colorRange:this.state.colorTexture};i.shaderInputs.setProps({screenGrid:e})}else o.colorScaleType!==t.colorScaleType&&(0,h.Pu)(this.state.colorTexture,t.colorScaleType);if(o.cellMarginPixels!==t.cellMarginPixels||o.cellSizePixels!==t.cellSizePixels||n.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:o,cellMarginPixels:n}=this.props,a=Math.max(o-n,0),r={gridSizeClipspace:[o/e*2,o/t*2],cellSizeClipspace:[a/e*2,a/t*2]};i.shaderInputs.setProps({screenGrid:r})}}finalizeState(e){super.finalizeState(e),this.state.colorTexture?.destroy()}draw({uniforms:e}){const t=this.props.colorDomain(),o=this.state.model,n={colorDomain:t};o.shaderInputs.setProps({screenGrid:n}),o.draw(this.context.renderPass)}_getModel(){return new d.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new u.V({topology:"triangle-strip",attributes:{positions:{value:new Float32Array([0,0,1,0,0,1,1,1]),size:2}}}),isInstanced:!0})}}v.layerName="ScreenGridCellLayer";const m=v,_={name:"binOptions",vs:"uniform binOptionsUniforms {\n  float cellSizePixels;\n} binOptions;\n",uniformTypes:{cellSizePixels:"f32"}},x={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0},colorRange:h.QO,colorScaleType:"linear",getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:1},gpuAggregation:!0,aggregation:"SUM"};class y extends c.A{getAggregatorType(){return this.props.gpuAggregation&&s.V.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(e){return"cpu"!==e&&s.V.isSupported(this.context.device)?new s.V(this.context.device,{dimensions:2,channelCount:1,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[r.A,_],vs:"\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  "})}):new l.M({dimensions:2,getBin:{sources:["positions"],getValue:({positions:e},t,o)=>{const n=this.context.viewport,i=n.project(e),a=o.cellSizePixels;return i[0]<0||i[0]>=n.width||i[1]<0||i[1]>=n.height?null:[Math.floor(i[0]/a),Math.floor(i[1]/a)]}},getValue:[{sources:["counts"],getValue:({counts:e})=>e}]})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},counts:{size:1,accessor:"getWeight"}})}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){const t=super.updateState(e),{props:o,oldProps:n,changeFlags:i}=e,{cellSizePixels:a,aggregation:r}=o;if(t||i.dataChanged||i.updateTriggersChanged||i.viewportChanged||r!==n.aggregation||a!==n.cellSizePixels){const{width:e,height:t}=this.context.viewport,{aggregator:o}=this.state;o instanceof s.V&&o.setProps({binIdRange:[[0,Math.ceil(e/a)],[0,Math.ceil(t/a)]]}),o.setProps({pointCount:this.getNumInstances(),operations:[r],binOptions:{cellSizePixels:a}})}return i.viewportChanged&&this.state.aggregator.setNeedsUpdate(),t}onAttributeChange(e){const{aggregator:t}=this.state;switch(e){case"positions":t.setNeedsUpdate();break;case"counts":t.setNeedsUpdate(0)}}renderLayers(){const{aggregator:e}=this.state,t=this.getSubLayerClass("cells",m),o=e.getBins(),n=e.getResult(0);return new t(this.props,this.getSubLayerProps({id:"cell-layer"}),{data:{length:e.binCount,attributes:{getBin:o,getWeight:n}},dataComparator:(e,t)=>e.length===t.length,updateTriggers:{getBin:[o],getWeight:[n]},parameters:{depthWriteEnabled:!1,...this.props.parameters},colorDomain:()=>this.props.colorDomain||e.getResultDomain(0),extensions:[]})}getPickingInfo(e){const t=e.info,{index:o}=t;if(o>=0){const e=this.state.aggregator.getBin(o);let n;e&&(n={col:e.id[0],row:e.id[1],value:e.value[0],count:e.count},e.pointIndices&&(n.pointIndices=e.pointIndices,n.points=Array.isArray(this.props.data)?e.pointIndices.map((e=>this.props.data[e])):[])),t.object=n}return t}}y.layerName="ScreenGridLayer",y.defaultProps=x;const P=y;var S=o(95579),w=o(25564),C=o(41857),b=o(32548),A=o(95490),L=o(70957),R=o(2445);function T(e){return e.map((e=>e.position))}function k(e){var t,o,n;return(0,R.FD)("div",{className:"deckgl-tooltip",children:[(0,R.Y)(b.A,{label:(0,S.t)("Longitude and Latitude")+": ",value:`${null==e||null==(t=e.coordinate)?void 0:t[0]}, ${null==e||null==(o=e.coordinate)?void 0:o[1]}`}),(0,R.Y)(b.A,{label:(0,S.t)("Weight")+": ",value:`${null==(n=e.object)?void 0:n.cellWeight}`})]})}function j(e,t,o,n){const i=e,a=i.color_picker;let r=t.data.features.map((e=>({...e,color:[a.r,a.g,a.b,255*a.a]})));return i.js_data_mutator&&(r=(0,w.A)(i.js_data_mutator)(r)),new P({id:`screengrid-layer-${i.slice_id}`,data:r,cellSizePixels:i.grid_size,minColor:[a.r,a.g,a.b,0],maxColor:[a.r,a.g,a.b,255*a.a],outline:!1,getWeight:e=>e.weight||0,...(0,C.T)(i,n,k)})}const z=e=>{const t=(0,a.useRef)(),o=(0,a.useCallback)((()=>{const t=e.payload.data.features||[],{width:o,height:n,formData:i}=e;return i.autozoom?(0,A.A)(e.viewport,{width:o,height:n,points:T(t)}):e.viewport}),[e]),[n,r]=(0,a.useState)(e.payload.form_data),[s,l]=(0,a.useState)(o());(0,a.useEffect)((()=>{e.payload.form_data!==n&&(l(o()),r(e.payload.form_data))}),[o,e.payload.form_data,n]);const c=(0,a.useCallback)((e=>{const{current:o}=t;o&&o.setTooltip(e)}),[]),d=(0,a.useCallback)((()=>[j(e.formData,e.payload,i(),c)]),[e.formData,e.payload,c]),{formData:u,payload:g,setControlValue:p}=e;return(0,R.Y)("div",{children:(0,R.Y)(L.S,{ref:t,viewport:s,layers:d(),setControlValue:p,mapStyle:u.mapbox_style,mapboxApiAccessToken:g.data.mapboxApiKey,width:e.width,height:e.height})})},D=(0,a.memo)(z)},42634:()=>{}}]);