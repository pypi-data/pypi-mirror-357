# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic
import typing_extensions
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.serialization import FieldMetadata
from ..core.unchecked_base_model import UncheckedBaseModel
from .api_request_tool_messages_item import ApiRequestToolMessagesItem
from .api_request_tool_method import ApiRequestToolMethod
from .backoff_plan import BackoffPlan
from .json_schema import JsonSchema
from .open_ai_function import OpenAiFunction
from .variable_extraction_plan import VariableExtractionPlan


class ApiRequestTool(UncheckedBaseModel):
    messages: typing.Optional[typing.List[ApiRequestToolMessagesItem]] = pydantic.Field(default=None)
    """
    These are the messages that will be spoken to the user as the tool is running.
    
    For some tools, this is auto-filled based on special fields like `tool.destinations`. For others like the function tool, these can be custom configured.
    """

    type: typing.Literal["apiRequest"] = "apiRequest"
    method: ApiRequestToolMethod
    timeout_seconds: typing_extensions.Annotated[typing.Optional[float], FieldMetadata(alias="timeoutSeconds")] = (
        pydantic.Field(default=None)
    )
    """
    This is the timeout in seconds for the request. Defaults to 20 seconds.
    
    @default 20
    """

    id: str = pydantic.Field()
    """
    This is the unique identifier for the tool.
    """

    org_id: typing_extensions.Annotated[str, FieldMetadata(alias="orgId")] = pydantic.Field()
    """
    This is the unique identifier for the organization that this tool belongs to.
    """

    created_at: typing_extensions.Annotated[dt.datetime, FieldMetadata(alias="createdAt")] = pydantic.Field()
    """
    This is the ISO 8601 date-time string of when the tool was created.
    """

    updated_at: typing_extensions.Annotated[dt.datetime, FieldMetadata(alias="updatedAt")] = pydantic.Field()
    """
    This is the ISO 8601 date-time string of when the tool was last updated.
    """

    function: typing.Optional[OpenAiFunction] = pydantic.Field(default=None)
    """
    This is the function definition of the tool.
    
    For `endCall`, `transferCall`, and `dtmf` tools, this is auto-filled based on tool-specific fields like `tool.destinations`. But, even in those cases, you can provide a custom function definition for advanced use cases.
    
    An example of an advanced use case is if you want to customize the message that's spoken for `endCall` tool. You can specify a function where it returns an argument "reason". Then, in `messages` array, you can have many "request-complete" messages. One of these messages will be triggered if the `messages[].conditions` matches the "reason" argument.
    """

    name: typing.Optional[str] = pydantic.Field(default=None)
    """
    This is the name of the tool. This will be passed to the model.
    
    Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 40.
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    This is the description of the tool. This will be passed to the model.
    """

    url: str = pydantic.Field()
    """
    This is where the request will be sent.
    """

    body: typing.Optional[JsonSchema] = pydantic.Field(default=None)
    """
    This is the body of the request.
    """

    headers: typing.Optional[JsonSchema] = pydantic.Field(default=None)
    """
    These are the headers to send in the request.
    """

    backoff_plan: typing_extensions.Annotated[typing.Optional[BackoffPlan], FieldMetadata(alias="backoffPlan")] = (
        pydantic.Field(default=None)
    )
    """
    This is the backoff plan if the request fails. Defaults to undefined (the request will not be retried).
    
    @default undefined (the request will not be retried)
    """

    variable_extraction_plan: typing_extensions.Annotated[
        typing.Optional[VariableExtractionPlan], FieldMetadata(alias="variableExtractionPlan")
    ] = pydantic.Field(default=None)
    """
    This is the plan that controls the variable extraction from the tool's response.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
