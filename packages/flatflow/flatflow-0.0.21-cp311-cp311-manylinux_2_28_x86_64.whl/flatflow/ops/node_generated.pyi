from __future__ import annotations

import flatbuffers
import numpy as np

import flatbuffers
import typing
from flatflow.ops.operator_generated import Operator

uoffset: typing.TypeAlias = flatbuffers.number_types.UOffsetTFlags.py_type

class SymInt(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def Data(self, i: int) -> typing.List[int]: ...
  def DataAsNumpy(self) -> np.ndarray: ...
  def DataLength(self) -> int: ...
  def DataIsNone(self) -> bool: ...

def CreateSymInt(builder: flatbuffers.Builder, data: int) -> uoffset: ...
class TensorMetadata(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> TensorMetadata: ...
  @classmethod
  def GetRootAsTensorMetadata(cls, buf: bytes, offset: int) -> TensorMetadata: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Shape(self, i: int) -> SymInt | None: ...
  def ShapeLength(self) -> int: ...
  def ShapeIsNone(self) -> bool: ...
def TensorMetadataStart(builder: flatbuffers.Builder) -> None: ...
def TensorMetadataAddShape(builder: flatbuffers.Builder, shape: uoffset) -> None: ...
def TensorMetadataStartShapeVector(builder: flatbuffers.Builder, num_elems: int) -> uoffset: ...
def TensorMetadataEnd(builder: flatbuffers.Builder) -> uoffset: ...
class Node(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Node: ...
  @classmethod
  def GetRootAsNode(cls, buf: bytes, offset: int) -> Node: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Target(self) -> typing.Literal[Operator._SOFTMAX, Operator._TO_COPY, Operator._UNSAFE_VIEW, Operator.ADD_TENSOR, Operator.ADDMM, Operator.ALIAS, Operator.ARANGE, Operator.ARANGE_START, Operator.BMM, Operator.CAT, Operator.CLONE, Operator.COS, Operator.CUMSUM, Operator.EMBEDDING, Operator.EXPAND, Operator.FULL, Operator.GELU, Operator.GT_TENSOR, Operator.LT_TENSOR, Operator.MASKED_FILL_SCALAR, Operator.MEAN_DIM, Operator.MM, Operator.MUL_SCALAR, Operator.MUL_TENSOR, Operator.NATIVE_LAYER_NORM, Operator.NEG, Operator.ONES, Operator.ONES_LIKE, Operator.PERMUTE, Operator.POW_TENSOR_SCALAR, Operator.RELU, Operator.RSQRT, Operator.RSUB_SCALAR, Operator.SCALAR_TENSOR, Operator.SILU, Operator.SIN, Operator.SLICE_TENSOR, Operator.SPLIT_TENSOR, Operator.SUB_TENSOR, Operator.T, Operator.TANH, Operator.TRANSPOSE_INT, Operator.TRIL, Operator.TRIU, Operator.UNSQUEEZE, Operator.VIEW, Operator.WHERE_SELF]: ...
  def Args(self, i: int) -> TensorMetadata | None: ...
  def ArgsLength(self) -> int: ...
  def ArgsIsNone(self) -> bool: ...
  def Meta(self) -> TensorMetadata | None: ...
def NodeStart(builder: flatbuffers.Builder) -> None: ...
def NodeAddTarget(builder: flatbuffers.Builder, target: typing.Literal[Operator._SOFTMAX, Operator._TO_COPY, Operator._UNSAFE_VIEW, Operator.ADD_TENSOR, Operator.ADDMM, Operator.ALIAS, Operator.ARANGE, Operator.ARANGE_START, Operator.BMM, Operator.CAT, Operator.CLONE, Operator.COS, Operator.CUMSUM, Operator.EMBEDDING, Operator.EXPAND, Operator.FULL, Operator.GELU, Operator.GT_TENSOR, Operator.LT_TENSOR, Operator.MASKED_FILL_SCALAR, Operator.MEAN_DIM, Operator.MM, Operator.MUL_SCALAR, Operator.MUL_TENSOR, Operator.NATIVE_LAYER_NORM, Operator.NEG, Operator.ONES, Operator.ONES_LIKE, Operator.PERMUTE, Operator.POW_TENSOR_SCALAR, Operator.RELU, Operator.RSQRT, Operator.RSUB_SCALAR, Operator.SCALAR_TENSOR, Operator.SILU, Operator.SIN, Operator.SLICE_TENSOR, Operator.SPLIT_TENSOR, Operator.SUB_TENSOR, Operator.T, Operator.TANH, Operator.TRANSPOSE_INT, Operator.TRIL, Operator.TRIU, Operator.UNSQUEEZE, Operator.VIEW, Operator.WHERE_SELF]) -> None: ...
def NodeAddArgs(builder: flatbuffers.Builder, args: uoffset) -> None: ...
def NodeStartArgsVector(builder: flatbuffers.Builder, num_elems: int) -> uoffset: ...
def NodeAddMeta(builder: flatbuffers.Builder, meta: uoffset) -> None: ...
def NodeEnd(builder: flatbuffers.Builder) -> uoffset: ...

