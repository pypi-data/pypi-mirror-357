import{H as v,g as k}from"./index-CjE8KAxu.js";import{f as L}from"./util-D5zhIDgq.js";import{a as P}from"./avro-Dd9UqmeZ.js";import{W as R}from"./RoadNetworkLoader.worker-CM-DT8Nw.js";import{C as p}from"./Coords-CQQjH_Bj.js";import{r as S}from"./group-DobYzF2-.js";function F(m){return new Worker("/assets/DataFetcher.worker-BEGJ5mrK.js",{name:m?.name})}const C=!!window.showDirectoryPicker,D=!C;class T{constructor(...t){this.root=t.length?t[0]:"",this.subfolder=t.length?t[1]:"",this.fileApi=this._getFileSystem(this.root)}threads=[];subfolder="";root="";fileApi;networks={};featureCollections={};kill(){for(const t of this.threads)t.terminate()}getFilteredDataset(t){return t.dataset in this.datasets?{filteredRows:this.datasets[t.dataset].filteredRows}:{filteredRows:null}}async OLDgetFiltered(t){const s=this.datasets[t.dataset].filteredRows;if(!s)return{filteredRows:null};let e={};if(t.value&&t.groupBy){const n=t.value,i=t.groupBy;e=S(s,d=>d.reduce((a,r)=>a+r[n],0),d=>d[i])}const c=Array.from(e.keys()),o=Array.from(e.values());return{filteredRows:{x:c,y:o}}}async getDataset(t,s){try{const e=`${s?.subfolder||this.subfolder}/${t.dataset}`;this.datasets[e]||(console.log("LOAD:",e),this.datasets[e]={dataset:this._fetchDataset(t,s),activeFilters:{},filteredRows:null,filterListeners:new Set});let o=await((a,r)=>{const u=new Promise((l,h)=>{setTimeout(()=>{h(new Error(`Operation timed out after ${r}s`))},r*1e3)});return Promise.race([a,u])})(this.datasets[e].dataset,60),{_comments:n,...i}=o,d=n;return t.ignoreColumns&&t.ignoreColumns.forEach(a=>{delete i[a]}),t.useLastRow&&Object.keys(i).forEach(a=>{const r=o[a].values;i[a]=r[r.length-1]}),{allRows:i,comments:d}}catch(e){const c=(""+e).replaceAll("Error: ","");throw console.error(c),Error(c)}}setRowWisePropertyTable(t,s,e){const c=t.substring(t.lastIndexOf("/")+1);let o={dataset:c};return typeof e!="string"&&(o=Object.assign(o,e)),this.datasets[c]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise(n=>{n(s)})},this.datasets[c].dataset}getFeatureCollection(t){return this.featureCollections[t]}async registerFeatures(t,s,e){this.featureCollections[t]=s;const c=s.map(o=>o.properties||{});await this.setFeatureProperties(t,c,e),s.forEach(o=>{o.properties={}})}setFeatureProperties(t,s,e){const c=t.substring(t.lastIndexOf("/")+1),o=`${e?.subfolder||""}/${c}`;let n={dataset:o};return typeof e!="string"&&(n=Object.assign(n,e)),this.datasets[o]={activeFilters:{},filteredRows:null,filterListeners:new Set,dataset:new Promise((i,d)=>{const a=new F;this.threads.push(a);try{a.postMessage({config:n,featureProperties:s}),a.onmessage=r=>{a.terminate(),r.data.error&&(console.error(r.data.error),d(`Problem loading properties in ${t}`)),i(r.data)}}catch(r){a.terminate(),console.error(r),d(r)}})},this.datasets[o].dataset}setPreloadedDataset(t){this.datasets[t.key]={dataset:new Promise((s,e)=>{s(t.dataTable)}),activeFilters:{},filteredRows:null,filterListeners:new Set}}async getRoadNetwork(t,s,e,c,o){const n=`/${s}/${t}`,i={};return e.projection&&(i.crs=e.projection),this.networks[n]||(this.networks[n]=this._fetchNetwork({subfolder:s,filename:t,vizDetails:e,cbStatus:c,options:i,extra:o})),await this.networks[n]}async setFilter(t){const{dataset:s,column:e,value:c,invert:o,range:n}=t;if(!this.datasets[s]){console.warn(`${s} doesn't exist yet`),console.warn(Object.keys(this.datasets));return}console.log("> setFilter",s,e,c);const i=Array.isArray(c)?c:[c];this.datasets[s].activeFilters==null&&(this.datasets[s].activeFilters={});const d=this.datasets[s].activeFilters;i.length?d[e]={values:i,invert:o,range:n}:delete d[e],await this._updateFilters(s)}addFilterListener(t,s){try{const e=`${t.subfolder||this.subfolder}/${t.dataset}`;if(!this.datasets[e])throw Error("Can't add listener, no dataset named: "+e);this.datasets[e].filterListeners.add(s)}catch(e){console.error("CANT ADD FILTER LISTENER"+e)}}removeFilterListener(t,s){const e=`${t.subfolder||this.subfolder}/${t.dataset}`;try{this.datasets[e].filterListeners&&this.datasets[e].filterListeners.delete(s)}catch{}}clearCache(){this.kill(),this.datasets={},this.networks={}}async _updateFilters(t){console.log("> updateFilters ",t);const s=this.datasets[t];if(console.log({metaData:s}),!Object.keys(s.activeFilters).length){console.log("no keys"),s.filteredRows=null,this._notifyListeners(t);return}const e=await s.dataset,c=Object.keys(e);let o=[];const n=e[c[0]].values.length;console.log("FILTERS:",s.activeFilters),console.log("TOTLROWS",n);const i=new Array(n).fill(!0),d=/^(<|>)/;for(const[a,r]of Object.entries(s.activeFilters)){const u=e[a];if(r.values[0]===void 0||r.values[0]==="")throw Error(t+": filter error");if(d.test(r.values[0]))r.values[0].startsWith("<=")?(r.conditional="<=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith(">=")?(r.conditional=">=",r.values[0]=r.values[0].substring(2).trim()):r.values[0].startsWith("<")?(r.conditional="<",r.values[0]=r.values[0].substring(1).trim()):r.values[0].startsWith(">")&&(r.conditional=">",r.values[0]=r.values[0].substring(1).trim());else if(r.values.length===1&&typeof r.values[0]=="string"){const l=parseFloat(r.values[0]);Number.isFinite(l)&&r.values.push(l)}for(let l=0;l<n;l++)E(r,u.values[l])||(i[l]=!1)}for(let a=0;a<n;a++)if(i[a]){const r={};c.forEach(u=>r[u]=e[u].values[a]),o.push(r)}s.filteredRows=o,this._notifyListeners(t)}_notifyListeners(t){const s=this.datasets[t];for(const e of s.filterListeners)e(t)}async _fetchDataset(t,s){const{files:e}=await new v(this.fileApi).getDirectory(s?.subfolder||this.subfolder);return new Promise((c,o)=>{const n=new F;this.threads.push(n);try{n.postMessage({fileSystemConfig:this.fileApi,subfolder:s?.subfolder||this.subfolder,files:e,config:t,options:s}),n.onmessage=i=>{if(n.terminate(),!i.data||i.data.error){let d=""+(i.data?.error||"Error loading file");d=d.replace("[object Response]","Error loading file"),t?.dataset&&d.indexOf(t.dataset)===-1&&(d+=`: ${t.dataset}`),o(d)}c(i.data)}}catch(i){n.terminate(),console.error(i),o(i)}})}async _getAvroNetwork(t){const e=await new v(this.fileApi).getFileBlob(`${t.subfolder}/${t.filename}`),o=(await new Promise(async(f,b)=>{const w=[];P.createBlobDecoder(e).on("metadata",y=>{}).on("data",y=>{w.push(y)}).on("end",()=>{f(w)})}))[0],n=o.linkId.length,i=o.crs||"EPSG:4326",d=i!=="EPSG:4326"&&i!=="WGS84",a=new Float32Array(2*n),r=new Float32Array(2*n),u=[];let l=[0,0],h=[0,0];for(let f=0;f<n;f++){const b=o.linkId[f],w=2*o.from[f],y=2*o.to[f];l[0]=o.nodeCoordinates[w],l[1]=o.nodeCoordinates[1+w],h[0]=o.nodeCoordinates[y],h[1]=o.nodeCoordinates[1+y],d&&(l=p.toLngLat(i,l),h=p.toLngLat(i,h)),a[2*f+0]=l[0],a[2*f+1]=l[1],r[2*f+0]=h[0],r[2*f+1]=h[1],u[f]=b}const g={source:a,dest:r,linkIds:u,projection:"EPSG:4326"};for(const f of o.linkAttributes)f!=="linkId"&&(g[f]=o[f]);return g}async _fetchNetwork(t){return new Promise(async(s,e)=>{const{subfolder:c,filename:o,vizDetails:n,cbStatus:i,options:d}=t,a=`/${c}/${o}`;console.log("load network:",a);let r=a.indexOf("/")>-1?a.substring(0,a.lastIndexOf("/")):this.subfolder;try{const{files:l}=await new v(this.fileApi).getDirectory(r);let h=a.indexOf("/")===-1?a:a.substring(a.lastIndexOf("/")+1);L(l,h).length!==1&&e("File not found: "+a)}catch{e("Error reading folder: "+r)}if(o.toLocaleLowerCase().endsWith(".avro")){const l=await this._getAvroNetwork(t);s(l);return}const u=new R;try{u.onmessage=l=>{if(l.data.promptUserForCRS){let h=prompt('Enter the projection coordinate reference system, e.g. "EPSG:25832", or cancel if unknown')||"Atlantis";Number.isInteger(parseInt(h))&&(h=`EPSG:${h}`),u.postMessage({crs:h});return}if(l.data.status){i&&i(l.data.status);return}u.terminate(),l.data.error&&(console.error(l.data.error),e(l.data.error)),s(l.data.links)},u.postMessage({filePath:a,fileSystem:this.fileApi,vizDetails:n,options:d,extraColumns:!!t.extra,isFirefox:D})}catch(l){u.terminate(),console.error(l),e(l)}})}_getFileSystem(t){const s=k.state.svnProjects.filter(e=>e.slug===t);if(s.length===0)throw console.error(`DDM: no such project, is slug correct? (${t})`),Error;return s[0]}datasets={}}function E(m,t){const s={"<":()=>t<m.values[0],"<=":()=>t<=m.values[0],">":()=>t>m.values[0],">=":()=>t>=m.values[0]};let e;return m.range?e=t>=m.values[0]&&t<=m.values[1]:m.conditional?e=s[m.conditional]():e=m.values.includes(t),m.invert?!e:e}export{T as D,F as W,E as c};
