from pydantic import BaseModel, Field, model_validator
from typing import Union, Optional, Any
from tablevault._table_reference.table_reference import (
    TableValue,
    TableReference,
    get_table_result,
    table_reference_from_string,
)
from tablevault._defintions import constants, tv_errors, types
from tablevault._dataframe_helper.artifact import apply_artifact_path
from tablevault._helper.copy_write_file import CopyOnWriteFile
import logging


class TVBuilder(BaseModel):
    name: Union[str, TableReference] = Field(
        description="Name of builder (autogenerated). Do not have to file."
    )
    dtypes: Union[
        TableReference, dict[Union[str, TableReference], Union[str, TableReference]]
    ] = Field(
        default={},
        description="Specify Pandas datatype of output columns: column_name: dtype.",
    )
    dependencies: Optional[list[TableValue]] = Field(
        default=None,
        description="Specifies table dependencies (can be autogenerated).",
    )
    changed_columns: Union[TableReference, list[Union[str, TableReference]]] = Field(
        description="Specifies the output column names that are generated."
    )
    builder_type: Union[str, TableReference] = Field(
        description="""Type of builder. See
        tablevault.builders.builder_type_mapping for supported Builders."""
    )
    is_custom: Union[bool, TableReference] = Field(description="Custom to database.")

    return_type: Union[str, TableReference] = Field(
        default="dataframe", description="Return type: [dataframe, row-wise, generator]"
    )

    n_threads: Union[int, TableReference] = Field(
        default=1, description="Number of Threads to run (if udf)."
    )
    code_module: Union[str, TableReference] = Field(description="Module of function.")

    python_function: Union[str, TableReference] = Field(
        description="Function to execute."
    )
    arguments: Union[TableReference, dict[Union[str, TableReference], Any]] = Field(
        description="Function"
    )

    @model_validator(mode="before")
    @classmethod
    def transform_fields_to_table_string(cls, values):
        for field_name, model_field in cls.model_fields.items():
            if field_name in values:
                expected_type = model_field.annotation
                values[field_name] = table_reference_from_string(
                    expected_type, values[field_name]
                )
        if (
            constants.BUILDER_DEPENDENCIES not in values
            or values[constants.BUILDER_DEPENDENCIES] is None
        ):
            deps = _get_builder_dependencies(values)
            if deps is None:
                raise tv_errors.TVBuilderError(
                    "Unclear dependencies - Need explicity specifications"
                )
            values[constants.BUILDER_DEPENDENCIES] = deps
        return values

    def execute(
        self,
        cache: types.Cache,
        instance_id: str,
        table_name: str,
        db_dir: str,
        process_id: str,
        file_writer: CopyOnWriteFile,
    ) -> Optional[bool]:
        raise tv_errors.TVImplementationError("Not Implemented")

    def transform_table_string(
        self,
        cache: types.Cache,
        instance_id: str,
        table_name: str,
        db_dir: str,
        process_id: str,
        index: Optional[int] = None,
        arguments: bool = False,
    ) -> None:
        for attr, val in vars(self).items():
            if attr == constants.BUILDER_ARGUMENTS and not arguments:
                continue
            if attr != constants.BUILDER_DEPENDENCIES:
                val_ = get_table_result(val, cache, index)
                val_ = apply_artifact_path(
                    val_, instance_id, table_name, db_dir, process_id
                )
                try:
                    setattr(self, attr, val_)
                except Exception as e:
                    logger = logging.getLogger(__name__)
                    logger.info(f"Immutable Object {e}")
                    continue


def _get_builder_dependencies(values) -> Optional[list[TableValue]]:
    tables = []
    if isinstance(values, TableReference):
        return values.get_data_tables()
    elif isinstance(values, list):
        for value in values:
            tables += _get_builder_dependencies(value)
    elif isinstance(values, set):
        for value in values:
            tables += _get_builder_dependencies(value)
    elif isinstance(values, dict):
        for key, value in values.items():
            tables += _get_builder_dependencies(key)
            tables += _get_builder_dependencies(value)
    elif hasattr(values, "__dict__"):
        for _, val in vars(values).items():
            tables += _get_builder_dependencies(val)
    for table in tables:
        if table is None:
            return None
    return tables
