import sys
import os

# Add the src directory to sys.path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src')))
from mpec_extract import extract_end_to_end  # will look like an import error, but should be fine if src is in syspath

import pandas as pd


_extraction_already_done = False  # allows us to avoid re-running extraction for every test


def create_outputs_to_extract_df(save_to_csv=False):
    '''
    Creates a df version of the table specifying the outputs to extract
    :param save_to_csv: filepath string, if you want to save the df version of the table as a csv;
            (default = False; i.e. don't save as a csv)
    :return: (pandas df) the df version of the table
    '''

    # Create the data frame from the CSV data
    data = {
        'Output': ['Overall', 'Monthly', 'Monthly', 'Monthly', 'Monthly ', 'Monthly ', 'Monthly ', 'Monthly ',
                   'Monthly', 'Monthly ', 'Monthly ', 'Monthly ', 'Monthly '],

        'Label': ['Initial Dist CD4 VHI', 'Transmission', 'HIV+undetected', 'HIV+unlinked', 'HIV+incare', 'HIV+LTFU',
                  'HIV+RTC', 'CHRM7_Death', 'PWH_Deaths_HIV+undetected', 'PWH_Deaths_HIV+unlinked',
                  'PWH_Deaths_HIV+incare', 'PWH_Deaths_HIV+LTFU ', 'PWH_Deaths_HIV+RTC'],

        'Section': ['INITIAL DISTRIBUTIONS', '', '', '', '', '', '', '', '', '', '', '', ''],

        'TextID': ['CD4 Count Level', 'Self Transmission Rate Multiplier', '#Alive', '#Alive', '#Alive', '#Alive',
                   '#Alive', 'Total Dths w. CHRM6', 'Age-Stratified Outputs', 'Age-Stratified Outputs',
                   'Age-Stratified Outputs', 'Age-Stratified Outputs', 'Age-Stratified Outputs'],

        'RowOffset': [1, 2, 2, 3, 4, 5, 6, 6, 4, 6, 8, 10, 12],
        'ColLetter': ['C', 'J', 'C', 'C', 'C', 'C', 'C', 'AF', 'Q', 'Q', 'Q', 'Q', 'Q'],
        'Months': ['', '1-5', '1-10', '1, 2, 3', '1, 2, 4', '1, 2, 5', '1, 2, 6', '1, 2, 7', '1, 2, 8', '1, 2, 9',
                   '1, 2, 10', '1, 2, 11', '1, 2, 12']
    }

    df = pd.DataFrame(data)

    # optional, save  as a csv file:
    if save_to_csv:
        df.to_csv('output_data.csv', index=False)

    return df


def is_equal_monthly_vs_gui_output(lib_df, gui_df):
    """
    Compare monthly outputs generated by the current library (lib_df) versus the MCT GUI (gui_df).
    :param lib_df: has columns: output, mth, run, val
    :param gui_df: index is "Month {i} {output}", columns are runs
    :return:
    """

    # look at monthly outputs only
    gui_df = gui_df[gui_df.index.str.startswith("Month")]

    # reformat gui_df to match lib_df structure
    # bring gui's "Month {i} {output}" into a column
    gui_df_reset = gui_df.reset_index().melt(id_vars=['index'], var_name='run', value_name='val')
    gui_df_reset[['mth_str', 'output']] = gui_df_reset['index'].str.extract(r'Month (\d+)\s+(.+)')
    gui_df_reset['mth'] = gui_df_reset['mth_str'].astype(int)
    gui_df_reset = gui_df_reset.drop(columns=['index', 'mth_str'])

    # get just the filename from the full run path
    gui_df_reset['run'] = gui_df_reset['run'].apply(lambda x: os.path.basename(x))
    lib_df['run'] = lib_df['run'].apply(lambda x: os.path.basename(x))

    # rearranged to same column order as lib_df
    gui_df_reorder = gui_df_reset[['output', 'mth', 'run', 'val']]

    # convert val to float
    lib_df['val'] = lib_df['val'].astype(float)
    gui_df_reorder['val'] = gui_df_reorder['val'].astype(float)

    # sort both dfs
    lib_df_sorted = lib_df.sort_values(by=['output', 'mth', 'run']).reset_index(drop=True)
    gui_df_sorted = gui_df_reorder.sort_values(by=['output', 'mth', 'run']).reset_index(drop=True)

    # compare
    are_equal = lib_df_sorted.equals(gui_df_sorted)
    print("Are the outputs equal?", are_equal)

    lib_df_sorted.to_csv("debug_lib_df_sorted.csv")
    gui_df_sorted.to_csv("debug_gui_df_sorted.csv")

    return are_equal


def is_equal_overall_vs_gui_output(lib_df, gui_df):
    """
    Compare overall (non-monthly) outputs generated by the current library (lib_df) versus the MCT GUI (gui_df).

    :param lib_df: DataFrame with columns: run_name, {Output Name columns}, Run Size
    :param gui_df: DataFrame with columns as run paths and rows as output types (index)
    :return: bool indicating whether lib_df and gui_df are equivalent
    """
    # look at overall (non-monthly) outputs only
    gui_df_filtered = gui_df[~gui_df.index.str.startswith("Month")]

    # reformat gui_df to match lib_df structure
    gui_long = gui_df_filtered.reset_index().melt(id_vars=["index"], var_name="run_name", value_name="val")
    gui_long = gui_long.rename(columns={"index": "output"})

    # get just the filename from the full run path
    gui_long["run_name"] = gui_long["run_name"].apply(os.path.basename)
    lib_df["run_name"] = lib_df["run_name"].apply(os.path.basename)

    # get same columnns and rows in both dfs
    lib_long = lib_df.melt(id_vars=["run_name"], var_name="output", value_name="val")

    # convert val to float
    gui_long["val"] = gui_long["val"].astype(float)
    lib_long["val"] = lib_long["val"].astype(float)

    # sort both dfs
    gui_sorted = gui_long.sort_values(by=["output", "run_name"]).reset_index(drop=True)
    lib_sorted = lib_long.sort_values(by=["output", "run_name"]).reset_index(drop=True)

    # rearranged to same column order as lib_df
    gui_sorted = gui_sorted[["run_name", "output", "val"]]
    lib_sorted = lib_sorted[["run_name", "output", "val"]]

    gui_sorted.to_csv("debug_gui_overall_sorted.csv", index=False)
    lib_sorted.to_csv("debug_lib_overall_sorted.csv", index=False)

    are_equal = gui_sorted.equals(lib_sorted)
    print("Are the overall outputs equal?", are_equal)

    return are_equal


def run_extraction():
    """ Extracts desired outputs from a folder with output files, used for testing.
    Uses outputs to extract hardcoded in the create_outputs_to_extract() function.

    Required in the working directory:
    - a folder "20plusoutfiles" with 1+ .out files in it
    - a data file "50d_new.out_data
    """

    global _extraction_already_done

    if _extraction_already_done:
        return

    data_filepath = r"./50d_new.out_data"
    all_outfiles_dir = r"./20plus_outfiles"
    desired_outputs = create_outputs_to_extract_df()

    # extract overall outputs
    extract_end_to_end(data_filepath, desired_outputs, all_outfiles_dir, overall=True,
                       save_as_csv='./df_to_csv_overall_python.csv')

    # extract monthly outputs
    extract_end_to_end(data_filepath, desired_outputs, all_outfiles_dir,
                        monthly=True, save_as_csv='./mth_outputs.csv')

    _extraction_already_done = True


def test_monthly_extract_is_wrong():
    """ Check that monthly extract comparison fails when the library-generated extraction and the GUI extraction
    values do not match.

    Requires './20plus_mct_out_wrong.extract_out' file in the current working directory
    Note './mth_outputs.csv' will be generated through the run_extraction() function"""

    run_extraction()

    lib_df = pd.read_csv('./mth_outputs.csv')  # has columns: output, mth, run, val
    gui_df = pd.read_csv('./20plus_mct_out_wrong.extract_out', index_col=0,
                         sep='\t')  # index is "Month {i} {output}", columns are runs

    assert not is_equal_monthly_vs_gui_output(lib_df, gui_df)


def test_monthly_extract():
    """ Check that the library-generated extraction and the GUI extraction generate the same monthly output values.

    Requires './20plus_mct_out_wrong.extract_out' file in the current working directory
    Note './mth_outputs.csv' will be generated through the run_extraction() function"""

    run_extraction()

    lib_df = pd.read_csv('./mth_outputs.csv')  # has columns: output, mth, run, val
    gui_df = pd.read_csv('./20plus_mct_out.extract_out', index_col=0, sep='\t')  # index is "Month {i} {output}", columns are runs

    assert is_equal_monthly_vs_gui_output(lib_df, gui_df)


def test_overall_extract():
    """ Check that the library-generated extraction and the GUI extraction generate the same overall output values.

    Requires './20plus_mct_out_wrong.extract_out' file in the current working directory
    Note './df_to_csv_overall_python.csv' will be generated through the run_extraction() function"""

    run_extraction()

    lib_df = pd.read_csv('./df_to_csv_overall_python.csv')  # has columns: output, mth, run, val
    gui_df = pd.read_csv('./20plus_mct_out.extract_out', index_col=0,
                         sep='\t')  # index is "Month {i} {output}", columns are runs

    assert is_equal_overall_vs_gui_output(lib_df, gui_df)


def test_overall_extract_is_wrong():
    """ Check that overall extract comparison fails when the library-generated extraction and the GUI extraction
        values do not match.

        Requires './20plus_mct_out_wrong.extract_out' file in the current working directory
        Note './df_to_csv_overall_python.csv' will be generated through the run_extraction() function"""

    run_extraction()

    lib_df = pd.read_csv('./df_to_csv_overall_python.csv')  # has columns: output, mth, run, val
    gui_df = pd.read_csv('./20plus_mct_out_wrong.extract_out', index_col=0,
                         sep='\t')  # index is "Month {i} {output}", columns are runs

    assert not is_equal_overall_vs_gui_output(lib_df, gui_df)






