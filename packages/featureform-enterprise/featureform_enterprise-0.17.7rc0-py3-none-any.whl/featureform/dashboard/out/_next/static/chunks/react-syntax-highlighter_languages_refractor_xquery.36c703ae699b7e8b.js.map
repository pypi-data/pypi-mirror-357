{"version":3,"file":"static/chunks/react-syntax-highlighter_languages_refractor_xquery.36c703ae699b7e8b.js","mappings":"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","sources":["webpack://_N_E/./node_modules/refractor/lang/xquery.js","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n\nmodule.exports = xquery\nxquery.displayName = 'xquery'\nxquery.aliases = []\nfunction xquery(Prism) {\n  ;(function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern:\n          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern:\n          /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern:\n          /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern:\n          /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n        {\n          pattern: /(\\s)-(?=\\s)/,\n          lookbehind: true\n        }\n      ],\n      punctuation: /[[\\](){},;:/]/\n    })\n    Prism.languages.xquery.tag.pattern =\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern =\n      /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =\n      /^=\"|\"$/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    } // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{' && // Ignore `{{`\n            (!tokens[i + 1] ||\n              tokens[i + 1].type !== 'punctuation' ||\n              tokens[i + 1].content !== '{') &&\n            (!tokens[i - 1] ||\n              tokens[i - 1].type !== 'plain-text' ||\n              tokens[i - 1].content !== '{')\n          ) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText\n            } else {\n              tokens[i] = new Prism.Token(\n                'plain-text',\n                plainText,\n                null,\n                plainText\n              )\n            }\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[982],{\n\n/***/ 20349:\n/***/ (function(module) {\n\n\n\nmodule.exports = xquery\nxquery.displayName = 'xquery'\nxquery.aliases = []\nfunction xquery(Prism) {\n  ;(function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern:\n          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern:\n          /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern:\n          /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern:\n          /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n        {\n          pattern: /(\\s)-(?=\\s)/,\n          lookbehind: true\n        }\n      ],\n      punctuation: /[[\\](){},;:/]/\n    })\n    Prism.languages.xquery.tag.pattern =\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern =\n      /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =\n      /^=\"|\"$/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    } // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{' && // Ignore `{{`\n            (!tokens[i + 1] ||\n              tokens[i + 1].type !== 'punctuation' ||\n              tokens[i + 1].content !== '{') &&\n            (!tokens[i - 1] ||\n              tokens[i - 1].type !== 'plain-text' ||\n              tokens[i - 1].content !== '{')\n          ) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText\n            } else {\n              tokens[i] = new Prism.Token(\n                'plain-text',\n                plainText,\n                null,\n                plainText\n              )\n            }\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n\n\n/***/ })\n\n}]);"],"names":["self","push","module","xquery","Prism","stringifyToken","walkTokens","languages","extend","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation","tag","inside","token","content","map","join","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","openedBraces","plainText","splice","test","Token","hooks","add","env","language","exports","displayName","aliases"],"sourceRoot":""}