{"version":3,"file":"static/chunks/react-syntax-highlighter_languages_refractor_jsx.4edbd6bef3b568e3.js","mappings":"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","sources":["webpack://_N_E/./node_modules/refractor/lang/jsx.js","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n    function re(source, flags) {\n      source = source\n        .replace(/<S>/g, function () {\n          return space\n        })\n        .replace(/<BRACES>/g, function () {\n          return braces\n        })\n        .replace(/<SPREAD>/g, function () {\n          return spread\n        })\n      return RegExp(source, flags)\n    }\n    spread = re(spread).source\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = re(\n      /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n        .source\n    )\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/\n    Prism.languages.jsx.tag.inside['attr-value'].pattern =\n      /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n      /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment']\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: re(/<SPREAD>/.source),\n          inside: Prism.languages.jsx\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'special-attr',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: re(/=<BRACES>/.source),\n          alias: 'language-javascript',\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?=\\{)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    ) // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[4657],{\n\n/***/ 96412:\n/***/ (function(module) {\n\n\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n    function re(source, flags) {\n      source = source\n        .replace(/<S>/g, function () {\n          return space\n        })\n        .replace(/<BRACES>/g, function () {\n          return braces\n        })\n        .replace(/<SPREAD>/g, function () {\n          return spread\n        })\n      return RegExp(source, flags)\n    }\n    spread = re(spread).source\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = re(\n      /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n        .source\n    )\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/\n    Prism.languages.jsx.tag.inside['attr-value'].pattern =\n      /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n      /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment']\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: re(/<SPREAD>/.source),\n          inside: Prism.languages.jsx\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'special-attr',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: re(/=<BRACES>/.source),\n          alias: 'language-javascript',\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?=\\{)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    ) // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n\n\n/***/ })\n\n}]);"],"names":["self","push","module","jsx","Prism","javascript","util","clone","languages","space","source","braces","spread","re","flags","RegExp","replace","extend","tag","pattern","inside","insertBefore","script","alias","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","openedBraces","plainText","splice","Token","hooks","add","env","language","exports","displayName","aliases"],"sourceRoot":""}