{"version":3,"file":"static/chunks/react-syntax-highlighter_languages_refractor_lisp.8e14602c7035b2ba.js","mappings":"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","sources":["webpack://_N_E/./node_modules/refractor/lang/lisp.js","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function (Prism) {\n    /**\n     * Functions to construct regular expressions\n     * e.g. (interactive ... or (interactive)\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function simple_form(name) {\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source)\n    }\n    /**\n     * booleans and numbers\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n    function primitive(pattern) {\n      return RegExp(\n        /([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source\n      )\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var nestedPar =\n      /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/\n        .source\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:append|by|collect|concat|do|finally|for|in|return)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form(/declare/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form(/interactive/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive(/nil|t/.source),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source +\n            symbol +\n            /\\s+\\(/.source +\n            nestedPar +\n            /\\)/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(\n          par +\n            'lambda\\\\s+\\\\(\\\\s*(?:&?' +\n            symbol +\n            '(?:\\\\s+&?' +\n            symbol +\n            ')*\\\\s*)?\\\\)'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(?:['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      varform: {\n        pattern: RegExp(\n          /\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source\n        ),\n        inside: language\n      },\n      argument: {\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\n        lookbehind: true,\n        alias: 'variable'\n      },\n      rest: language\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + nestedPar + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[3520],{\n\n/***/ 3848:\n/***/ (function(module) {\n\n\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function (Prism) {\n    /**\n     * Functions to construct regular expressions\n     * e.g. (interactive ... or (interactive)\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function simple_form(name) {\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source)\n    }\n    /**\n     * booleans and numbers\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n    function primitive(pattern) {\n      return RegExp(\n        /([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source\n      )\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var nestedPar =\n      /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/\n        .source\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:append|by|collect|concat|do|finally|for|in|return)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form(/declare/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form(/interactive/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive(/nil|t/.source),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source +\n            symbol +\n            /\\s+\\(/.source +\n            nestedPar +\n            /\\)/.source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(\n          par +\n            'lambda\\\\s+\\\\(\\\\s*(?:&?' +\n            symbol +\n            '(?:\\\\s+&?' +\n            symbol +\n            ')*\\\\s*)?\\\\)'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(?:['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      varform: {\n        pattern: RegExp(\n          /\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source\n        ),\n        inside: language\n      },\n      argument: {\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\n        lookbehind: true,\n        alias: 'variable'\n      },\n      rest: language\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + nestedPar + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n\n\n/***/ })\n\n}]);"],"names":["self","push","module","lisp","Prism","simple_form","name","RegExp","source","primitive","pattern","symbol","par","space","nestedPar","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","varform","rest","forms","arglist","keys","util","clone","sublist","languages","elisp","emacs","exports","displayName","aliases"],"sourceRoot":""}