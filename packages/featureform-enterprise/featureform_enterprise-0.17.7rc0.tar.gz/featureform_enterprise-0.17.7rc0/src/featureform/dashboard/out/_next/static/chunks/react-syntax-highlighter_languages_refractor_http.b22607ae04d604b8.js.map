{"version":3,"file":"static/chunks/react-syntax-highlighter_languages_refractor_http.b22607ae04d604b8.js","mappings":"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","sources":["webpack://_N_E/./node_modules/refractor/lang/http.js","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n\nmodule.exports = http\nhttp.displayName = 'http'\nhttp.aliases = []\nfunction http(Prism) {\n  ;(function (Prism) {\n    /**\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function headerValueOf(name) {\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i')\n    }\n    Prism.languages.http = {\n      'request-line': {\n        pattern:\n          /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\n        inside: {\n          // HTTP Method\n          method: {\n            pattern: /^[A-Z]+\\b/,\n            alias: 'property'\n          },\n          // Request Target e.g. http://example.com, /path/to/file\n          'request-target': {\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n            lookbehind: true,\n            alias: 'url',\n            inside: Prism.languages.uri\n          },\n          // HTTP Version\n          'http-version': {\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\n            lookbehind: true,\n            alias: 'property'\n          }\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n        inside: {\n          // HTTP Version\n          'http-version': {\n            pattern: /^HTTP\\/[\\d.]+/,\n            alias: 'property'\n          },\n          // Status Code\n          'status-code': {\n            pattern: /^(\\s)\\d+(?=\\s)/,\n            lookbehind: true,\n            alias: 'number'\n          },\n          // Reason Phrase\n          'reason-phrase': {\n            pattern: /^(\\s).+/,\n            lookbehind: true,\n            alias: 'string'\n          }\n        }\n      },\n      header: {\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\n        inside: {\n          'header-value': [\n            {\n              pattern: headerValueOf(/Content-Security-Policy/.source),\n              lookbehind: true,\n              alias: ['csp', 'languages-csp'],\n              inside: Prism.languages.csp\n            },\n            {\n              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\n              lookbehind: true,\n              alias: ['hpkp', 'languages-hpkp'],\n              inside: Prism.languages.hpkp\n            },\n            {\n              pattern: headerValueOf(/Strict-Transport-Security/.source),\n              lookbehind: true,\n              alias: ['hsts', 'languages-hsts'],\n              inside: Prism.languages.hsts\n            },\n            {\n              pattern: headerValueOf(/[^:]+/.source),\n              lookbehind: true\n            }\n          ],\n          'header-name': {\n            pattern: /^[^:]+/,\n            alias: 'keyword'\n          },\n          punctuation: /^:/\n        }\n      }\n    } // Create a mapping of Content-Type headers to language definitions\n    var langs = Prism.languages\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css,\n      'text/plain': langs.plain\n    } // Declare which types can also be suffixes\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    }\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '')\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])'\n      return '(?:' + contentType + '|' + suffixPattern + ')'\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n    var options\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {}\n        var pattern = suffixTypes[contentType]\n          ? getSuffixPattern(contentType)\n          : contentType\n        options[contentType.replace(/\\//g, '-')] = {\n          pattern: RegExp(\n            '(' +\n              /content-type:\\s*/.source +\n              pattern +\n              /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source +\n              ')' + // This is a little interesting:\n              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\n              // However, when writing code by hand (e.g. to display on a website) people can forget about this,\n              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\n              // the body does not start with a [\\w-] character (as headers do).\n              /[^ \\t\\w-][\\s\\S]*/.source,\n            'i'\n          ),\n          lookbehind: true,\n          inside: httpLanguages[contentType]\n        }\n      }\n    }\n    if (options) {\n      Prism.languages.insertBefore('http', 'header', options)\n    }\n  })(Prism)\n}\n","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[6508],{\n\n/***/ 49660:\n/***/ (function(module) {\n\n\n\nmodule.exports = http\nhttp.displayName = 'http'\nhttp.aliases = []\nfunction http(Prism) {\n  ;(function (Prism) {\n    /**\n     * @param {string} name\n     * @returns {RegExp}\n     */\n    function headerValueOf(name) {\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i')\n    }\n    Prism.languages.http = {\n      'request-line': {\n        pattern:\n          /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\n        inside: {\n          // HTTP Method\n          method: {\n            pattern: /^[A-Z]+\\b/,\n            alias: 'property'\n          },\n          // Request Target e.g. http://example.com, /path/to/file\n          'request-target': {\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n            lookbehind: true,\n            alias: 'url',\n            inside: Prism.languages.uri\n          },\n          // HTTP Version\n          'http-version': {\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\n            lookbehind: true,\n            alias: 'property'\n          }\n        }\n      },\n      'response-status': {\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\n        inside: {\n          // HTTP Version\n          'http-version': {\n            pattern: /^HTTP\\/[\\d.]+/,\n            alias: 'property'\n          },\n          // Status Code\n          'status-code': {\n            pattern: /^(\\s)\\d+(?=\\s)/,\n            lookbehind: true,\n            alias: 'number'\n          },\n          // Reason Phrase\n          'reason-phrase': {\n            pattern: /^(\\s).+/,\n            lookbehind: true,\n            alias: 'string'\n          }\n        }\n      },\n      header: {\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\n        inside: {\n          'header-value': [\n            {\n              pattern: headerValueOf(/Content-Security-Policy/.source),\n              lookbehind: true,\n              alias: ['csp', 'languages-csp'],\n              inside: Prism.languages.csp\n            },\n            {\n              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\n              lookbehind: true,\n              alias: ['hpkp', 'languages-hpkp'],\n              inside: Prism.languages.hpkp\n            },\n            {\n              pattern: headerValueOf(/Strict-Transport-Security/.source),\n              lookbehind: true,\n              alias: ['hsts', 'languages-hsts'],\n              inside: Prism.languages.hsts\n            },\n            {\n              pattern: headerValueOf(/[^:]+/.source),\n              lookbehind: true\n            }\n          ],\n          'header-name': {\n            pattern: /^[^:]+/,\n            alias: 'keyword'\n          },\n          punctuation: /^:/\n        }\n      }\n    } // Create a mapping of Content-Type headers to language definitions\n    var langs = Prism.languages\n    var httpLanguages = {\n      'application/javascript': langs.javascript,\n      'application/json': langs.json || langs.javascript,\n      'application/xml': langs.xml,\n      'text/xml': langs.xml,\n      'text/html': langs.html,\n      'text/css': langs.css,\n      'text/plain': langs.plain\n    } // Declare which types can also be suffixes\n    var suffixTypes = {\n      'application/json': true,\n      'application/xml': true\n    }\n    /**\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n     *\n     * @param {string} contentType\n     * @returns {string}\n     */\n    function getSuffixPattern(contentType) {\n      var suffix = contentType.replace(/^[a-z]+\\//, '')\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])'\n      return '(?:' + contentType + '|' + suffixPattern + ')'\n    } // Insert each content type parser that has its associated language\n    // currently loaded.\n    var options\n    for (var contentType in httpLanguages) {\n      if (httpLanguages[contentType]) {\n        options = options || {}\n        var pattern = suffixTypes[contentType]\n          ? getSuffixPattern(contentType)\n          : contentType\n        options[contentType.replace(/\\//g, '-')] = {\n          pattern: RegExp(\n            '(' +\n              /content-type:\\s*/.source +\n              pattern +\n              /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source +\n              ')' + // This is a little interesting:\n              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\n              // However, when writing code by hand (e.g. to display on a website) people can forget about this,\n              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\n              // the body does not start with a [\\w-] character (as headers do).\n              /[^ \\t\\w-][\\s\\S]*/.source,\n            'i'\n          ),\n          lookbehind: true,\n          inside: httpLanguages[contentType]\n        }\n      }\n    }\n    if (options) {\n      Prism.languages.insertBefore('http', 'header', options)\n    }\n  })(Prism)\n}\n\n\n/***/ })\n\n}]);"],"names":["self","push","module","http","Prism","headerValueOf","name","RegExp","languages","pattern","inside","method","alias","lookbehind","uri","header","source","csp","hpkp","hsts","punctuation","options","langs","httpLanguages","javascript","json","xml","html","css","plain","suffixTypes","getSuffixPattern","contentType","suffix","replace","insertBefore","exports","displayName","aliases"],"sourceRoot":""}