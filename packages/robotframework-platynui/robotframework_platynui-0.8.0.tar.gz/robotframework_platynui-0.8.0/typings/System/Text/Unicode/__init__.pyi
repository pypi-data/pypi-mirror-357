# This file was generated by PythonNetStubGenerator
# mypy: ignore-errors
import typing, clr, abc
from System.Buffers import OperationStatus
from System import ReadOnlySpan_1, Span_1, IFormatProvider

class Utf8(abc.ABC):
    @staticmethod
    def FromUtf16(
        source: ReadOnlySpan_1[str],
        destination: Span_1[int],
        charsRead: clr.Reference[int],
        bytesWritten: clr.Reference[int],
        replaceInvalidSequences: bool = ...,
        isFinalBlock: bool = ...,
    ) -> OperationStatus: ...
    @staticmethod
    def IsValid(value: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def ToUtf16(
        source: ReadOnlySpan_1[int],
        destination: Span_1[str],
        bytesRead: clr.Reference[int],
        charsWritten: clr.Reference[int],
        replaceInvalidSequences: bool = ...,
        isFinalBlock: bool = ...,
    ) -> OperationStatus: ...
    # Skipped TryWrite due to it being static, abstract and generic.

    TryWrite: TryWrite_MethodGroup

    class TryWrite_MethodGroup:
        @typing.overload
        def __call__(
            self,
            destination: Span_1[int],
            handler: clr.Reference[Utf8.TryWriteInterpolatedStringHandler],
            bytesWritten: clr.Reference[int],
        ) -> bool: ...
        @typing.overload
        def __call__(
            self,
            destination: Span_1[int],
            provider: typing.Optional[IFormatProvider],
            handler: clr.Reference[Utf8.TryWriteInterpolatedStringHandler],
            bytesWritten: clr.Reference[int],
        ) -> bool: ...

    class TryWriteInterpolatedStringHandler:
        @typing.overload
        def __init__(
            self,
            literalLength: int,
            formattedCount: int,
            destination: Span_1[int],
            provider: typing.Optional[IFormatProvider],
            shouldAppend: clr.Reference[bool],
        ) -> None: ...
        @typing.overload
        def __init__(
            self, literalLength: int, formattedCount: int, destination: Span_1[int], shouldAppend: clr.Reference[bool]
        ) -> None: ...
        def AppendLiteral(self, value: str) -> bool: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted: AppendFormatted_MethodGroup

        class AppendFormatted_MethodGroup:
            def __getitem__(self, t: typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar("AppendFormatted_1_T1")

            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = (
                    Utf8.TryWriteInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                )
                @typing.overload
                def __call__(self, value: typing.Optional[AppendFormatted_1_T]) -> bool: ...
                @typing.overload
                def __call__(self, value: typing.Optional[AppendFormatted_1_T], alignment: int) -> bool: ...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: typing.Optional[str]) -> bool: ...
                @typing.overload
                def __call__(
                    self, value: AppendFormatted_1_T, alignment: int, format: typing.Optional[str]
                ) -> bool: ...

            @typing.overload
            def __call__(self, utf8Value: ReadOnlySpan_1[int]) -> bool: ...
            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> bool: ...
            @typing.overload
            def __call__(self, value: typing.Optional[str]) -> bool: ...
            @typing.overload
            def __call__(
                self, utf8Value: ReadOnlySpan_1[int], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> bool: ...
            @typing.overload
            def __call__(
                self, value: ReadOnlySpan_1[str], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> bool: ...
            @typing.overload
            def __call__(
                self, value: typing.Optional[str], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> bool: ...
            @typing.overload
            def __call__(
                self, value: typing.Optional[typing.Any], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> bool: ...
