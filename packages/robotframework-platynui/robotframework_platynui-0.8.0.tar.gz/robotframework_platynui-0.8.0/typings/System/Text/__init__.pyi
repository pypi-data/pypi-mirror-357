# This file was generated by PythonNetStubGenerator
# mypy: ignore-errors
import typing, clr, abc
from System.Buffers import OperationStatus
from System import (
    ReadOnlySpan_1,
    Span_1,
    Range,
    Array_1,
    ArgumentException,
    Exception,
    ICloneable,
    ISpanFormattable,
    IUtf8SpanFormattable,
    IEquatable_1,
    IComparable_1,
    IComparable,
    Decimal,
    ReadOnlyMemory_1,
    IFormatProvider,
)
from System.Collections import IDictionary
from System.Reflection import MethodBase
from System.IO import Stream
from System.Collections.Generic import IEnumerable_1, IEnumerator_1
from System.Globalization import UnicodeCategory, CultureInfo
from System.Runtime.Serialization import ISerializable

class Ascii(abc.ABC):
    @staticmethod
    def FromUtf16(
        source: ReadOnlySpan_1[str], destination: Span_1[int], bytesWritten: clr.Reference[int]
    ) -> OperationStatus: ...
    @staticmethod
    def ToUtf16(
        source: ReadOnlySpan_1[int], destination: Span_1[str], charsWritten: clr.Reference[int]
    ) -> OperationStatus: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup

    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[int], right: ReadOnlySpan_1[int]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[int], right: ReadOnlySpan_1[str]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[str], right: ReadOnlySpan_1[int]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[str], right: ReadOnlySpan_1[str]) -> bool: ...

    # Skipped EqualsIgnoreCase due to it being static, abstract and generic.

    EqualsIgnoreCase: EqualsIgnoreCase_MethodGroup

    class EqualsIgnoreCase_MethodGroup:
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[int], right: ReadOnlySpan_1[int]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[int], right: ReadOnlySpan_1[str]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[str], right: ReadOnlySpan_1[int]) -> bool: ...
        @typing.overload
        def __call__(self, left: ReadOnlySpan_1[str], right: ReadOnlySpan_1[str]) -> bool: ...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid: IsValid_MethodGroup

    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: int) -> bool: ...
        @typing.overload
        def __call__(self, value: str) -> bool: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[int]) -> bool: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> bool: ...

    # Skipped ToLower due to it being static, abstract and generic.

    ToLower: ToLower_MethodGroup

    class ToLower_MethodGroup:
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[str], destination: Span_1[int], bytesWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[str], destination: Span_1[str], charsWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[int], destination: Span_1[str], charsWritten: clr.Reference[int]
        ) -> OperationStatus: ...

    # Skipped ToLowerInPlace due to it being static, abstract and generic.

    ToLowerInPlace: ToLowerInPlace_MethodGroup

    class ToLowerInPlace_MethodGroup:
        @typing.overload
        def __call__(self, value: Span_1[int], bytesWritten: clr.Reference[int]) -> OperationStatus: ...
        @typing.overload
        def __call__(self, value: Span_1[str], charsWritten: clr.Reference[int]) -> OperationStatus: ...

    # Skipped ToUpper due to it being static, abstract and generic.

    ToUpper: ToUpper_MethodGroup

    class ToUpper_MethodGroup:
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[str], destination: Span_1[int], bytesWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[str], destination: Span_1[str], charsWritten: clr.Reference[int]
        ) -> OperationStatus: ...
        @typing.overload
        def __call__(
            self, source: ReadOnlySpan_1[int], destination: Span_1[str], charsWritten: clr.Reference[int]
        ) -> OperationStatus: ...

    # Skipped ToUpperInPlace due to it being static, abstract and generic.

    ToUpperInPlace: ToUpperInPlace_MethodGroup

    class ToUpperInPlace_MethodGroup:
        @typing.overload
        def __call__(self, value: Span_1[int], bytesWritten: clr.Reference[int]) -> OperationStatus: ...
        @typing.overload
        def __call__(self, value: Span_1[str], charsWritten: clr.Reference[int]) -> OperationStatus: ...

    # Skipped Trim due to it being static, abstract and generic.

    Trim: Trim_MethodGroup

    class Trim_MethodGroup:
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[int]) -> Range: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> Range: ...

    # Skipped TrimEnd due to it being static, abstract and generic.

    TrimEnd: TrimEnd_MethodGroup

    class TrimEnd_MethodGroup:
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[int]) -> Range: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> Range: ...

    # Skipped TrimStart due to it being static, abstract and generic.

    TrimStart: TrimStart_MethodGroup

    class TrimStart_MethodGroup:
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[int]) -> Range: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> Range: ...

class ASCIIEncoding(Encoding):
    def __init__(self) -> None: ...
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    def GetMaxByteCount(self, charCount: int) -> int: ...
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetString(self, bytes: Array_1[int], byteIndex: int, byteCount: int) -> str: ...
    def TryGetBytes(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryGetChars(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str], charsWritten: clr.Reference[int]) -> bool: ...
    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str]) -> int: ...
        @typing.overload
        def __call__(self, chars: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int]) -> int: ...
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, chars: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int]) -> int: ...
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str]) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...

class CompositeFormat:
    @property
    def Format(self) -> str: ...
    @property
    def MinimumArgumentCount(self) -> int: ...
    @staticmethod
    def Parse(format: str) -> CompositeFormat: ...

class Decoder(abc.ABC):
    @property
    def Fallback(self) -> typing.Optional[DecoderFallback]: ...
    @Fallback.setter
    def Fallback(self, value: typing.Optional[DecoderFallback]) -> typing.Optional[DecoderFallback]: ...
    @property
    def FallbackBuffer(self) -> DecoderFallbackBuffer: ...
    def Reset(self) -> None: ...
    # Skipped Convert due to it being static, abstract and generic.

    Convert: Convert_MethodGroup

    class Convert_MethodGroup:
        @typing.overload
        def __call__(
            self,
            bytes: ReadOnlySpan_1[int],
            chars: Span_1[str],
            flush: bool,
            bytesUsed: clr.Reference[int],
            charsUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            bytes: clr.Reference[int],
            byteCount: int,
            chars: clr.Reference[str],
            charCount: int,
            flush: bool,
            bytesUsed: clr.Reference[int],
            charsUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            bytes: Array_1[int],
            byteIndex: int,
            byteCount: int,
            chars: Array_1[str],
            charIndex: int,
            charCount: int,
            flush: bool,
            bytesUsed: clr.Reference[int],
            charsUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int], flush: bool) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int, flush: bool) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int, flush: bool) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str], flush: bool) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int, flush: bool
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int, flush: bool
        ) -> int: ...

class DecoderExceptionFallback(DecoderFallback):
    def __init__(self) -> None: ...
    @property
    def MaxCharCount(self) -> int: ...
    def CreateFallbackBuffer(self) -> DecoderFallbackBuffer: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetHashCode(self) -> int: ...

class DecoderExceptionFallbackBuffer(DecoderFallbackBuffer):
    def __init__(self) -> None: ...
    @property
    def Remaining(self) -> int: ...
    def Fallback(self, bytesUnknown: Array_1[int], index: int) -> bool: ...
    def GetNextChar(self) -> str: ...
    def MovePrevious(self) -> bool: ...

class DecoderFallback(abc.ABC):
    @classmethod
    @property
    def ExceptionFallback(cls) -> DecoderFallback: ...
    @property
    def MaxCharCount(self) -> int: ...
    @classmethod
    @property
    def ReplacementFallback(cls) -> DecoderFallback: ...
    @abc.abstractmethod
    def CreateFallbackBuffer(self) -> DecoderFallbackBuffer: ...

class DecoderFallbackBuffer(abc.ABC):
    @property
    def Remaining(self) -> int: ...
    @abc.abstractmethod
    def Fallback(self, bytesUnknown: Array_1[int], index: int) -> bool: ...
    @abc.abstractmethod
    def GetNextChar(self) -> str: ...
    @abc.abstractmethod
    def MovePrevious(self) -> bool: ...
    def Reset(self) -> None: ...

class DecoderFallbackException(ArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: typing.Optional[str]) -> None: ...
    @typing.overload
    def __init__(
        self, message: typing.Optional[str], bytesUnknown: typing.Optional[Array_1[int]], index: int
    ) -> None: ...
    @typing.overload
    def __init__(self, message: typing.Optional[str], innerException: typing.Optional[Exception]) -> None: ...
    @property
    def BytesUnknown(self) -> typing.Optional[Array_1[int]]: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> typing.Optional[str]: ...
    @HelpLink.setter
    def HelpLink(self, value: typing.Optional[str]) -> typing.Optional[str]: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def InnerException(self) -> typing.Optional[Exception]: ...
    @property
    def Message(self) -> str: ...
    @property
    def ParamName(self) -> typing.Optional[str]: ...
    @property
    def Source(self) -> typing.Optional[str]: ...
    @Source.setter
    def Source(self, value: typing.Optional[str]) -> typing.Optional[str]: ...
    @property
    def StackTrace(self) -> typing.Optional[str]: ...
    @property
    def TargetSite(self) -> typing.Optional[MethodBase]: ...

class DecoderReplacementFallback(DecoderFallback):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, replacement: str) -> None: ...
    @property
    def DefaultString(self) -> str: ...
    @property
    def MaxCharCount(self) -> int: ...
    def CreateFallbackBuffer(self) -> DecoderFallbackBuffer: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetHashCode(self) -> int: ...

class DecoderReplacementFallbackBuffer(DecoderFallbackBuffer):
    def __init__(self, fallback: DecoderReplacementFallback) -> None: ...
    @property
    def Remaining(self) -> int: ...
    def Fallback(self, bytesUnknown: Array_1[int], index: int) -> bool: ...
    def GetNextChar(self) -> str: ...
    def MovePrevious(self) -> bool: ...
    def Reset(self) -> None: ...

class Encoder(abc.ABC):
    @property
    def Fallback(self) -> typing.Optional[EncoderFallback]: ...
    @Fallback.setter
    def Fallback(self, value: typing.Optional[EncoderFallback]) -> typing.Optional[EncoderFallback]: ...
    @property
    def FallbackBuffer(self) -> EncoderFallbackBuffer: ...
    def Reset(self) -> None: ...
    # Skipped Convert due to it being static, abstract and generic.

    Convert: Convert_MethodGroup

    class Convert_MethodGroup:
        @typing.overload
        def __call__(
            self,
            chars: ReadOnlySpan_1[str],
            bytes: Span_1[int],
            flush: bool,
            charsUsed: clr.Reference[int],
            bytesUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            chars: clr.Reference[str],
            charCount: int,
            bytes: clr.Reference[int],
            byteCount: int,
            flush: bool,
            charsUsed: clr.Reference[int],
            bytesUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...
        @typing.overload
        def __call__(
            self,
            chars: Array_1[str],
            charIndex: int,
            charCount: int,
            bytes: Array_1[int],
            byteIndex: int,
            byteCount: int,
            flush: bool,
            charsUsed: clr.Reference[int],
            bytesUsed: clr.Reference[int],
            completed: clr.Reference[bool],
        ) -> None: ...

    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str], flush: bool) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int, flush: bool) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int, flush: bool) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int], flush: bool) -> int: ...
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int, flush: bool
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int, flush: bool
        ) -> int: ...

class EncoderExceptionFallback(EncoderFallback):
    def __init__(self) -> None: ...
    @property
    def MaxCharCount(self) -> int: ...
    def CreateFallbackBuffer(self) -> EncoderFallbackBuffer: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetHashCode(self) -> int: ...

class EncoderExceptionFallbackBuffer(EncoderFallbackBuffer):
    def __init__(self) -> None: ...
    @property
    def Remaining(self) -> int: ...
    def GetNextChar(self) -> str: ...
    def MovePrevious(self) -> bool: ...
    # Skipped Fallback due to it being static, abstract and generic.

    Fallback: Fallback_MethodGroup

    class Fallback_MethodGroup:
        @typing.overload
        def __call__(self, charUnknown: str, index: int) -> bool: ...
        @typing.overload
        def __call__(self, charUnknownHigh: str, charUnknownLow: str, index: int) -> bool: ...

class EncoderFallback(abc.ABC):
    @classmethod
    @property
    def ExceptionFallback(cls) -> EncoderFallback: ...
    @property
    def MaxCharCount(self) -> int: ...
    @classmethod
    @property
    def ReplacementFallback(cls) -> EncoderFallback: ...
    @abc.abstractmethod
    def CreateFallbackBuffer(self) -> EncoderFallbackBuffer: ...

class EncoderFallbackBuffer(abc.ABC):
    @property
    def Remaining(self) -> int: ...
    @abc.abstractmethod
    def GetNextChar(self) -> str: ...
    @abc.abstractmethod
    def MovePrevious(self) -> bool: ...
    def Reset(self) -> None: ...
    # Skipped Fallback due to it being static, abstract and generic.

    Fallback: Fallback_MethodGroup

    class Fallback_MethodGroup:
        @typing.overload
        def __call__(self, charUnknown: str, index: int) -> bool: ...
        @typing.overload
        def __call__(self, charUnknownHigh: str, charUnknownLow: str, index: int) -> bool: ...

class EncoderFallbackException(ArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: typing.Optional[str]) -> None: ...
    @typing.overload
    def __init__(self, message: typing.Optional[str], innerException: typing.Optional[Exception]) -> None: ...
    @property
    def CharUnknown(self) -> str: ...
    @property
    def CharUnknownHigh(self) -> str: ...
    @property
    def CharUnknownLow(self) -> str: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> typing.Optional[str]: ...
    @HelpLink.setter
    def HelpLink(self, value: typing.Optional[str]) -> typing.Optional[str]: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def InnerException(self) -> typing.Optional[Exception]: ...
    @property
    def Message(self) -> str: ...
    @property
    def ParamName(self) -> typing.Optional[str]: ...
    @property
    def Source(self) -> typing.Optional[str]: ...
    @Source.setter
    def Source(self, value: typing.Optional[str]) -> typing.Optional[str]: ...
    @property
    def StackTrace(self) -> typing.Optional[str]: ...
    @property
    def TargetSite(self) -> typing.Optional[MethodBase]: ...
    def IsUnknownSurrogate(self) -> bool: ...

class EncoderReplacementFallback(EncoderFallback):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, replacement: str) -> None: ...
    @property
    def DefaultString(self) -> str: ...
    @property
    def MaxCharCount(self) -> int: ...
    def CreateFallbackBuffer(self) -> EncoderFallbackBuffer: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetHashCode(self) -> int: ...

class EncoderReplacementFallbackBuffer(EncoderFallbackBuffer):
    def __init__(self, fallback: EncoderReplacementFallback) -> None: ...
    @property
    def Remaining(self) -> int: ...
    def GetNextChar(self) -> str: ...
    def MovePrevious(self) -> bool: ...
    def Reset(self) -> None: ...
    # Skipped Fallback due to it being static, abstract and generic.

    Fallback: Fallback_MethodGroup

    class Fallback_MethodGroup:
        @typing.overload
        def __call__(self, charUnknown: str, index: int) -> bool: ...
        @typing.overload
        def __call__(self, charUnknownHigh: str, charUnknownLow: str, index: int) -> bool: ...

class Encoding(ICloneable, abc.ABC):
    @classmethod
    @property
    def ASCII(cls) -> Encoding: ...
    @classmethod
    @property
    def BigEndianUnicode(cls) -> Encoding: ...
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @classmethod
    @property
    def Default(cls) -> Encoding: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @classmethod
    @property
    def Latin1(cls) -> Encoding: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def Unicode(cls) -> Encoding: ...
    @classmethod
    @property
    def UTF32(cls) -> Encoding: ...
    @classmethod
    @property
    def UTF7(cls) -> Encoding: ...
    @classmethod
    @property
    def UTF8(cls) -> Encoding: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def Clone(self) -> typing.Any: ...
    @staticmethod
    def CreateTranscodingStream(
        innerStream: Stream, innerStreamEncoding: Encoding, outerStreamEncoding: Encoding, leaveOpen: bool = ...
    ) -> Stream: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    @staticmethod
    def GetEncodings() -> Array_1[EncodingInfo]: ...
    def GetHashCode(self) -> int: ...
    @abc.abstractmethod
    def GetMaxByteCount(self, charCount: int) -> int: ...
    @abc.abstractmethod
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetPreamble(self) -> Array_1[int]: ...
    @staticmethod
    def RegisterProvider(provider: EncodingProvider) -> None: ...
    def TryGetBytes(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryGetChars(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str], charsWritten: clr.Reference[int]) -> bool: ...
    # Skipped Convert due to it being static, abstract and generic.

    Convert: Convert_MethodGroup

    class Convert_MethodGroup:
        @typing.overload
        def __call__(self, srcEncoding: Encoding, dstEncoding: Encoding, bytes: Array_1[int]) -> Array_1[int]: ...
        @typing.overload
        def __call__(
            self, srcEncoding: Encoding, dstEncoding: Encoding, bytes: Array_1[int], index: int, count: int
        ) -> Array_1[int]: ...

    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, chars: Array_1[str]) -> int: ...
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str]) -> int: ...
        @typing.overload
        def __call__(self, s: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...
        @typing.overload
        def __call__(self, s: str, index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, chars: Array_1[str]) -> Array_1[int]: ...
        @typing.overload
        def __call__(self, s: str) -> Array_1[int]: ...
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int]) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> Array_1[int]: ...
        @typing.overload
        def __call__(self, s: str, index: int, count: int) -> Array_1[int]: ...
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, s: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: Array_1[int]) -> int: ...
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int]) -> int: ...
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(self, bytes: Array_1[int]) -> Array_1[str]: ...
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str]) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> Array_1[str]: ...
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...

    # Skipped GetEncoding due to it being static, abstract and generic.

    GetEncoding: GetEncoding_MethodGroup

    class GetEncoding_MethodGroup:
        @typing.overload
        def __call__(self, codepage: int) -> Encoding: ...
        @typing.overload
        def __call__(self, name: str) -> Encoding: ...
        @typing.overload
        def __call__(
            self, codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback
        ) -> Encoding: ...
        @typing.overload
        def __call__(
            self, name: str, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback
        ) -> Encoding: ...

    # Skipped GetString due to it being static, abstract and generic.

    GetString: GetString_MethodGroup

    class GetString_MethodGroup:
        @typing.overload
        def __call__(self, bytes: Array_1[int]) -> str: ...
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int]) -> str: ...
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], byteCount: int) -> str: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> str: ...

    # Skipped IsAlwaysNormalized due to it being static, abstract and generic.

    IsAlwaysNormalized: IsAlwaysNormalized_MethodGroup

    class IsAlwaysNormalized_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, form: NormalizationForm) -> bool: ...

class EncodingInfo:
    def __init__(self, provider: EncodingProvider, codePage: int, name: str, displayName: str) -> None: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def Name(self) -> str: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetEncoding(self) -> Encoding: ...
    def GetHashCode(self) -> int: ...

class EncodingProvider(abc.ABC):
    def __init__(self) -> None: ...
    def GetEncodings(self) -> IEnumerable_1[EncodingInfo]: ...
    # Skipped GetEncoding due to it being static, abstract and generic.

    GetEncoding: GetEncoding_MethodGroup

    class GetEncoding_MethodGroup:
        @typing.overload
        def __call__(self, codepage: int) -> Encoding: ...
        @typing.overload
        def __call__(self, name: str) -> Encoding: ...
        @typing.overload
        def __call__(
            self, codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback
        ) -> Encoding: ...
        @typing.overload
        def __call__(
            self, name: str, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback
        ) -> Encoding: ...

class NormalizationForm(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    FormC: NormalizationForm  # 1
    FormD: NormalizationForm  # 2
    FormKC: NormalizationForm  # 5
    FormKD: NormalizationForm  # 6

class Rune(ISpanFormattable, IUtf8SpanFormattable, IEquatable_1[Rune], IComparable_1[Rune], IComparable_0):
    # Constructor .ctor(value : UInt32) was skipped since it collides with above method
    @typing.overload
    def __init__(self, ch: str) -> None: ...
    @typing.overload
    def __init__(self, highSurrogate: str, lowSurrogate: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def IsAscii(self) -> bool: ...
    @property
    def IsBmp(self) -> bool: ...
    @property
    def Plane(self) -> int: ...
    @classmethod
    @property
    def ReplacementChar(cls) -> Rune: ...
    @property
    def Utf16SequenceLength(self) -> int: ...
    @property
    def Utf8SequenceLength(self) -> int: ...
    @property
    def Value(self) -> int: ...
    def CompareTo(self, other: Rune) -> int: ...
    @staticmethod
    def DecodeFromUtf16(
        source: ReadOnlySpan_1[str], result: clr.Reference[Rune], charsConsumed: clr.Reference[int]
    ) -> OperationStatus: ...
    @staticmethod
    def DecodeFromUtf8(
        source: ReadOnlySpan_1[int], result: clr.Reference[Rune], bytesConsumed: clr.Reference[int]
    ) -> OperationStatus: ...
    @staticmethod
    def DecodeLastFromUtf16(
        source: ReadOnlySpan_1[str], result: clr.Reference[Rune], charsConsumed: clr.Reference[int]
    ) -> OperationStatus: ...
    @staticmethod
    def DecodeLastFromUtf8(
        source: ReadOnlySpan_1[int], value: clr.Reference[Rune], bytesConsumed: clr.Reference[int]
    ) -> OperationStatus: ...
    def EncodeToUtf16(self, destination: Span_1[str]) -> int: ...
    def EncodeToUtf8(self, destination: Span_1[int]) -> int: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def GetNumericValue(value: Rune) -> float: ...
    @staticmethod
    def GetRuneAt(input: str, index: int) -> Rune: ...
    @staticmethod
    def GetUnicodeCategory(value: Rune) -> UnicodeCategory: ...
    @staticmethod
    def IsControl(value: Rune) -> bool: ...
    @staticmethod
    def IsDigit(value: Rune) -> bool: ...
    @staticmethod
    def IsLetter(value: Rune) -> bool: ...
    @staticmethod
    def IsLetterOrDigit(value: Rune) -> bool: ...
    @staticmethod
    def IsLower(value: Rune) -> bool: ...
    @staticmethod
    def IsNumber(value: Rune) -> bool: ...
    @staticmethod
    def IsPunctuation(value: Rune) -> bool: ...
    @staticmethod
    def IsSeparator(value: Rune) -> bool: ...
    @staticmethod
    def IsSymbol(value: Rune) -> bool: ...
    @staticmethod
    def IsUpper(value: Rune) -> bool: ...
    @staticmethod
    def IsWhiteSpace(value: Rune) -> bool: ...
    def __eq__(self, left: Rune, right: Rune) -> bool: ...
    # Operator not supported op_Explicit(ch: Char)
    # Operator not supported op_Explicit(value: UInt32)
    # Operator not supported op_Explicit(value: Int32)
    def __gt__(self, left: Rune, right: Rune) -> bool: ...
    def __ge__(self, left: Rune, right: Rune) -> bool: ...
    def __ne__(self, left: Rune, right: Rune) -> bool: ...
    def __lt__(self, left: Rune, right: Rune) -> bool: ...
    def __le__(self, left: Rune, right: Rune) -> bool: ...
    @staticmethod
    def ToLower(value: Rune, culture: CultureInfo) -> Rune: ...
    @staticmethod
    def ToLowerInvariant(value: Rune) -> Rune: ...
    def ToString(self) -> str: ...
    @staticmethod
    def ToUpper(value: Rune, culture: CultureInfo) -> Rune: ...
    @staticmethod
    def ToUpperInvariant(value: Rune) -> Rune: ...
    def TryEncodeToUtf16(self, destination: Span_1[str], charsWritten: clr.Reference[int]) -> bool: ...
    def TryEncodeToUtf8(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    @staticmethod
    def TryGetRuneAt(input: str, index: int, value: clr.Reference[Rune]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup

    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Rune) -> bool: ...
        @typing.overload
        def __call__(self, obj: typing.Optional[typing.Any]) -> bool: ...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid: IsValid_MethodGroup

    class IsValid_MethodGroup:
        def __call__(self, value: int) -> bool: ...
        # Method IsValid(value : UInt32) was skipped since it collides with above method

    # Skipped TryCreate due to it being static, abstract and generic.

    TryCreate: TryCreate_MethodGroup

    class TryCreate_MethodGroup:
        @typing.overload
        def __call__(self, ch: str, result: clr.Reference[Rune]) -> bool: ...
        @typing.overload
        def __call__(self, value: int, result: clr.Reference[Rune]) -> bool: ...
        # Method TryCreate(value : UInt32, result : Rune&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, highSurrogate: str, lowSurrogate: str, result: clr.Reference[Rune]) -> bool: ...

class SpanLineEnumerator:
    @property
    def Current(self) -> ReadOnlySpan_1[str]: ...
    def GetEnumerator(self) -> SpanLineEnumerator: ...
    def MoveNext(self) -> bool: ...

class SpanRuneEnumerator:
    @property
    def Current(self) -> Rune: ...
    def GetEnumerator(self) -> SpanRuneEnumerator: ...
    def MoveNext(self) -> bool: ...

class StringBuilder(ISerializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int) -> None: ...
    @typing.overload
    def __init__(self, capacity: int, maxCapacity: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Optional[str]) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Optional[str], capacity: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Optional[str], startIndex: int, length: int, capacity: int) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Chars(self) -> str: ...
    @Chars.setter
    def Chars(self, value: str) -> str: ...
    @property
    def Length(self) -> int: ...
    @Length.setter
    def Length(self, value: int) -> int: ...
    @property
    def MaxCapacity(self) -> int: ...
    def Clear(self) -> StringBuilder: ...
    def EnsureCapacity(self, capacity: int) -> int: ...
    def GetChunks(self) -> StringBuilder.ChunkEnumerator: ...
    def Remove(self, startIndex: int, length: int) -> StringBuilder: ...
    # Skipped Append due to it being static, abstract and generic.

    Append: Append_MethodGroup

    class Append_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> StringBuilder: ...
        # Method Append(value : Double) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: str) -> StringBuilder: ...
        # Method Append(value : SByte) was skipped since it collides with above method
        # Method Append(value : Byte) was skipped since it collides with above method
        # Method Append(value : Int16) was skipped since it collides with above method
        # Method Append(value : Int32) was skipped since it collides with above method
        # Method Append(value : Int64) was skipped since it collides with above method
        # Method Append(value : UInt16) was skipped since it collides with above method
        # Method Append(value : UInt32) was skipped since it collides with above method
        # Method Append(value : UInt64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: Decimal) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[Array_1[str]]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: ReadOnlySpan_1[str]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: ReadOnlyMemory_1[str]) -> StringBuilder: ...
        # Method Append(value : String) was skipped since it collides with above method
        # Method Append(value : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: typing.Optional[StringBuilder]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, handler: clr.Reference[StringBuilder.AppendInterpolatedStringHandler]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[typing.Any]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: str, repeatCount: int) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: clr.Reference[str], valueCount: int) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self,
            provider: typing.Optional[IFormatProvider],
            handler: clr.Reference[StringBuilder.AppendInterpolatedStringHandler],
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[Array_1[str]], startIndex: int, charCount: int) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[str], startIndex: int, count: int) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[StringBuilder], startIndex: int, count: int) -> StringBuilder: ...

    # Skipped AppendFormat due to it being static, abstract and generic.

    AppendFormat: AppendFormat_MethodGroup

    class AppendFormat_MethodGroup:
        @typing.overload
        def __getitem__(self, t: typing.Type[AppendFormat_1_T1]) -> AppendFormat_1[AppendFormat_1_T1]: ...

        AppendFormat_1_T1 = typing.TypeVar("AppendFormat_1_T1")

        class AppendFormat_1(typing.Generic[AppendFormat_1_T1]):
            AppendFormat_1_TArg0 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_1_T1
            def __call__(
                self,
                provider: typing.Optional[IFormatProvider],
                format: CompositeFormat,
                arg0: typing.Optional[AppendFormat_1_TArg0],
            ) -> StringBuilder: ...

        @typing.overload
        def __getitem__(
            self, t: typing.Tuple[typing.Type[AppendFormat_2_T1], typing.Type[AppendFormat_2_T2]]
        ) -> AppendFormat_2[AppendFormat_2_T1, AppendFormat_2_T2]: ...

        AppendFormat_2_T1 = typing.TypeVar("AppendFormat_2_T1")
        AppendFormat_2_T2 = typing.TypeVar("AppendFormat_2_T2")

        class AppendFormat_2(typing.Generic[AppendFormat_2_T1, AppendFormat_2_T2]):
            AppendFormat_2_TArg0 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_2_T1
            AppendFormat_2_TArg1 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_2_T2
            def __call__(
                self,
                provider: typing.Optional[IFormatProvider],
                format: CompositeFormat,
                arg0: typing.Optional[AppendFormat_2_TArg0],
                arg1: typing.Optional[AppendFormat_2_TArg1],
            ) -> StringBuilder: ...

        @typing.overload
        def __getitem__(
            self,
            t: typing.Tuple[
                typing.Type[AppendFormat_3_T1], typing.Type[AppendFormat_3_T2], typing.Type[AppendFormat_3_T3]
            ],
        ) -> AppendFormat_3[AppendFormat_3_T1, AppendFormat_3_T2, AppendFormat_3_T3]: ...

        AppendFormat_3_T1 = typing.TypeVar("AppendFormat_3_T1")
        AppendFormat_3_T2 = typing.TypeVar("AppendFormat_3_T2")
        AppendFormat_3_T3 = typing.TypeVar("AppendFormat_3_T3")

        class AppendFormat_3(typing.Generic[AppendFormat_3_T1, AppendFormat_3_T2, AppendFormat_3_T3]):
            AppendFormat_3_TArg0 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_3_T1
            AppendFormat_3_TArg1 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_3_T2
            AppendFormat_3_TArg2 = StringBuilder.AppendFormat_MethodGroup.AppendFormat_3_T3
            def __call__(
                self,
                provider: typing.Optional[IFormatProvider],
                format: CompositeFormat,
                arg0: typing.Optional[AppendFormat_3_TArg0],
                arg1: typing.Optional[AppendFormat_3_TArg1],
                arg2: typing.Optional[AppendFormat_3_TArg2],
            ) -> StringBuilder: ...

        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, format: str, arg0: typing.Optional[typing.Any]) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, format: str, arg0: typing.Optional[typing.Any], arg1: typing.Optional[typing.Any]
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, provider: typing.Optional[IFormatProvider], format: str, args: Array_1[typing.Any]
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, provider: typing.Optional[IFormatProvider], format: str, arg0: typing.Optional[typing.Any]
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, provider: typing.Optional[IFormatProvider], format: CompositeFormat, args: Array_1[typing.Any]
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, provider: typing.Optional[IFormatProvider], format: CompositeFormat, args: ReadOnlySpan_1[typing.Any]
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self,
            format: str,
            arg0: typing.Optional[typing.Any],
            arg1: typing.Optional[typing.Any],
            arg2: typing.Optional[typing.Any],
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self,
            provider: typing.Optional[IFormatProvider],
            format: str,
            arg0: typing.Optional[typing.Any],
            arg1: typing.Optional[typing.Any],
        ) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self,
            provider: typing.Optional[IFormatProvider],
            format: str,
            arg0: typing.Optional[typing.Any],
            arg1: typing.Optional[typing.Any],
            arg2: typing.Optional[typing.Any],
        ) -> StringBuilder: ...

    # Skipped AppendJoin due to it being static, abstract and generic.

    AppendJoin: AppendJoin_MethodGroup

    class AppendJoin_MethodGroup:
        def __getitem__(self, t: typing.Type[AppendJoin_1_T1]) -> AppendJoin_1[AppendJoin_1_T1]: ...

        AppendJoin_1_T1 = typing.TypeVar("AppendJoin_1_T1")

        class AppendJoin_1(typing.Generic[AppendJoin_1_T1]):
            AppendJoin_1_T = StringBuilder.AppendJoin_MethodGroup.AppendJoin_1_T1
            def __call__(
                self, separator: typing.Optional[str], values: IEnumerable_1[AppendJoin_1_T]
            ) -> StringBuilder: ...
            # Method AppendJoin(separator : Char, values : IEnumerable`1) was skipped since it collides with above method

        @typing.overload
        def __call__(self, separator: typing.Optional[str], values: Array_1[str]) -> StringBuilder: ...
        # Method AppendJoin(separator : Char, values : String[]) was skipped since it collides with above method
        @typing.overload
        def __call__(self, separator: typing.Optional[str], values: Array_1[typing.Any]) -> StringBuilder: ...
        # Method AppendJoin(separator : Char, values : Object[]) was skipped since it collides with above method

    # Skipped AppendLine due to it being static, abstract and generic.

    AppendLine: AppendLine_MethodGroup

    class AppendLine_MethodGroup:
        @typing.overload
        def __call__(self) -> StringBuilder: ...
        @typing.overload
        def __call__(self, value: typing.Optional[str]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, handler: clr.Reference[StringBuilder.AppendInterpolatedStringHandler]) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self,
            provider: typing.Optional[IFormatProvider],
            handler: clr.Reference[StringBuilder.AppendInterpolatedStringHandler],
        ) -> StringBuilder: ...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo: CopyTo_MethodGroup

    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, sourceIndex: int, destination: Span_1[str], count: int) -> None: ...
        @typing.overload
        def __call__(self, sourceIndex: int, destination: Array_1[str], destinationIndex: int, count: int) -> None: ...

    # Skipped Equals due to it being static, abstract and generic.

    Equals: Equals_MethodGroup

    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, span: ReadOnlySpan_1[str]) -> bool: ...
        @typing.overload
        def __call__(self, sb: typing.Optional[StringBuilder]) -> bool: ...

    # Skipped Insert due to it being static, abstract and generic.

    Insert: Insert_MethodGroup

    class Insert_MethodGroup:
        @typing.overload
        def __call__(self, index: int, value: float) -> StringBuilder: ...
        # Method Insert(index : Int32, value : Double) was skipped since it collides with above method
        # Method Insert(index : Int32, value : SByte) was skipped since it collides with above method
        # Method Insert(index : Int32, value : Byte) was skipped since it collides with above method
        # Method Insert(index : Int32, value : Int16) was skipped since it collides with above method
        @typing.overload
        def __call__(self, index: int, value: str) -> StringBuilder: ...
        # Method Insert(index : Int32, value : Int32) was skipped since it collides with above method
        # Method Insert(index : Int32, value : Int64) was skipped since it collides with above method
        # Method Insert(index : Int32, value : UInt16) was skipped since it collides with above method
        # Method Insert(index : Int32, value : UInt32) was skipped since it collides with above method
        # Method Insert(index : Int32, value : UInt64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, index: int, value: Decimal) -> StringBuilder: ...
        @typing.overload
        def __call__(self, index: int, value: typing.Optional[Array_1[str]]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, index: int, value: ReadOnlySpan_1[str]) -> StringBuilder: ...
        # Method Insert(index : Int32, value : String) was skipped since it collides with above method
        # Method Insert(index : Int32, value : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, index: int, value: typing.Optional[typing.Any]) -> StringBuilder: ...
        @typing.overload
        def __call__(self, index: int, value: typing.Optional[str], count: int) -> StringBuilder: ...
        @typing.overload
        def __call__(
            self, index: int, value: typing.Optional[Array_1[str]], startIndex: int, charCount: int
        ) -> StringBuilder: ...

    # Skipped Replace due to it being static, abstract and generic.

    Replace: Replace_MethodGroup

    class Replace_MethodGroup:
        @typing.overload
        def __call__(self, oldChar: str, newChar: str) -> StringBuilder: ...
        # Method Replace(oldValue : String, newValue : String) was skipped since it collides with above method
        @typing.overload
        def __call__(self, oldChar: str, newChar: str, startIndex: int, count: int) -> StringBuilder: ...
        # Method Replace(oldValue : String, newValue : String, startIndex : Int32, count : Int32) was skipped since it collides with above method

    # Skipped ToString due to it being static, abstract and generic.

    ToString: ToString_MethodGroup

    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str: ...
        @typing.overload
        def __call__(self, startIndex: int, length: int) -> str: ...

    class AppendInterpolatedStringHandler:
        @typing.overload
        def __init__(self, literalLength: int, formattedCount: int, stringBuilder: StringBuilder) -> None: ...
        @typing.overload
        def __init__(
            self,
            literalLength: int,
            formattedCount: int,
            stringBuilder: StringBuilder,
            provider: typing.Optional[IFormatProvider],
        ) -> None: ...
        def AppendLiteral(self, value: str) -> None: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted: AppendFormatted_MethodGroup

        class AppendFormatted_MethodGroup:
            def __getitem__(self, t: typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar("AppendFormatted_1_T1")

            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = (
                    StringBuilder.AppendInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                )
                @typing.overload
                def __call__(self, value: typing.Optional[AppendFormatted_1_T]) -> None: ...
                @typing.overload
                def __call__(self, value: typing.Optional[AppendFormatted_1_T], alignment: int) -> None: ...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: typing.Optional[str]) -> None: ...
                @typing.overload
                def __call__(
                    self, value: AppendFormatted_1_T, alignment: int, format: typing.Optional[str]
                ) -> None: ...

            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> None: ...
            @typing.overload
            def __call__(self, value: typing.Optional[str]) -> None: ...
            @typing.overload
            def __call__(
                self, value: ReadOnlySpan_1[str], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> None: ...
            @typing.overload
            def __call__(
                self, value: typing.Optional[str], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> None: ...
            @typing.overload
            def __call__(
                self, value: typing.Optional[typing.Any], alignment: int = ..., format: typing.Optional[str] = ...
            ) -> None: ...

    class ChunkEnumerator:
        @property
        def Current(self) -> ReadOnlyMemory_1[str]: ...
        def GetEnumerator(self) -> StringBuilder.ChunkEnumerator: ...
        def MoveNext(self) -> bool: ...

class StringRuneEnumerator(IEnumerator_1[Rune], IEnumerable_1[Rune]):
    @property
    def Current(self) -> Rune: ...
    def GetEnumerator(self) -> StringRuneEnumerator: ...
    def MoveNext(self) -> bool: ...

class UnicodeEncoding(Encoding):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bigEndian: bool, byteOrderMark: bool) -> None: ...
    @typing.overload
    def __init__(self, bigEndian: bool, byteOrderMark: bool, throwOnInvalidBytes: bool) -> None: ...
    CharSize: int
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    def GetHashCode(self) -> int: ...
    def GetMaxByteCount(self, charCount: int) -> int: ...
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetPreamble(self) -> Array_1[int]: ...
    def GetString(self, bytes: Array_1[int], index: int, count: int) -> str: ...
    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, s: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...

class UTF32Encoding(Encoding):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, bigEndian: bool, byteOrderMark: bool) -> None: ...
    @typing.overload
    def __init__(self, bigEndian: bool, byteOrderMark: bool, throwOnInvalidCharacters: bool) -> None: ...
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    def GetHashCode(self) -> int: ...
    def GetMaxByteCount(self, charCount: int) -> int: ...
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetPreamble(self) -> Array_1[int]: ...
    def GetString(self, bytes: Array_1[int], index: int, count: int) -> str: ...
    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, s: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...

class UTF7Encoding(Encoding):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, allowOptionals: bool) -> None: ...
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    def GetHashCode(self) -> int: ...
    def GetMaxByteCount(self, charCount: int) -> int: ...
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetString(self, bytes: Array_1[int], index: int, count: int) -> str: ...
    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, s: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, s: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...

class UTF8Encoding(Encoding):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, encoderShouldEmitUTF8Identifier: bool) -> None: ...
    @typing.overload
    def __init__(self, encoderShouldEmitUTF8Identifier: bool, throwOnInvalidBytes: bool) -> None: ...
    @property
    def BodyName(self) -> str: ...
    @property
    def CodePage(self) -> int: ...
    @property
    def DecoderFallback(self) -> DecoderFallback: ...
    @DecoderFallback.setter
    def DecoderFallback(self, value: DecoderFallback) -> DecoderFallback: ...
    @property
    def EncoderFallback(self) -> EncoderFallback: ...
    @EncoderFallback.setter
    def EncoderFallback(self, value: EncoderFallback) -> EncoderFallback: ...
    @property
    def EncodingName(self) -> str: ...
    @property
    def HeaderName(self) -> str: ...
    @property
    def IsBrowserDisplay(self) -> bool: ...
    @property
    def IsBrowserSave(self) -> bool: ...
    @property
    def IsMailNewsDisplay(self) -> bool: ...
    @property
    def IsMailNewsSave(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: bool) -> bool: ...
    @property
    def IsSingleByte(self) -> bool: ...
    @property
    def Preamble(self) -> ReadOnlySpan_1[int]: ...
    @property
    def WebName(self) -> str: ...
    @property
    def WindowsCodePage(self) -> int: ...
    def Equals(self, value: typing.Optional[typing.Any]) -> bool: ...
    def GetDecoder(self) -> Decoder: ...
    def GetEncoder(self) -> Encoder: ...
    def GetHashCode(self) -> int: ...
    def GetMaxByteCount(self, charCount: int) -> int: ...
    def GetMaxCharCount(self, byteCount: int) -> int: ...
    def GetPreamble(self) -> Array_1[int]: ...
    def GetString(self, bytes: Array_1[int], index: int, count: int) -> str: ...
    def TryGetBytes(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryGetChars(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str], charsWritten: clr.Reference[int]) -> bool: ...
    # Skipped GetByteCount due to it being static, abstract and generic.

    GetByteCount: GetByteCount_MethodGroup

    class GetByteCount_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str]) -> int: ...
        @typing.overload
        def __call__(self, chars: str) -> int: ...
        @typing.overload
        def __call__(self, chars: clr.Reference[str], count: int) -> int: ...
        @typing.overload
        def __call__(self, chars: Array_1[str], index: int, count: int) -> int: ...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes: GetBytes_MethodGroup

    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, chars: ReadOnlySpan_1[str], bytes: Span_1[int]) -> int: ...
        @typing.overload
        def __call__(
            self, chars: clr.Reference[str], charCount: int, bytes: clr.Reference[int], byteCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, chars: Array_1[str], charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int
        ) -> int: ...
        @typing.overload
        def __call__(self, s: str, charIndex: int, charCount: int, bytes: Array_1[int], byteIndex: int) -> int: ...

    # Skipped GetCharCount due to it being static, abstract and generic.

    GetCharCount: GetCharCount_MethodGroup

    class GetCharCount_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int]) -> int: ...
        @typing.overload
        def __call__(self, bytes: clr.Reference[int], count: int) -> int: ...
        @typing.overload
        def __call__(self, bytes: Array_1[int], index: int, count: int) -> int: ...

    # Skipped GetChars due to it being static, abstract and generic.

    GetChars: GetChars_MethodGroup

    class GetChars_MethodGroup:
        @typing.overload
        def __call__(self, bytes: ReadOnlySpan_1[int], chars: Span_1[str]) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: clr.Reference[int], byteCount: int, chars: clr.Reference[str], charCount: int
        ) -> int: ...
        @typing.overload
        def __call__(
            self, bytes: Array_1[int], byteIndex: int, byteCount: int, chars: Array_1[str], charIndex: int
        ) -> int: ...
