# This file was generated by PythonNetStubGenerator
# mypy: ignore-errors
import typing, abc
from System.Collections.Generic import IDictionary_2
from System.Collections import IEnumerable, IEnumerator
from System import Array_1, IDisposable, DateTime, DateTimeOffset, Decimal, Uri, IAsyncDisposable
from System.Text import Encoding, StringBuilder
from System.Xml.Schema import IXmlSchemaInfo, XmlSchemaSet, XmlSchemaValidationFlags
from System.Threading.Tasks import Task_1, Task, ValueTask
from System.IO import Stream, TextReader, TextWriter
from System.Net import ICredentials
from System.Xml.XPath import XPathNavigator

class ConformanceLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Auto: ConformanceLevel  # 0
    Fragment: ConformanceLevel  # 1
    Document: ConformanceLevel  # 2

class DtdProcessing(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Prohibit: DtdProcessing  # 0
    Ignore: DtdProcessing  # 1
    Parse: DtdProcessing  # 2

class IXmlNamespaceResolver(typing.Protocol):
    @abc.abstractmethod
    def GetNamespacesInScope(self, scope: XmlNamespaceScope) -> IDictionary_2[str, str]: ...
    @abc.abstractmethod
    def LookupNamespace(self, prefix: str) -> typing.Optional[str]: ...
    @abc.abstractmethod
    def LookupPrefix(self, namespaceName: str) -> typing.Optional[str]: ...

class NamespaceHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Default: NamespaceHandling  # 0
    OmitDuplicates: NamespaceHandling  # 1

class NewLineHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Replace: NewLineHandling  # 0
    Entitize: NewLineHandling  # 1
    None_: NewLineHandling  # 2

class ReadState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Initial: ReadState  # 0
    Interactive: ReadState  # 1
    Error: ReadState  # 2
    EndOfFile: ReadState  # 3
    Closed: ReadState  # 4

class ValidationType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: ValidationType  # 0
    Auto: ValidationType  # 1
    DTD: ValidationType  # 2
    XDR: ValidationType  # 3
    Schema: ValidationType  # 4

class WriteState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Start: WriteState  # 0
    Prolog: WriteState  # 1
    Element: WriteState  # 2
    Attribute: WriteState  # 3
    Content: WriteState  # 4
    Closed: WriteState  # 5
    Error: WriteState  # 6

class XmlNamespaceManager(IEnumerable, IXmlNamespaceResolver):
    def __init__(self, nameTable: XmlNameTable) -> None: ...
    @property
    def DefaultNamespace(self) -> str: ...
    @property
    def NameTable(self) -> typing.Optional[XmlNameTable]: ...
    def AddNamespace(self, prefix: str, uri: str) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetNamespacesInScope(self, scope: XmlNamespaceScope) -> IDictionary_2[str, str]: ...
    def HasNamespace(self, prefix: str) -> bool: ...
    def LookupNamespace(self, prefix: str) -> typing.Optional[str]: ...
    def LookupPrefix(self, uri: str) -> typing.Optional[str]: ...
    def PopScope(self) -> bool: ...
    def PushScope(self) -> None: ...
    def RemoveNamespace(self, prefix: str, uri: str) -> None: ...

class XmlNamespaceScope(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    All: XmlNamespaceScope  # 0
    ExcludeXml: XmlNamespaceScope  # 1
    Local: XmlNamespaceScope  # 2

class XmlNameTable(abc.ABC):
    # Skipped Add due to it being static, abstract and generic.

    Add: Add_MethodGroup

    class Add_MethodGroup:
        @typing.overload
        def __call__(self, array: str) -> str: ...
        @typing.overload
        def __call__(self, array: Array_1[str], offset: int, length: int) -> str: ...

    # Skipped Get due to it being static, abstract and generic.

    Get: Get_MethodGroup

    class Get_MethodGroup:
        @typing.overload
        def __call__(self, array: str) -> str: ...
        @typing.overload
        def __call__(self, array: Array_1[str], offset: int, length: int) -> str: ...

class XmlNodeOrder(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Before: XmlNodeOrder  # 0
    After: XmlNodeOrder  # 1
    Same: XmlNodeOrder  # 2
    Unknown: XmlNodeOrder  # 3

class XmlNodeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: XmlNodeType  # 0
    Element: XmlNodeType  # 1
    Attribute: XmlNodeType  # 2
    Text: XmlNodeType  # 3
    CDATA: XmlNodeType  # 4
    EntityReference: XmlNodeType  # 5
    Entity: XmlNodeType  # 6
    ProcessingInstruction: XmlNodeType  # 7
    Comment: XmlNodeType  # 8
    Document: XmlNodeType  # 9
    DocumentType: XmlNodeType  # 10
    DocumentFragment: XmlNodeType  # 11
    Notation: XmlNodeType  # 12
    Whitespace: XmlNodeType  # 13
    SignificantWhitespace: XmlNodeType  # 14
    EndElement: XmlNodeType  # 15
    EndEntity: XmlNodeType  # 16
    XmlDeclaration: XmlNodeType  # 17

class XmlOutputMethod(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Xml: XmlOutputMethod  # 0
    Html: XmlOutputMethod  # 1
    Text: XmlOutputMethod  # 2
    AutoDetect: XmlOutputMethod  # 3

class XmlParserContext:
    @typing.overload
    def __init__(
        self,
        nt: typing.Optional[XmlNameTable],
        nsMgr: typing.Optional[XmlNamespaceManager],
        docTypeName: typing.Optional[str],
        pubId: typing.Optional[str],
        sysId: typing.Optional[str],
        internalSubset: typing.Optional[str],
        baseURI: typing.Optional[str],
        xmlLang: typing.Optional[str],
        xmlSpace: XmlSpace,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        nt: typing.Optional[XmlNameTable],
        nsMgr: typing.Optional[XmlNamespaceManager],
        docTypeName: typing.Optional[str],
        pubId: typing.Optional[str],
        sysId: typing.Optional[str],
        internalSubset: typing.Optional[str],
        baseURI: typing.Optional[str],
        xmlLang: typing.Optional[str],
        xmlSpace: XmlSpace,
        enc: typing.Optional[Encoding],
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        nt: typing.Optional[XmlNameTable],
        nsMgr: typing.Optional[XmlNamespaceManager],
        xmlLang: typing.Optional[str],
        xmlSpace: XmlSpace,
    ) -> None: ...
    @typing.overload
    def __init__(
        self,
        nt: typing.Optional[XmlNameTable],
        nsMgr: typing.Optional[XmlNamespaceManager],
        xmlLang: typing.Optional[str],
        xmlSpace: XmlSpace,
        enc: typing.Optional[Encoding],
    ) -> None: ...
    @property
    def BaseURI(self) -> str: ...
    @BaseURI.setter
    def BaseURI(self, value: str) -> str: ...
    @property
    def DocTypeName(self) -> str: ...
    @DocTypeName.setter
    def DocTypeName(self, value: str) -> str: ...
    @property
    def Encoding(self) -> typing.Optional[Encoding]: ...
    @Encoding.setter
    def Encoding(self, value: typing.Optional[Encoding]) -> typing.Optional[Encoding]: ...
    @property
    def InternalSubset(self) -> str: ...
    @InternalSubset.setter
    def InternalSubset(self, value: str) -> str: ...
    @property
    def NamespaceManager(self) -> typing.Optional[XmlNamespaceManager]: ...
    @NamespaceManager.setter
    def NamespaceManager(self, value: typing.Optional[XmlNamespaceManager]) -> typing.Optional[XmlNamespaceManager]: ...
    @property
    def NameTable(self) -> typing.Optional[XmlNameTable]: ...
    @NameTable.setter
    def NameTable(self, value: typing.Optional[XmlNameTable]) -> typing.Optional[XmlNameTable]: ...
    @property
    def PublicId(self) -> str: ...
    @PublicId.setter
    def PublicId(self, value: str) -> str: ...
    @property
    def SystemId(self) -> str: ...
    @SystemId.setter
    def SystemId(self, value: str) -> str: ...
    @property
    def XmlLang(self) -> str: ...
    @XmlLang.setter
    def XmlLang(self, value: str) -> str: ...
    @property
    def XmlSpace(self) -> XmlSpace: ...
    @XmlSpace.setter
    def XmlSpace(self, value: XmlSpace) -> XmlSpace: ...

class XmlReader(IDisposable, abc.ABC):
    @property
    def AttributeCount(self) -> int: ...
    @property
    def BaseURI(self) -> str: ...
    @property
    def CanReadBinaryContent(self) -> bool: ...
    @property
    def CanReadValueChunk(self) -> bool: ...
    @property
    def CanResolveEntity(self) -> bool: ...
    @property
    def Depth(self) -> int: ...
    @property
    def EOF(self) -> bool: ...
    @property
    def HasAttributes(self) -> bool: ...
    @property
    def HasValue(self) -> bool: ...
    @property
    def IsDefault(self) -> bool: ...
    @property
    def IsEmptyElement(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @property
    def Item(self) -> typing.Optional[str]: ...
    @property
    def Item(self) -> typing.Optional[str]: ...
    @property
    def LocalName(self) -> str: ...
    @property
    def Name(self) -> str: ...
    @property
    def NamespaceURI(self) -> str: ...
    @property
    def NameTable(self) -> XmlNameTable: ...
    @property
    def NodeType(self) -> XmlNodeType: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def QuoteChar(self) -> str: ...
    @property
    def ReadState(self) -> ReadState: ...
    @property
    def SchemaInfo(self) -> typing.Optional[IXmlSchemaInfo]: ...
    @property
    def Settings(self) -> typing.Optional[XmlReaderSettings]: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    @property
    def XmlLang(self) -> str: ...
    @property
    def XmlSpace(self) -> XmlSpace: ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def GetValueAsync(self) -> Task_1[str]: ...
    @staticmethod
    def IsName(str: str) -> bool: ...
    @staticmethod
    def IsNameToken(str: str) -> bool: ...
    @abc.abstractmethod
    def LookupNamespace(self, prefix: str) -> typing.Optional[str]: ...
    def MoveToContent(self) -> XmlNodeType: ...
    def MoveToContentAsync(self) -> Task_1[XmlNodeType]: ...
    @abc.abstractmethod
    def MoveToElement(self) -> bool: ...
    @abc.abstractmethod
    def MoveToFirstAttribute(self) -> bool: ...
    @abc.abstractmethod
    def MoveToNextAttribute(self) -> bool: ...
    @abc.abstractmethod
    def Read(self) -> bool: ...
    def ReadAsync(self) -> Task_1[bool]: ...
    @abc.abstractmethod
    def ReadAttributeValue(self) -> bool: ...
    def ReadContentAs(
        self, returnType: typing.Type[typing.Any], namespaceResolver: typing.Optional[IXmlNamespaceResolver]
    ) -> typing.Any: ...
    def ReadContentAsAsync(
        self, returnType: typing.Type[typing.Any], namespaceResolver: typing.Optional[IXmlNamespaceResolver]
    ) -> Task_1[typing.Any]: ...
    def ReadContentAsBase64(self, buffer: Array_1[int], index: int, count: int) -> int: ...
    def ReadContentAsBase64Async(self, buffer: Array_1[int], index: int, count: int) -> Task_1[int]: ...
    def ReadContentAsBinHex(self, buffer: Array_1[int], index: int, count: int) -> int: ...
    def ReadContentAsBinHexAsync(self, buffer: Array_1[int], index: int, count: int) -> Task_1[int]: ...
    def ReadContentAsBoolean(self) -> bool: ...
    def ReadContentAsDateTime(self) -> DateTime: ...
    def ReadContentAsDateTimeOffset(self) -> DateTimeOffset: ...
    def ReadContentAsDecimal(self) -> Decimal: ...
    def ReadContentAsDouble(self) -> float: ...
    def ReadContentAsFloat(self) -> float: ...
    def ReadContentAsInt(self) -> int: ...
    def ReadContentAsLong(self) -> int: ...
    def ReadContentAsObject(self) -> typing.Any: ...
    def ReadContentAsObjectAsync(self) -> Task_1[typing.Any]: ...
    def ReadContentAsString(self) -> str: ...
    def ReadContentAsStringAsync(self) -> Task_1[str]: ...
    def ReadElementContentAsAsync(
        self, returnType: typing.Type[typing.Any], namespaceResolver: IXmlNamespaceResolver
    ) -> Task_1[typing.Any]: ...
    def ReadElementContentAsBase64(self, buffer: Array_1[int], index: int, count: int) -> int: ...
    def ReadElementContentAsBase64Async(self, buffer: Array_1[int], index: int, count: int) -> Task_1[int]: ...
    def ReadElementContentAsBinHex(self, buffer: Array_1[int], index: int, count: int) -> int: ...
    def ReadElementContentAsBinHexAsync(self, buffer: Array_1[int], index: int, count: int) -> Task_1[int]: ...
    def ReadElementContentAsObjectAsync(self) -> Task_1[typing.Any]: ...
    def ReadElementContentAsStringAsync(self) -> Task_1[str]: ...
    def ReadEndElement(self) -> None: ...
    def ReadInnerXml(self) -> str: ...
    def ReadInnerXmlAsync(self) -> Task_1[str]: ...
    def ReadOuterXml(self) -> str: ...
    def ReadOuterXmlAsync(self) -> Task_1[str]: ...
    def ReadString(self) -> str: ...
    def ReadSubtree(self) -> XmlReader: ...
    def ReadValueChunk(self, buffer: Array_1[str], index: int, count: int) -> int: ...
    def ReadValueChunkAsync(self, buffer: Array_1[str], index: int, count: int) -> Task_1[int]: ...
    @abc.abstractmethod
    def ResolveEntity(self) -> None: ...
    def Skip(self) -> None: ...
    def SkipAsync(self) -> Task: ...
    # Skipped Create due to it being static, abstract and generic.

    Create: Create_MethodGroup

    class Create_MethodGroup:
        @typing.overload
        def __call__(self, input: Stream) -> XmlReader: ...
        @typing.overload
        def __call__(self, input: TextReader) -> XmlReader: ...
        @typing.overload
        def __call__(self, inputUri: str) -> XmlReader: ...
        @typing.overload
        def __call__(self, inputUri: str, settings: typing.Optional[XmlReaderSettings]) -> XmlReader: ...
        @typing.overload
        def __call__(self, input: Stream, settings: typing.Optional[XmlReaderSettings]) -> XmlReader: ...
        @typing.overload
        def __call__(self, input: TextReader, settings: typing.Optional[XmlReaderSettings]) -> XmlReader: ...
        @typing.overload
        def __call__(self, reader: XmlReader, settings: typing.Optional[XmlReaderSettings]) -> XmlReader: ...
        @typing.overload
        def __call__(
            self, input: Stream, settings: typing.Optional[XmlReaderSettings], baseUri: typing.Optional[str]
        ) -> XmlReader: ...
        @typing.overload
        def __call__(
            self, input: TextReader, settings: typing.Optional[XmlReaderSettings], baseUri: typing.Optional[str]
        ) -> XmlReader: ...
        @typing.overload
        def __call__(
            self,
            inputUri: str,
            settings: typing.Optional[XmlReaderSettings],
            inputContext: typing.Optional[XmlParserContext],
        ) -> XmlReader: ...
        @typing.overload
        def __call__(
            self,
            input: Stream,
            settings: typing.Optional[XmlReaderSettings],
            inputContext: typing.Optional[XmlParserContext],
        ) -> XmlReader: ...
        @typing.overload
        def __call__(
            self,
            input: TextReader,
            settings: typing.Optional[XmlReaderSettings],
            inputContext: typing.Optional[XmlParserContext],
        ) -> XmlReader: ...

    # Skipped GetAttribute due to it being static, abstract and generic.

    GetAttribute: GetAttribute_MethodGroup

    class GetAttribute_MethodGroup:
        @typing.overload
        def __call__(self, i: int) -> str: ...
        @typing.overload
        def __call__(self, name: str) -> str: ...
        @typing.overload
        def __call__(self, name: str, namespaceURI: typing.Optional[str]) -> str: ...

    # Skipped IsStartElement due to it being static, abstract and generic.

    IsStartElement: IsStartElement_MethodGroup

    class IsStartElement_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, localname: str, ns: str) -> bool: ...

    # Skipped MoveToAttribute due to it being static, abstract and generic.

    MoveToAttribute: MoveToAttribute_MethodGroup

    class MoveToAttribute_MethodGroup:
        @typing.overload
        def __call__(self, i: int) -> None: ...
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, name: str, ns: typing.Optional[str]) -> bool: ...

    # Skipped ReadElementContentAs due to it being static, abstract and generic.

    ReadElementContentAs: ReadElementContentAs_MethodGroup

    class ReadElementContentAs_MethodGroup:
        @typing.overload
        def __call__(
            self, returnType: typing.Type[typing.Any], namespaceResolver: IXmlNamespaceResolver
        ) -> typing.Any: ...
        @typing.overload
        def __call__(
            self,
            returnType: typing.Type[typing.Any],
            namespaceResolver: IXmlNamespaceResolver,
            localName: str,
            namespaceURI: str,
        ) -> typing.Any: ...

    # Skipped ReadElementContentAsBoolean due to it being static, abstract and generic.

    ReadElementContentAsBoolean: ReadElementContentAsBoolean_MethodGroup

    class ReadElementContentAsBoolean_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

    # Skipped ReadElementContentAsDateTime due to it being static, abstract and generic.

    ReadElementContentAsDateTime: ReadElementContentAsDateTime_MethodGroup

    class ReadElementContentAsDateTime_MethodGroup:
        @typing.overload
        def __call__(self) -> DateTime: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> DateTime: ...

    # Skipped ReadElementContentAsDecimal due to it being static, abstract and generic.

    ReadElementContentAsDecimal: ReadElementContentAsDecimal_MethodGroup

    class ReadElementContentAsDecimal_MethodGroup:
        @typing.overload
        def __call__(self) -> Decimal: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> Decimal: ...

    # Skipped ReadElementContentAsDouble due to it being static, abstract and generic.

    ReadElementContentAsDouble: ReadElementContentAsDouble_MethodGroup

    class ReadElementContentAsDouble_MethodGroup:
        @typing.overload
        def __call__(self) -> float: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> float: ...

    # Skipped ReadElementContentAsFloat due to it being static, abstract and generic.

    ReadElementContentAsFloat: ReadElementContentAsFloat_MethodGroup

    class ReadElementContentAsFloat_MethodGroup:
        @typing.overload
        def __call__(self) -> float: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> float: ...

    # Skipped ReadElementContentAsInt due to it being static, abstract and generic.

    ReadElementContentAsInt: ReadElementContentAsInt_MethodGroup

    class ReadElementContentAsInt_MethodGroup:
        @typing.overload
        def __call__(self) -> int: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> int: ...

    # Skipped ReadElementContentAsLong due to it being static, abstract and generic.

    ReadElementContentAsLong: ReadElementContentAsLong_MethodGroup

    class ReadElementContentAsLong_MethodGroup:
        @typing.overload
        def __call__(self) -> int: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> int: ...

    # Skipped ReadElementContentAsObject due to it being static, abstract and generic.

    ReadElementContentAsObject: ReadElementContentAsObject_MethodGroup

    class ReadElementContentAsObject_MethodGroup:
        @typing.overload
        def __call__(self) -> typing.Any: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> typing.Any: ...

    # Skipped ReadElementContentAsString due to it being static, abstract and generic.

    ReadElementContentAsString: ReadElementContentAsString_MethodGroup

    class ReadElementContentAsString_MethodGroup:
        @typing.overload
        def __call__(self) -> str: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> str: ...

    # Skipped ReadElementString due to it being static, abstract and generic.

    ReadElementString: ReadElementString_MethodGroup

    class ReadElementString_MethodGroup:
        @typing.overload
        def __call__(self) -> str: ...
        @typing.overload
        def __call__(self, name: str) -> str: ...
        @typing.overload
        def __call__(self, localname: str, ns: str) -> str: ...

    # Skipped ReadStartElement due to it being static, abstract and generic.

    ReadStartElement: ReadStartElement_MethodGroup

    class ReadStartElement_MethodGroup:
        @typing.overload
        def __call__(self) -> None: ...
        @typing.overload
        def __call__(self, name: str) -> None: ...
        @typing.overload
        def __call__(self, localname: str, ns: str) -> None: ...

    # Skipped ReadToDescendant due to it being static, abstract and generic.

    ReadToDescendant: ReadToDescendant_MethodGroup

    class ReadToDescendant_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

    # Skipped ReadToFollowing due to it being static, abstract and generic.

    ReadToFollowing: ReadToFollowing_MethodGroup

    class ReadToFollowing_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

    # Skipped ReadToNextSibling due to it being static, abstract and generic.

    ReadToNextSibling: ReadToNextSibling_MethodGroup

    class ReadToNextSibling_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

class XmlReaderSettings:
    def __init__(self) -> None: ...
    @property
    def Async(self) -> bool: ...
    @Async.setter
    def Async(self, value: bool) -> bool: ...
    @property
    def CheckCharacters(self) -> bool: ...
    @CheckCharacters.setter
    def CheckCharacters(self, value: bool) -> bool: ...
    @property
    def CloseInput(self) -> bool: ...
    @CloseInput.setter
    def CloseInput(self, value: bool) -> bool: ...
    @property
    def ConformanceLevel(self) -> ConformanceLevel: ...
    @ConformanceLevel.setter
    def ConformanceLevel(self, value: ConformanceLevel) -> ConformanceLevel: ...
    @property
    def DtdProcessing(self) -> DtdProcessing: ...
    @DtdProcessing.setter
    def DtdProcessing(self, value: DtdProcessing) -> DtdProcessing: ...
    @property
    def IgnoreComments(self) -> bool: ...
    @IgnoreComments.setter
    def IgnoreComments(self, value: bool) -> bool: ...
    @property
    def IgnoreProcessingInstructions(self) -> bool: ...
    @IgnoreProcessingInstructions.setter
    def IgnoreProcessingInstructions(self, value: bool) -> bool: ...
    @property
    def IgnoreWhitespace(self) -> bool: ...
    @IgnoreWhitespace.setter
    def IgnoreWhitespace(self, value: bool) -> bool: ...
    @property
    def LineNumberOffset(self) -> int: ...
    @LineNumberOffset.setter
    def LineNumberOffset(self, value: int) -> int: ...
    @property
    def LinePositionOffset(self) -> int: ...
    @LinePositionOffset.setter
    def LinePositionOffset(self, value: int) -> int: ...
    @property
    def MaxCharactersFromEntities(self) -> int: ...
    @MaxCharactersFromEntities.setter
    def MaxCharactersFromEntities(self, value: int) -> int: ...
    @property
    def MaxCharactersInDocument(self) -> int: ...
    @MaxCharactersInDocument.setter
    def MaxCharactersInDocument(self, value: int) -> int: ...
    @property
    def NameTable(self) -> typing.Optional[XmlNameTable]: ...
    @NameTable.setter
    def NameTable(self, value: typing.Optional[XmlNameTable]) -> typing.Optional[XmlNameTable]: ...
    @property
    def ProhibitDtd(self) -> bool: ...
    @ProhibitDtd.setter
    def ProhibitDtd(self, value: bool) -> bool: ...
    @property
    def Schemas(self) -> XmlSchemaSet: ...
    @Schemas.setter
    def Schemas(self, value: XmlSchemaSet) -> XmlSchemaSet: ...
    @property
    def ValidationFlags(self) -> XmlSchemaValidationFlags: ...
    @ValidationFlags.setter
    def ValidationFlags(self, value: XmlSchemaValidationFlags) -> XmlSchemaValidationFlags: ...
    @property
    def ValidationType(self) -> ValidationType: ...
    @ValidationType.setter
    def ValidationType(self, value: ValidationType) -> ValidationType: ...
    @property
    def XmlResolver(self) -> None: ...
    @XmlResolver.setter
    def XmlResolver(self, value: XmlResolver) -> None: ...
    def Clone(self) -> XmlReaderSettings: ...
    def Reset(self) -> None: ...

class XmlResolver(abc.ABC):
    @property
    def Credentials(self) -> None: ...
    @Credentials.setter
    def Credentials(self, value: ICredentials) -> None: ...
    @classmethod
    @property
    def FileSystemResolver(cls) -> XmlResolver: ...
    @classmethod
    @property
    def ThrowingResolver(cls) -> XmlResolver: ...
    @abc.abstractmethod
    def GetEntity(
        self, absoluteUri: Uri, role: typing.Optional[str], ofObjectToReturn: typing.Optional[typing.Type[typing.Any]]
    ) -> typing.Optional[typing.Any]: ...
    def GetEntityAsync(
        self, absoluteUri: Uri, role: typing.Optional[str], ofObjectToReturn: typing.Optional[typing.Type[typing.Any]]
    ) -> Task_1[typing.Any]: ...
    def ResolveUri(self, baseUri: typing.Optional[Uri], relativeUri: typing.Optional[str]) -> Uri: ...
    def SupportsType(self, absoluteUri: Uri, type: typing.Optional[typing.Type[typing.Any]]) -> bool: ...

class XmlSpace(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: XmlSpace  # 0
    Default: XmlSpace  # 1
    Preserve: XmlSpace  # 2

class XmlWriter(IAsyncDisposable, IDisposable, abc.ABC):
    @property
    def Settings(self) -> typing.Optional[XmlWriterSettings]: ...
    @property
    def WriteState(self) -> WriteState: ...
    @property
    def XmlLang(self) -> typing.Optional[str]: ...
    @property
    def XmlSpace(self) -> XmlSpace: ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    @abc.abstractmethod
    def Flush(self) -> None: ...
    def FlushAsync(self) -> Task: ...
    @abc.abstractmethod
    def LookupPrefix(self, ns: str) -> typing.Optional[str]: ...
    def WriteAttributes(self, reader: XmlReader, defattr: bool) -> None: ...
    def WriteAttributesAsync(self, reader: XmlReader, defattr: bool) -> Task: ...
    def WriteAttributeStringAsync(
        self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str], value: typing.Optional[str]
    ) -> Task: ...
    @abc.abstractmethod
    def WriteBase64(self, buffer: Array_1[int], index: int, count: int) -> None: ...
    def WriteBase64Async(self, buffer: Array_1[int], index: int, count: int) -> Task: ...
    def WriteBinHex(self, buffer: Array_1[int], index: int, count: int) -> None: ...
    def WriteBinHexAsync(self, buffer: Array_1[int], index: int, count: int) -> Task: ...
    @abc.abstractmethod
    def WriteCData(self, text: typing.Optional[str]) -> None: ...
    def WriteCDataAsync(self, text: typing.Optional[str]) -> Task: ...
    @abc.abstractmethod
    def WriteCharEntity(self, ch: str) -> None: ...
    def WriteCharEntityAsync(self, ch: str) -> Task: ...
    @abc.abstractmethod
    def WriteChars(self, buffer: Array_1[str], index: int, count: int) -> None: ...
    def WriteCharsAsync(self, buffer: Array_1[str], index: int, count: int) -> Task: ...
    @abc.abstractmethod
    def WriteComment(self, text: typing.Optional[str]) -> None: ...
    def WriteCommentAsync(self, text: typing.Optional[str]) -> Task: ...
    @abc.abstractmethod
    def WriteDocType(
        self, name: str, pubid: typing.Optional[str], sysid: typing.Optional[str], subset: typing.Optional[str]
    ) -> None: ...
    def WriteDocTypeAsync(
        self, name: str, pubid: typing.Optional[str], sysid: typing.Optional[str], subset: typing.Optional[str]
    ) -> Task: ...
    def WriteElementStringAsync(
        self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str], value: str
    ) -> Task: ...
    @abc.abstractmethod
    def WriteEndAttribute(self) -> None: ...
    @abc.abstractmethod
    def WriteEndDocument(self) -> None: ...
    def WriteEndDocumentAsync(self) -> Task: ...
    @abc.abstractmethod
    def WriteEndElement(self) -> None: ...
    def WriteEndElementAsync(self) -> Task: ...
    @abc.abstractmethod
    def WriteEntityRef(self, name: str) -> None: ...
    def WriteEntityRefAsync(self, name: str) -> Task: ...
    @abc.abstractmethod
    def WriteFullEndElement(self) -> None: ...
    def WriteFullEndElementAsync(self) -> Task: ...
    def WriteName(self, name: str) -> None: ...
    def WriteNameAsync(self, name: str) -> Task: ...
    def WriteNmToken(self, name: str) -> None: ...
    def WriteNmTokenAsync(self, name: str) -> Task: ...
    @abc.abstractmethod
    def WriteProcessingInstruction(self, name: str, text: typing.Optional[str]) -> None: ...
    def WriteProcessingInstructionAsync(self, name: str, text: typing.Optional[str]) -> Task: ...
    def WriteQualifiedName(self, localName: str, ns: typing.Optional[str]) -> None: ...
    def WriteQualifiedNameAsync(self, localName: str, ns: typing.Optional[str]) -> Task: ...
    def WriteStartElementAsync(
        self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str]
    ) -> Task: ...
    @abc.abstractmethod
    def WriteString(self, text: typing.Optional[str]) -> None: ...
    def WriteStringAsync(self, text: typing.Optional[str]) -> Task: ...
    @abc.abstractmethod
    def WriteSurrogateCharEntity(self, lowChar: str, highChar: str) -> None: ...
    def WriteSurrogateCharEntityAsync(self, lowChar: str, highChar: str) -> Task: ...
    @abc.abstractmethod
    def WriteWhitespace(self, ws: typing.Optional[str]) -> None: ...
    def WriteWhitespaceAsync(self, ws: typing.Optional[str]) -> Task: ...
    # Skipped Create due to it being static, abstract and generic.

    Create: Create_MethodGroup

    class Create_MethodGroup:
        @typing.overload
        def __call__(self, output: Stream) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: TextWriter) -> XmlWriter: ...
        @typing.overload
        def __call__(self, outputFileName: str) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: StringBuilder) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: XmlWriter) -> XmlWriter: ...
        @typing.overload
        def __call__(self, outputFileName: str, settings: typing.Optional[XmlWriterSettings]) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: Stream, settings: typing.Optional[XmlWriterSettings]) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: TextWriter, settings: typing.Optional[XmlWriterSettings]) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: StringBuilder, settings: typing.Optional[XmlWriterSettings]) -> XmlWriter: ...
        @typing.overload
        def __call__(self, output: XmlWriter, settings: typing.Optional[XmlWriterSettings]) -> XmlWriter: ...

    # Skipped WriteAttributeString due to it being static, abstract and generic.

    WriteAttributeString: WriteAttributeString_MethodGroup

    class WriteAttributeString_MethodGroup:
        @typing.overload
        def __call__(self, localName: str, value: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(self, localName: str, ns: typing.Optional[str], value: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(
            self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str], value: typing.Optional[str]
        ) -> None: ...

    # Skipped WriteElementString due to it being static, abstract and generic.

    WriteElementString: WriteElementString_MethodGroup

    class WriteElementString_MethodGroup:
        @typing.overload
        def __call__(self, localName: str, value: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(self, localName: str, ns: typing.Optional[str], value: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(
            self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str], value: typing.Optional[str]
        ) -> None: ...

    # Skipped WriteNode due to it being static, abstract and generic.

    WriteNode: WriteNode_MethodGroup

    class WriteNode_MethodGroup:
        @typing.overload
        def __call__(self, navigator: XPathNavigator, defattr: bool) -> None: ...
        @typing.overload
        def __call__(self, reader: XmlReader, defattr: bool) -> None: ...

    # Skipped WriteNodeAsync due to it being static, abstract and generic.

    WriteNodeAsync: WriteNodeAsync_MethodGroup

    class WriteNodeAsync_MethodGroup:
        @typing.overload
        def __call__(self, navigator: XPathNavigator, defattr: bool) -> Task: ...
        @typing.overload
        def __call__(self, reader: XmlReader, defattr: bool) -> Task: ...

    # Skipped WriteRaw due to it being static, abstract and generic.

    WriteRaw: WriteRaw_MethodGroup

    class WriteRaw_MethodGroup:
        @typing.overload
        def __call__(self, data: str) -> None: ...
        @typing.overload
        def __call__(self, buffer: Array_1[str], index: int, count: int) -> None: ...

    # Skipped WriteRawAsync due to it being static, abstract and generic.

    WriteRawAsync: WriteRawAsync_MethodGroup

    class WriteRawAsync_MethodGroup:
        @typing.overload
        def __call__(self, data: str) -> Task: ...
        @typing.overload
        def __call__(self, buffer: Array_1[str], index: int, count: int) -> Task: ...

    # Skipped WriteStartAttribute due to it being static, abstract and generic.

    WriteStartAttribute: WriteStartAttribute_MethodGroup

    class WriteStartAttribute_MethodGroup:
        @typing.overload
        def __call__(self, localName: str) -> None: ...
        @typing.overload
        def __call__(self, localName: str, ns: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str]) -> None: ...

    # Skipped WriteStartDocument due to it being static, abstract and generic.

    WriteStartDocument: WriteStartDocument_MethodGroup

    class WriteStartDocument_MethodGroup:
        @typing.overload
        def __call__(self) -> None: ...
        @typing.overload
        def __call__(self, standalone: bool) -> None: ...

    # Skipped WriteStartDocumentAsync due to it being static, abstract and generic.

    WriteStartDocumentAsync: WriteStartDocumentAsync_MethodGroup

    class WriteStartDocumentAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task: ...
        @typing.overload
        def __call__(self, standalone: bool) -> Task: ...

    # Skipped WriteStartElement due to it being static, abstract and generic.

    WriteStartElement: WriteStartElement_MethodGroup

    class WriteStartElement_MethodGroup:
        @typing.overload
        def __call__(self, localName: str) -> None: ...
        @typing.overload
        def __call__(self, localName: str, ns: typing.Optional[str]) -> None: ...
        @typing.overload
        def __call__(self, prefix: typing.Optional[str], localName: str, ns: typing.Optional[str]) -> None: ...

    # Skipped WriteValue due to it being static, abstract and generic.

    WriteValue: WriteValue_MethodGroup

    class WriteValue_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> None: ...
        # Method WriteValue(value : Single) was skipped since it collides with above method
        # Method WriteValue(value : Int32) was skipped since it collides with above method
        # Method WriteValue(value : Int64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: Decimal) -> None: ...
        @typing.overload
        def __call__(self, value: typing.Optional[str]) -> None: ...
        # Method WriteValue(value : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: DateTime) -> None: ...
        @typing.overload
        def __call__(self, value: DateTimeOffset) -> None: ...
        @typing.overload
        def __call__(self, value: typing.Any) -> None: ...

class XmlWriterSettings:
    def __init__(self) -> None: ...
    @property
    def Async(self) -> bool: ...
    @Async.setter
    def Async(self, value: bool) -> bool: ...
    @property
    def CheckCharacters(self) -> bool: ...
    @CheckCharacters.setter
    def CheckCharacters(self, value: bool) -> bool: ...
    @property
    def CloseOutput(self) -> bool: ...
    @CloseOutput.setter
    def CloseOutput(self, value: bool) -> bool: ...
    @property
    def ConformanceLevel(self) -> ConformanceLevel: ...
    @ConformanceLevel.setter
    def ConformanceLevel(self, value: ConformanceLevel) -> ConformanceLevel: ...
    @property
    def DoNotEscapeUriAttributes(self) -> bool: ...
    @DoNotEscapeUriAttributes.setter
    def DoNotEscapeUriAttributes(self, value: bool) -> bool: ...
    @property
    def Encoding(self) -> Encoding: ...
    @Encoding.setter
    def Encoding(self, value: Encoding) -> Encoding: ...
    @property
    def Indent(self) -> bool: ...
    @Indent.setter
    def Indent(self, value: bool) -> bool: ...
    @property
    def IndentChars(self) -> str: ...
    @IndentChars.setter
    def IndentChars(self, value: str) -> str: ...
    @property
    def NamespaceHandling(self) -> NamespaceHandling: ...
    @NamespaceHandling.setter
    def NamespaceHandling(self, value: NamespaceHandling) -> NamespaceHandling: ...
    @property
    def NewLineChars(self) -> str: ...
    @NewLineChars.setter
    def NewLineChars(self, value: str) -> str: ...
    @property
    def NewLineHandling(self) -> NewLineHandling: ...
    @NewLineHandling.setter
    def NewLineHandling(self, value: NewLineHandling) -> NewLineHandling: ...
    @property
    def NewLineOnAttributes(self) -> bool: ...
    @NewLineOnAttributes.setter
    def NewLineOnAttributes(self, value: bool) -> bool: ...
    @property
    def OmitXmlDeclaration(self) -> bool: ...
    @OmitXmlDeclaration.setter
    def OmitXmlDeclaration(self, value: bool) -> bool: ...
    @property
    def OutputMethod(self) -> XmlOutputMethod: ...
    @OutputMethod.setter
    def OutputMethod(self, value: XmlOutputMethod) -> XmlOutputMethod: ...
    @property
    def WriteEndDocumentOnClose(self) -> bool: ...
    @WriteEndDocumentOnClose.setter
    def WriteEndDocumentOnClose(self, value: bool) -> bool: ...
    def Clone(self) -> XmlWriterSettings: ...
    def Reset(self) -> None: ...
