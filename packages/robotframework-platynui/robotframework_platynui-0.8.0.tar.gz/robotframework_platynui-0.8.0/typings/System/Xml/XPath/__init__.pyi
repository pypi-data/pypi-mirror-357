# This file was generated by PythonNetStubGenerator
# mypy: ignore-errors
import typing, abc
from System.Collections import IComparer, IEqualityComparer, IEnumerable, IEnumerator
from System.Xml import (
    IXmlNamespaceResolver,
    XmlNamespaceManager,
    XmlNameTable,
    XmlNodeOrder,
    XmlWriter,
    XmlNamespaceScope,
    XmlReader,
)
from System import DateTime, ICloneable
from System.Xml.Schema import XmlSchemaType, IXmlSchemaInfo, XmlSchemaSet, ValidationEventHandler
from System.Collections.Generic import IDictionary_2

class IXPathNavigable(typing.Protocol):
    @abc.abstractmethod
    def CreateNavigator(self) -> typing.Optional[XPathNavigator]: ...

class XmlCaseOrder(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    None_: XmlCaseOrder  # 0
    UpperFirst: XmlCaseOrder  # 1
    LowerFirst: XmlCaseOrder  # 2

class XmlDataType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Text: XmlDataType  # 1
    Number: XmlDataType  # 2

class XmlSortOrder(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Ascending: XmlSortOrder  # 1
    Descending: XmlSortOrder  # 2

class XPathExpression(abc.ABC):
    @property
    def Expression(self) -> str: ...
    @property
    def ReturnType(self) -> XPathResultType: ...
    @abc.abstractmethod
    def Clone(self) -> XPathExpression: ...
    # Skipped AddSort due to it being static, abstract and generic.

    AddSort: AddSort_MethodGroup

    class AddSort_MethodGroup:
        @typing.overload
        def __call__(self, expr: typing.Any, comparer: IComparer) -> None: ...
        @typing.overload
        def __call__(
            self, expr: typing.Any, order: XmlSortOrder, caseOrder: XmlCaseOrder, lang: str, dataType: XmlDataType
        ) -> None: ...

    # Skipped Compile due to it being static, abstract and generic.

    Compile: Compile_MethodGroup

    class Compile_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathExpression: ...
        @typing.overload
        def __call__(self, xpath: str, nsResolver: typing.Optional[IXmlNamespaceResolver]) -> XPathExpression: ...

    # Skipped SetContext due to it being static, abstract and generic.

    SetContext: SetContext_MethodGroup

    class SetContext_MethodGroup:
        @typing.overload
        def __call__(self, nsManager: XmlNamespaceManager) -> None: ...
        @typing.overload
        def __call__(self, nsResolver: typing.Optional[IXmlNamespaceResolver]) -> None: ...

class XPathItem(abc.ABC):
    @property
    def IsNode(self) -> bool: ...
    @property
    def TypedValue(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueAsBoolean(self) -> bool: ...
    @property
    def ValueAsDateTime(self) -> DateTime: ...
    @property
    def ValueAsDouble(self) -> float: ...
    @property
    def ValueAsInt(self) -> int: ...
    @property
    def ValueAsLong(self) -> int: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    @property
    def XmlType(self) -> typing.Optional[XmlSchemaType]: ...
    # Skipped ValueAs due to it being static, abstract and generic.

    ValueAs: ValueAs_MethodGroup

    class ValueAs_MethodGroup:
        @typing.overload
        def __call__(self, returnType: typing.Type[typing.Any]) -> typing.Any: ...
        @typing.overload
        def __call__(
            self, returnType: typing.Type[typing.Any], nsResolver: typing.Optional[IXmlNamespaceResolver]
        ) -> typing.Any: ...

class XPathNamespaceScope(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    All: XPathNamespaceScope  # 0
    ExcludeXml: XPathNamespaceScope  # 1
    Local: XPathNamespaceScope  # 2

class XPathNavigator(XPathItem, IXmlNamespaceResolver, IXPathNavigable, ICloneable):
    @property
    def BaseURI(self) -> str: ...
    @property
    def CanEdit(self) -> bool: ...
    @property
    def HasAttributes(self) -> bool: ...
    @property
    def HasChildren(self) -> bool: ...
    @property
    def InnerXml(self) -> str: ...
    @InnerXml.setter
    def InnerXml(self, value: str) -> str: ...
    @property
    def IsEmptyElement(self) -> bool: ...
    @property
    def IsNode(self) -> bool: ...
    @property
    def LocalName(self) -> str: ...
    @property
    def Name(self) -> str: ...
    @property
    def NamespaceURI(self) -> str: ...
    @property
    def NameTable(self) -> XmlNameTable: ...
    @classmethod
    @property
    def NavigatorComparer(cls) -> IEqualityComparer: ...
    @property
    def NodeType(self) -> XPathNodeType: ...
    @property
    def OuterXml(self) -> str: ...
    @OuterXml.setter
    def OuterXml(self, value: str) -> str: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def SchemaInfo(self) -> typing.Optional[IXmlSchemaInfo]: ...
    @property
    def TypedValue(self) -> typing.Any: ...
    @property
    def UnderlyingObject(self) -> typing.Optional[typing.Any]: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueAsBoolean(self) -> bool: ...
    @property
    def ValueAsDateTime(self) -> DateTime: ...
    @property
    def ValueAsDouble(self) -> float: ...
    @property
    def ValueAsInt(self) -> int: ...
    @property
    def ValueAsLong(self) -> int: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    @property
    def XmlLang(self) -> str: ...
    @property
    def XmlType(self) -> typing.Optional[XmlSchemaType]: ...
    def AppendChildElement(
        self,
        prefix: typing.Optional[str],
        localName: str,
        namespaceURI: typing.Optional[str],
        value: typing.Optional[str],
    ) -> None: ...
    def CheckValidity(self, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler) -> bool: ...
    @abc.abstractmethod
    def Clone(self) -> XPathNavigator: ...
    def ComparePosition(self, nav: typing.Optional[XPathNavigator]) -> XmlNodeOrder: ...
    def Compile(self, xpath: str) -> XPathExpression: ...
    def CreateAttribute(
        self,
        prefix: typing.Optional[str],
        localName: str,
        namespaceURI: typing.Optional[str],
        value: typing.Optional[str],
    ) -> None: ...
    def CreateAttributes(self) -> XmlWriter: ...
    def CreateNavigator(self) -> XPathNavigator: ...
    def DeleteRange(self, lastSiblingToDelete: XPathNavigator) -> None: ...
    def DeleteSelf(self) -> None: ...
    def GetAttribute(self, localName: str, namespaceURI: str) -> str: ...
    def GetNamespace(self, name: str) -> str: ...
    def GetNamespacesInScope(self, scope: XmlNamespaceScope) -> IDictionary_2[str, str]: ...
    def InsertElementAfter(
        self,
        prefix: typing.Optional[str],
        localName: str,
        namespaceURI: typing.Optional[str],
        value: typing.Optional[str],
    ) -> None: ...
    def InsertElementBefore(
        self,
        prefix: typing.Optional[str],
        localName: str,
        namespaceURI: typing.Optional[str],
        value: typing.Optional[str],
    ) -> None: ...
    def IsDescendant(self, nav: typing.Optional[XPathNavigator]) -> bool: ...
    @abc.abstractmethod
    def IsSamePosition(self, other: XPathNavigator) -> bool: ...
    def LookupNamespace(self, prefix: str) -> typing.Optional[str]: ...
    def LookupPrefix(self, namespaceURI: str) -> typing.Optional[str]: ...
    @abc.abstractmethod
    def MoveTo(self, other: XPathNavigator) -> bool: ...
    def MoveToAttribute(self, localName: str, namespaceURI: str) -> bool: ...
    def MoveToFirst(self) -> bool: ...
    @abc.abstractmethod
    def MoveToFirstAttribute(self) -> bool: ...
    @abc.abstractmethod
    def MoveToFirstChild(self) -> bool: ...
    @abc.abstractmethod
    def MoveToId(self, id: str) -> bool: ...
    def MoveToNamespace(self, name: str) -> bool: ...
    @abc.abstractmethod
    def MoveToNextAttribute(self) -> bool: ...
    @abc.abstractmethod
    def MoveToParent(self) -> bool: ...
    @abc.abstractmethod
    def MoveToPrevious(self) -> bool: ...
    def MoveToRoot(self) -> None: ...
    def PrependChildElement(
        self,
        prefix: typing.Optional[str],
        localName: str,
        namespaceURI: typing.Optional[str],
        value: typing.Optional[str],
    ) -> None: ...
    def ReadSubtree(self) -> XmlReader: ...
    def ReplaceRange(self, lastSiblingToReplace: XPathNavigator) -> XmlWriter: ...
    def SetTypedValue(self, typedValue: typing.Any) -> None: ...
    def SetValue(self, value: str) -> None: ...
    def ToString(self) -> str: ...
    def ValueAs(
        self, returnType: typing.Type[typing.Any], nsResolver: typing.Optional[IXmlNamespaceResolver]
    ) -> typing.Any: ...
    def WriteSubtree(self, writer: XmlWriter) -> None: ...
    # Skipped AppendChild due to it being static, abstract and generic.

    AppendChild: AppendChild_MethodGroup

    class AppendChild_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter: ...
        @typing.overload
        def __call__(self, newChild: str) -> None: ...
        @typing.overload
        def __call__(self, newChild: XPathNavigator) -> None: ...
        @typing.overload
        def __call__(self, newChild: XmlReader) -> None: ...

    # Skipped Evaluate due to it being static, abstract and generic.

    Evaluate: Evaluate_MethodGroup

    class Evaluate_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> typing.Any: ...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> typing.Any: ...
        @typing.overload
        def __call__(self, xpath: str, resolver: typing.Optional[IXmlNamespaceResolver]) -> typing.Any: ...
        @typing.overload
        def __call__(self, expr: XPathExpression, context: typing.Optional[XPathNodeIterator]) -> typing.Any: ...

    # Skipped InsertAfter due to it being static, abstract and generic.

    InsertAfter: InsertAfter_MethodGroup

    class InsertAfter_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter: ...
        @typing.overload
        def __call__(self, newSibling: str) -> None: ...
        @typing.overload
        def __call__(self, newSibling: XPathNavigator) -> None: ...
        @typing.overload
        def __call__(self, newSibling: XmlReader) -> None: ...

    # Skipped InsertBefore due to it being static, abstract and generic.

    InsertBefore: InsertBefore_MethodGroup

    class InsertBefore_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter: ...
        @typing.overload
        def __call__(self, newSibling: str) -> None: ...
        @typing.overload
        def __call__(self, newSibling: XPathNavigator) -> None: ...
        @typing.overload
        def __call__(self, newSibling: XmlReader) -> None: ...

    # Skipped Matches due to it being static, abstract and generic.

    Matches: Matches_MethodGroup

    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> bool: ...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> bool: ...

    # Skipped MoveToChild due to it being static, abstract and generic.

    MoveToChild: MoveToChild_MethodGroup

    class MoveToChild_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

    # Skipped MoveToFirstNamespace due to it being static, abstract and generic.

    MoveToFirstNamespace: MoveToFirstNamespace_MethodGroup

    class MoveToFirstNamespace_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, namespaceScope: XPathNamespaceScope) -> bool: ...

    # Skipped MoveToFollowing due to it being static, abstract and generic.

    MoveToFollowing: MoveToFollowing_MethodGroup

    class MoveToFollowing_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool: ...
        @typing.overload
        def __call__(self, type: XPathNodeType, end: typing.Optional[XPathNavigator]) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str, end: typing.Optional[XPathNavigator]) -> bool: ...

    # Skipped MoveToNext due to it being static, abstract and generic.

    MoveToNext: MoveToNext_MethodGroup

    class MoveToNext_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool: ...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool: ...

    # Skipped MoveToNextNamespace due to it being static, abstract and generic.

    MoveToNextNamespace: MoveToNextNamespace_MethodGroup

    class MoveToNextNamespace_MethodGroup:
        @typing.overload
        def __call__(self) -> bool: ...
        @typing.overload
        def __call__(self, namespaceScope: XPathNamespaceScope) -> bool: ...

    # Skipped PrependChild due to it being static, abstract and generic.

    PrependChild: PrependChild_MethodGroup

    class PrependChild_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter: ...
        @typing.overload
        def __call__(self, newChild: str) -> None: ...
        @typing.overload
        def __call__(self, newChild: XPathNavigator) -> None: ...
        @typing.overload
        def __call__(self, newChild: XmlReader) -> None: ...

    # Skipped ReplaceSelf due to it being static, abstract and generic.

    ReplaceSelf: ReplaceSelf_MethodGroup

    class ReplaceSelf_MethodGroup:
        @typing.overload
        def __call__(self, newNode: str) -> None: ...
        @typing.overload
        def __call__(self, newNode: XPathNavigator) -> None: ...
        @typing.overload
        def __call__(self, newNode: XmlReader) -> None: ...

    # Skipped Select due to it being static, abstract and generic.

    Select: Select_MethodGroup

    class Select_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathNodeIterator: ...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> XPathNodeIterator: ...
        @typing.overload
        def __call__(self, xpath: str, resolver: typing.Optional[IXmlNamespaceResolver]) -> XPathNodeIterator: ...

    # Skipped SelectAncestors due to it being static, abstract and generic.

    SelectAncestors: SelectAncestors_MethodGroup

    class SelectAncestors_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType, matchSelf: bool) -> XPathNodeIterator: ...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str, matchSelf: bool) -> XPathNodeIterator: ...

    # Skipped SelectChildren due to it being static, abstract and generic.

    SelectChildren: SelectChildren_MethodGroup

    class SelectChildren_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> XPathNodeIterator: ...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str) -> XPathNodeIterator: ...

    # Skipped SelectDescendants due to it being static, abstract and generic.

    SelectDescendants: SelectDescendants_MethodGroup

    class SelectDescendants_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType, matchSelf: bool) -> XPathNodeIterator: ...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str, matchSelf: bool) -> XPathNodeIterator: ...

    # Skipped SelectSingleNode due to it being static, abstract and generic.

    SelectSingleNode: SelectSingleNode_MethodGroup

    class SelectSingleNode_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathNavigator: ...
        @typing.overload
        def __call__(self, expression: XPathExpression) -> XPathNavigator: ...
        @typing.overload
        def __call__(self, xpath: str, resolver: typing.Optional[IXmlNamespaceResolver]) -> XPathNavigator: ...

class XPathNodeIterator(IEnumerable, ICloneable, abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def Current(self) -> typing.Optional[XPathNavigator]: ...
    @property
    def CurrentPosition(self) -> int: ...
    @abc.abstractmethod
    def Clone(self) -> XPathNodeIterator: ...
    def GetEnumerator(self) -> IEnumerator: ...
    @abc.abstractmethod
    def MoveNext(self) -> bool: ...

class XPathNodeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Root: XPathNodeType  # 0
    Element: XPathNodeType  # 1
    Attribute: XPathNodeType  # 2
    Namespace: XPathNodeType  # 3
    Text: XPathNodeType  # 4
    SignificantWhitespace: XPathNodeType  # 5
    Whitespace: XPathNodeType  # 6
    ProcessingInstruction: XPathNodeType  # 7
    Comment: XPathNodeType  # 8
    All: XPathNodeType  # 9

class XPathResultType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...

    # Values:
    Number: XPathResultType  # 0
    String: XPathResultType  # 1
    Navigator: XPathResultType  # 1
    Boolean: XPathResultType  # 2
    NodeSet: XPathResultType  # 3
    Any: XPathResultType  # 5
    Error: XPathResultType  # 6
