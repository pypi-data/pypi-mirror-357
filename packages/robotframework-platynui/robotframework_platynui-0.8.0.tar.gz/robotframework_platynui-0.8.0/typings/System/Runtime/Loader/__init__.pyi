# This file was generated by PythonNetStubGenerator
# mypy: ignore-errors
import typing
from System.Reflection import AssemblyName, Assembly
from System.Collections.Generic import IEnumerable_1
from System.IO import Stream
from System import IDisposable

class AssemblyDependencyResolver:
    def __init__(self, componentAssemblyPath: str) -> None: ...
    def ResolveAssemblyToPath(self, assemblyName: AssemblyName) -> typing.Optional[str]: ...
    def ResolveUnmanagedDllToPath(self, unmanagedDllName: str) -> typing.Optional[str]: ...

class AssemblyLoadContext:
    def __init__(self, name: typing.Optional[str], isCollectible: bool = ...) -> None: ...
    @classmethod
    @property
    def All(cls) -> IEnumerable_1[AssemblyLoadContext]: ...
    @property
    def Assemblies(self) -> IEnumerable_1[Assembly]: ...
    @classmethod
    @property
    def CurrentContextualReflectionContext(cls) -> typing.Optional[AssemblyLoadContext]: ...
    @classmethod
    @property
    def Default(cls) -> AssemblyLoadContext: ...
    @property
    def IsCollectible(self) -> bool: ...
    @property
    def Name(self) -> typing.Optional[str]: ...
    @staticmethod
    def GetAssemblyName(assemblyPath: str) -> AssemblyName: ...
    @staticmethod
    def GetLoadContext(assembly: Assembly) -> typing.Optional[AssemblyLoadContext]: ...
    def LoadFromAssemblyName(self, assemblyName: AssemblyName) -> Assembly: ...
    def LoadFromAssemblyPath(self, assemblyPath: str) -> Assembly: ...
    def LoadFromNativeImagePath(self, nativeImagePath: str, assemblyPath: typing.Optional[str]) -> Assembly: ...
    def SetProfileOptimizationRoot(self, directoryPath: str) -> None: ...
    def StartProfileOptimization(self, profile: typing.Optional[str]) -> None: ...
    def ToString(self) -> str: ...
    def Unload(self) -> None: ...
    # Skipped EnterContextualReflection due to it being static, abstract and generic.

    EnterContextualReflection: EnterContextualReflection_MethodGroup

    class EnterContextualReflection_MethodGroup:
        @typing.overload
        def __call__(self) -> AssemblyLoadContext.ContextualReflectionScope: ...
        @typing.overload
        def __call__(self, activating: typing.Optional[Assembly]) -> AssemblyLoadContext.ContextualReflectionScope: ...

    # Skipped LoadFromStream due to it being static, abstract and generic.

    LoadFromStream: LoadFromStream_MethodGroup

    class LoadFromStream_MethodGroup:
        @typing.overload
        def __call__(self, assembly: Stream) -> Assembly: ...
        @typing.overload
        def __call__(self, assembly: Stream, assemblySymbols: typing.Optional[Stream]) -> Assembly: ...

    class ContextualReflectionScope(IDisposable):
        def Dispose(self) -> None: ...
