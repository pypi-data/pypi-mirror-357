# Copyright (c) 2025 Frank David Martínez Muñoz <mnesarco>
# SPDX-License-Identifier: MIT

import re
import textwrap
from collections.abc import Callable
from dataclasses import dataclass
from datetime import datetime
from itertools import product
from pathlib import Path
from typing import Any


@dataclass
class TableOutput:
    """Table output class."""

    content: str
    rows: int
    columns: int


def default_cell_render(content: str, *_) -> str:  # noqa: ANN002
    """
    Default cell render function.

    Simply calls str() on the content.

    :param content: cell content
    :param _args: ignored
    :return: rendered cell content
    """
    return str(content)


def table_output(
    data: list[list[Any]],
    indent: int = 0,
    sep: str = "",
    render: Callable[[Any, int, int], str] = default_cell_render,
    just: Callable[[str, int], str] = str.center,
) -> TableOutput:
    """
    Render a table from a list of lists.

    This function takes a 2D array of objects and renders them as a table.
    The table is rendered with centered columns and can be indented.
    The table is returned as a TableOutput object, which contains the
    rendered string, the number of rows and the number of columns.

    :param data: The 2D array of objects to render.
    :param indent: The number of spaces to indent the table with.
                  Defaults to 0.
    :param sep: The separator to use between columns. Defaults to "".
    :param render: A function that takes an object and row and column
                   indexes and returns a string. Defaults to default_cell_render.
    :param just: A function that takes a string and a width and returns a
                 string. Defaults to str.center.
    :return: A TableOutput object containing the rendered table.
    """
    num_rows = len(data)
    num_cols = max(len(r) for r in data) if data else 0
    table = [["" for c in range(num_cols)] for r in range(num_rows)]
    widths = [0] * num_cols

    for n_row, row in enumerate(data):
        min_col = (num_cols - len(row)) // 2
        for c in range(len(row)):
            col = min_col + c
            content = f"{render(row[c], n_row, col)} "
            table[n_row][col] = content
            widths[col] = max(widths[col], len(content))

    for r, c in product(range(num_rows), range(num_cols)):
        table[r][c] = just(table[r][c], (widths[c]))

    rows = [sep.join(r) for r in table]
    body = textwrap.indent(f"{sep}\n".join(rows), " " * indent)
    return TableOutput(f"\n{body}", num_rows, num_cols)


def file_header_comment(comment_style: str = "//") -> str:
    """
    Generate a file header comment.

    :param comment_style: The style of comment to use (e.g., "//", "#").
                          Defaults to "//".
    :return: A string representing the file header comment.
    """
    return f"{comment_style} Generated by zkeymap: https://pypi.org/project/zkeymap/\n"


def file_tag(name: str | Path) -> str:
    """
    Create a unique, uppercase, alphanumeric C/C++ include guard token.

    The token is in the form of "INCLUDED_<name>_H", where <name> is the
    file name with all non-alphanumeric characters replaced by "_".

    :param name: the file name to create the guard token from.
    :return: the guard token.
    """
    path = Path(name)
    base = re.sub(r"\W+", "_", path.stem).upper()
    return f"INCLUDED_{base}_H"


def path_with_suffix(name: str | Path, suffix: str) -> Path:
    """
    Add a suffix to a path if it does not have one already.

    :param name: the path to modify.
    :param suffix: the suffix to add if the path does not have one.

    :return: A Path object with the suffix added if it was not already present.
    """
    path = Path(name)
    if path.suffix:
        return path
    return Path(path.parent, f"{path.stem}{suffix}")


def ascii_box(text: str, indent: int = 0) -> str:
    """
    Format a string into a box with ascii art.

    :param text: the text to format.
    :param indent: the indentation to apply to the output.

    :return: A string with the formatted text inside a box with ascii art.
    """
    content = textwrap.dedent(f"{text}")
    lines = content.splitlines()
    size = max(map(len, lines))
    lines = [f"// │ {r.ljust(size, ' ')} │" for r in lines]
    size += 2
    top = "".join(["// ┌", "─" * size, "┐"])
    bottom = "".join(["// └", "─" * size, "┘"])
    middle = "\n".join(lines)
    return textwrap.indent(f"\n{top}\n{middle}\n{bottom}", " " * indent)
