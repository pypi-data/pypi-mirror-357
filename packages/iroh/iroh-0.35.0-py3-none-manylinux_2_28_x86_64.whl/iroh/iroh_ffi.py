

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_iroh_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_iroh_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_iroh_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("iroh_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_iroh_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_iroh_ffi_checksum_func_key_to_path() != 28001:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_func_path_to_key() != 4438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_func_set_log_level() != 52619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addcallback_progress() != 62116:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_as_abort() != 44667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_as_all_done() != 62551:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_as_done() != 58505:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_as_found() != 8172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_as_progress() != 36155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_addprogress_type() != 46221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_author_id() != 39022:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authorid_equal() != 56356:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_create() != 47692:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_default() != 6795:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_delete() != 51040:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_export() != 17391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_import() != 11067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_import_author() != 56460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_authors_list() != 33930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_bistream_recv() != 60625:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_bistream_send() != 13146:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_client_connected() != 48446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_get_request_received() != 8740:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_tagged_blob_added() != 59887:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_aborted() != 41238:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_blob_completed() != 20663:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_completed() != 47368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_hash_seq_started() != 27778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_progress() != 40626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideevent_type() != 51159:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobprovideeventcallback_blob_event() != 43399:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobticket_as_download_options() != 18713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobticket_format() != 35808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobticket_hash() != 54061:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobticket_node_addr() != 30662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobticket_recursive() != 53797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes() != 16525:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes_named() != 4623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_add_from_path() != 12412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_create_collection() != 63440:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_delete_blob() != 24901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_download() != 14779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_export() != 23697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_get_collection() != 57130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_has() != 1301:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_list() != 9714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_list_collections() != 22274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_list_incomplete() != 31740:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_read_at_to_bytes() != 43209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_read_to_bytes() != 13624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_share() != 35831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_size() != 20254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_status() != 34093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_blobs_write_to_path() != 47517:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_blobs() != 52509:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_is_empty() != 40621:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_len() != 10206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_links() != 56034:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_names() != 28871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_collection_push() != 22031:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connecting_alpn() != 45347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connecting_connect() != 64341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_accept_bi() != 10996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_accept_uni() != 17891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_alpn() != 53975:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_close() != 61009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_close_reason() != 44737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_closed() != 30404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_datagram_send_buffer_space() != 52904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_max_datagram_size() != 49257:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_open_bi() != 34801:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_open_uni() != 36079:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_read_datagram() != 23201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_remote_node_id() != 59577:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_rtt() != 61654:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_send_datagram() != 105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_bii_stream() != 13576:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_uni_stream() != 26642:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_set_receive_window() != 27731:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connection_stable_id() != 28186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connectiontype_as_direct() != 47530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connectiontype_as_mixed() != 49068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connectiontype_as_relay() != 6121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_connectiontype_type() != 54998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_directaddrinfo_addr() != 20100:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_control() != 35048:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_payload() != 12406:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_directaddrinfo_latency() != 7414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_close_me() != 13449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_delete() != 54552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_export_file() != 16067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_get_download_policy() != 44884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_get_exact() != 20423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_get_many() != 53909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_get_one() != 18797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_get_sync_peers() != 59505:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_id() != 53450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_import_file() != 52327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_leave() != 40204:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_set_bytes() != 32483:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_set_download_policy() != 18200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_set_hash() != 30875:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_share() != 59706:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_start_sync() != 54450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_status() != 30558:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_doc_subscribe() != 59807:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docexportfilecallback_progress() != 53186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_abort() != 34476:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_found() != 23982:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_progress() != 44802:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docexportprogress_type() != 11215:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportfilecallback_progress() != 55347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_abort() != 35952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_all_done() != 35787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_found() != 6030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_ingest_done() != 36:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_progress() != 19927:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docimportprogress_type() != 48401:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_create() != 54486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_drop_doc() != 5864:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_join() != 38489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_join_and_subscribe() != 41379:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_list() != 23866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_docs_open() != 45928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadcallback_progress() != 21881:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_abort() != 6879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_all_done() != 4219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_done() != 21859:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found() != 47836:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_hash_seq() != 14451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_local() != 47262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_progress() != 16155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_downloadprogress_type() != 60534:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_endpoint_connect() != 29734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_endpoint_node_id() != 54517:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_author() != 39787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_content_hash() != 26949:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_content_len() != 40073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_key() != 10200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_namespace() != 25213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_entry_timestamp() != 38377:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_filterkind_matches() != 24522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_gossip_subscribe() != 6414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_gossipmessagecallback_on_message() != 49150:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_hash_equal() != 28210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_hash_to_bytes() != 26394:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_hash_to_hex() != 52108:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_authors() != 61389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_blobs() != 50340:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_docs() != 17607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_gossip() != 58884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_net() != 41953:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_node() != 12499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroh_tags() != 59606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_iroherror_message() != 31085:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_content_ready() != 6578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_local() != 27496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_remote() != 38454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_down() != 27752:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_up() != 44203:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_as_sync_finished() != 27893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_liveevent_type() != 30099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_as_error() != 9059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_as_joined() != 39463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_down() != 19092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_up() != 3541:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_as_received() != 6044:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_message_type() != 75:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_add_node_addr() != 17723:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_home_relay() != 3492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_node_addr() != 60712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_node_id() != 35201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_remote_info() != 60537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_net_remote_info_list() != 15919:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_node_endpoint() != 6829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_node_shutdown() != 49624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_node_stats() != 13439:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_node_status() != 21889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodeaddr_direct_addresses() != 23787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodeaddr_equal() != 19664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodeaddr_relay_url() != 34772:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodestatus_listen_addrs() != 54436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodestatus_node_addr() != 12507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodestatus_rpc_addr() != 20002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodestatus_version() != 3183:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_nodeticket_node_addr() != 3397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_protocolcreator_create() != 33391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_protocolhandler_accept() != 45944:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_protocolhandler_shutdown() != 55574:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_publickey_equal() != 8690:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_publickey_fmt_short() != 31871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_publickey_to_bytes() != 22449:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_query_limit() != 23235:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_query_offset() != 14460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_rangespec_is_all() != 51737:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_rangespec_is_empty() != 38175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_id() != 17291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_read() != 25331:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_read_exact() != 37269:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_read_to_end() != 31754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_received_reset() != 12049:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_recvstream_stop() != 5360:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_finish() != 32400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_id() != 905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_priority() != 33897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_reset() != 34438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_set_priority() != 1968:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_stopped() != 40814:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_write() != 61923:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sendstream_write_all() != 5755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sender_broadcast() != 42694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sender_broadcast_neighbors() != 14000:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_sender_cancel() != 24357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_subscribecallback_event() != 35520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_tags_delete() != 17755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_method_tags_list() != 16151:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_author_from_string() != 63158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_authorid_from_string() != 47849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_blobdownloadoptions_new() != 46030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_blobticket_new() != 29763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_collection_new() != 3798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_docticket_new() != 29537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything() != 35143:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything_except() != 21211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing() != 16928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing_except() != 12041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_filterkind_exact() != 13432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_filterkind_prefix() != 42338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_hash_from_bytes() != 13104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_hash_from_string() != 23453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_hash_new() != 30613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_iroh_memory() != 49939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_iroh_memory_with_options() != 60437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent() != 42623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent_with_options() != 60788:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_nodeaddr_new() != 5759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_nodeticket_new() != 8609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_nodeticket_parse() != 16834:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_publickey_from_bytes() != 64011:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_publickey_from_string() != 42207:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_all() != 34328:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_author() != 17803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_author_key_exact() != 38571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_author_key_prefix() != 48731:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_key_exact() != 17481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_key_prefix() != 35279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key() != 58221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_exact() != 6734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_prefix() != 8914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_readatlen_all() != 34450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_readatlen_at_most() != 62414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_readatlen_exact() != 12971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_settagoption_auto() != 50496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_settagoption_named() != 33009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_wrapoption_no_wrap() != 59800:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iroh_ffi_checksum_constructor_wrapoption_wrap() != 6667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_ADD_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_BLOB_PROVIDE_EVENT_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_DOC_EXPORT_FILE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_DOC_IMPORT_FILE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_DOWNLOAD_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_GOSSIP_MESSAGE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_CREATOR_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,ctypes.POINTER(ctypes.c_void_p),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_SUBSCRIBE_CALLBACK_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
class _UniffiVTableCallbackInterfaceAddCallback(ctypes.Structure):
    _fields_ = [
        ("progress", _UNIFFI_CALLBACK_INTERFACE_ADD_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceBlobProvideEventCallback(ctypes.Structure):
    _fields_ = [
        ("blob_event", _UNIFFI_CALLBACK_INTERFACE_BLOB_PROVIDE_EVENT_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceDocExportFileCallback(ctypes.Structure):
    _fields_ = [
        ("progress", _UNIFFI_CALLBACK_INTERFACE_DOC_EXPORT_FILE_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceDocImportFileCallback(ctypes.Structure):
    _fields_ = [
        ("progress", _UNIFFI_CALLBACK_INTERFACE_DOC_IMPORT_FILE_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceDownloadCallback(ctypes.Structure):
    _fields_ = [
        ("progress", _UNIFFI_CALLBACK_INTERFACE_DOWNLOAD_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceGossipMessageCallback(ctypes.Structure):
    _fields_ = [
        ("on_message", _UNIFFI_CALLBACK_INTERFACE_GOSSIP_MESSAGE_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceProtocolCreator(ctypes.Structure):
    _fields_ = [
        ("create", _UNIFFI_CALLBACK_INTERFACE_PROTOCOL_CREATOR_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceProtocolHandler(ctypes.Structure):
    _fields_ = [
        ("accept", _UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD0),
        ("shutdown", _UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceSubscribeCallback(ctypes.Structure):
    _fields_ = [
        ("event", _UNIFFI_CALLBACK_INTERFACE_SUBSCRIBE_CALLBACK_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_iroh_ffi_fn_clone_addcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_addcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_addcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_addcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_addcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceAddCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_addcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_addcallback_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addcallback_progress.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_addprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_addprogress.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_addprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_addprogress.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_author.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_author_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_author_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_author_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_author_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_author_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_author_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_authorid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_authorid.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_authorid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_authorid.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_authorid_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_authorid_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_authors.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_authors.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_authors.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_create.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_create.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_default.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_default.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_delete.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_export.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_export.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_import.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_import.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_import_author.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_import_author.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_authors_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_bistream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_bistream.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_bistream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_bistream.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_recv.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_recv.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_send.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_send.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobdownloadoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobdownloadoptions.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobdownloadoptions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobdownloadoptions.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobdownloadoptions_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobdownloadoptions_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideevent.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideevent.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_client_connected.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_client_connected.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_get_request_received.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_get_request_received.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_tagged_blob_added.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_tagged_blob_added.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_aborted.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_aborted.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_blob_completed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_blob_completed.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_completed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_completed.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_hash_seq_started.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_hash_seq_started.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideeventcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideeventcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideeventcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideeventcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_blobprovideeventcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceBlobProvideEventCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_blobprovideeventcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideeventcallback_blob_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideeventcallback_blob_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobstatus.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobstatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobstatus.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobticket.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobticket.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobticket_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobticket_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_as_download_options.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_as_download_options.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_format.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_format.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_node_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_recursive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_recursive.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_blobs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_blobs.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes_named.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes_named.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_from_path.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_from_path.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_create_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_create_collection.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_delete_blob.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_delete_blob.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_download.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_download.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_export.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_export.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_get_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_get_collection.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_has.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_has.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_collections.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_collections.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_incomplete.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_incomplete.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_at_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_at_to_bytes.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_to_bytes.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_share.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_share.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_size.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_status.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_write_to_path.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_blobs_write_to_path.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_collection.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_collection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_collection.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_collection_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_collection_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_blobs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_links.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_links.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_names.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_names.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_push.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_collection_push.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_clone_connecting.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_connecting.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_connecting.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_connecting.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connecting_alpn.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connecting_alpn.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connecting_connect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connecting_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_connection.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_connection.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_bi.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_bi.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_uni.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_uni.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_alpn.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_alpn.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close_reason.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close_reason.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_closed.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_closed.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_datagram_send_buffer_space.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_datagram_send_buffer_space.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_max_datagram_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_max_datagram_size.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_bi.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_bi.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_uni.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_uni.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_read_datagram.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_read_datagram.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_remote_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_remote_node_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_rtt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_rtt.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_send_datagram.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_send_datagram.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_bii_stream.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_bii_stream.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_uni_stream.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_uni_stream.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_receive_window.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_receive_window.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_stable_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connection_stable_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_connectiontype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_connectiontype.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_connectiontype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_connectiontype.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_direct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_direct.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_mixed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_mixed.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_relay.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_relay.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_directaddrinfo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_directaddrinfo.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_directaddrinfo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_directaddrinfo.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_addr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_control.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_control.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_payload.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_payload.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_latency.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_latency.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_doc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_doc.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_doc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_doc.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_close_me.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_close_me.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_delete.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_export_file.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_export_file.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_download_policy.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_download_policy.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_exact.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_exact.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_many.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_many.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_one.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_one.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_sync_peers.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_sync_peers.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_import_file.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_import_file.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_leave.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_leave.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_bytes.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_download_policy.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_download_policy.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_share.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_share.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_start_sync.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_start_sync.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_status.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_doc_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportfilecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportfilecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docexportfilecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docexportfilecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docexportfilecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceDocExportFileCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docexportfilecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportfilecallback_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportfilecallback_progress.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportprogress.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docexportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docexportprogress.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportfilecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportfilecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docimportfilecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docimportfilecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docimportfilecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceDocImportFileCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docimportfilecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportfilecallback_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportfilecallback_progress.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportprogress.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docimportprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docimportprogress.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_ingest_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_ingest_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_docticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docticket.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docticket.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_docticket_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_docticket_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_docticket_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docticket_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_docs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_docs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_docs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_docs.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_create.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_create.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_drop_doc.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_drop_doc.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_join.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_join.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_join_and_subscribe.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_join_and_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_open.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_docs_open.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadcallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadcallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_downloadcallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceDownloadCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_downloadcallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadcallback_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadcallback_progress.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadpolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadpolicy.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadpolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadpolicy.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything_except.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything_except.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing_except.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing_except.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadprogress.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadprogress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_downloadprogress.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_abort.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_abort.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_all_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_all_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_done.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_done.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_hash_seq.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_hash_seq.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_local.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_local.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_progress.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_progress.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_endpoint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_endpoint.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_endpoint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_endpoint.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_node_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_entry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_entry.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_entry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_entry.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_author.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_len.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_len.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_namespace.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_namespace.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_timestamp.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_entry_timestamp.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_filterkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_filterkind.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_filterkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_filterkind.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_exact.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_prefix.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_filterkind_matches.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_filterkind_matches.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_clone_gossip.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_gossip.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_gossip.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_gossip.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_gossip_subscribe.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_gossip_subscribe.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_gossipmessagecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_gossipmessagecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_gossipmessagecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_gossipmessagecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_gossipmessagecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceGossipMessageCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_gossipmessagecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_gossipmessagecallback_on_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_gossipmessagecallback_on_message.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_hash.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_hash_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_iroh.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_iroh.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_iroh.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_iroh.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory_with_options.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory_with_options.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent.argtypes = (
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent_with_options.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent_with_options.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_authors.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_authors.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_blobs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_blobs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_docs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_docs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_gossip.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_gossip.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_net.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_net.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_node.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_iroherror.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_iroherror.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_iroherror.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_iroherror.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_liveevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_liveevent.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_liveevent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_liveevent.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_content_ready.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_content_ready.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_local.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_local.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_remote.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_remote.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_down.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_down.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_up.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_up.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_sync_finished.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_sync_finished.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_message.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_error.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_error.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_joined.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_joined.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_down.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_down.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_up.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_up.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_received.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_received.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_message_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_message_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_net.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_net.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_net.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_net.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_net_add_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_add_node_addr.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_net_home_relay.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_home_relay.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_net_node_addr.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_node_addr.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_net_node_id.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_node_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_node.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_node.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_node_endpoint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_node_endpoint.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_node_shutdown.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_node_shutdown.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_node_stats.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_node_stats.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_node_status.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_node_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeaddr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeaddr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_nodeaddr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_nodeaddr.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeaddr_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeaddr_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_direct_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_direct_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_relay_url.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_relay_url.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodestatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodestatus.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_nodestatus.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_nodestatus.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_listen_addrs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_listen_addrs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_node_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_rpc_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_rpc_addr.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_version.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeticket.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_nodeticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_nodeticket.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_parse.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_parse.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_node_addr.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_node_addr.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolcreator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolcreator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_protocolcreator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_protocolcreator.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolcreator.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceProtocolCreator),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolcreator.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolcreator_create.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolcreator_create.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolhandler.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolhandler.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_protocolhandler.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_protocolhandler.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolhandler.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceProtocolHandler),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolhandler.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_accept.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_accept.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_shutdown.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_shutdown.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_publickey.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_equal.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_equal.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_fmt_short.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_fmt_short.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_clone_query.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_query.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_query.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_query.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_all.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_exact.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_prefix.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_exact.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_prefix.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_exact.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_prefix.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_prefix.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_method_query_limit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_query_limit.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_method_query_offset.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_query_offset.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_rangespec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_rangespec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_rangespec.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_rangespec.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_all.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_all.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_empty.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_empty.restype = ctypes.c_int8
_UniffiLib.uniffi_iroh_ffi_fn_clone_readatlen.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_readatlen.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_readatlen.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_readatlen.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_all.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_all.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_at_most.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_at_most.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_exact.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_exact.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_recvstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_recvstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_recvstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_recvstream.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_id.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_exact.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_exact.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_to_end.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_to_end.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_received_reset.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_received_reset.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_stop.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_sendstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_sendstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_sendstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_sendstream.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_finish.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_finish.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_id.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_priority.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_priority.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_reset.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_reset.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_set_priority.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_set_priority.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_stopped.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_stopped.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write_all.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write_all.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_sender.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_sender.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_sender.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_sender.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast_neighbors.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast_neighbors.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_cancel.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_sender_cancel.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_settagoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_settagoption.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_settagoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_settagoption.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_auto.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_auto.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_named.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_named.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_clone_subscribecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_subscribecallback.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_subscribecallback.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_subscribecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_subscribecallback.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceSubscribeCallback),
)
_UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_subscribecallback.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_subscribecallback_event.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_subscribecallback_event.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_tags.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_tags.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_tags.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_method_tags_delete.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_tags_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_method_tags_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iroh_ffi_fn_method_tags_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_iroh_ffi_fn_clone_wrapoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_clone_wrapoption.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_free_wrapoption.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_free_wrapoption.restype = None
_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_no_wrap.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_no_wrap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_wrap.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_wrap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iroh_ffi_fn_func_key_to_path.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_func_key_to_path.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_func_path_to_key.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_func_path_to_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iroh_ffi_fn_func_set_log_level.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iroh_ffi_fn_func_set_log_level.restype = None
_UniffiLib.ffi_iroh_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_iroh_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_iroh_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_iroh_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_iroh_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iroh_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_iroh_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iroh_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_iroh_ffi_checksum_func_key_to_path.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_func_key_to_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_func_path_to_key.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_func_path_to_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_func_set_log_level.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_func_set_log_level.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addcallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addcallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_addprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_author_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_author_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authorid_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authorid_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_create.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_default.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_default.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_delete.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_export.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_export.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_import.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_import.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_import_author.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_import_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_list.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_authors_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_bistream_recv.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_bistream_recv.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_bistream_send.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_bistream_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_client_connected.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_client_connected.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_get_request_received.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_get_request_received.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_tagged_blob_added.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_tagged_blob_added.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_aborted.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_aborted.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_blob_completed.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_blob_completed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_completed.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_completed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_hash_seq_started.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_hash_seq_started.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_as_transfer_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideevent_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideeventcallback_blob_event.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobprovideeventcallback_blob_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_as_download_options.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_as_download_options.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_format.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_format.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_recursive.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobticket_recursive.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes_named.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_bytes_named.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_from_path.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_add_from_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_create_collection.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_create_collection.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_delete_blob.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_delete_blob.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_download.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_download.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_export.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_export.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_get_collection.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_get_collection.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_has.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_has.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list_collections.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list_collections.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list_incomplete.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_list_incomplete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_read_at_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_read_at_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_read_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_read_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_share.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_share.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_size.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_status.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_write_to_path.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_blobs_write_to_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_blobs.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_blobs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_is_empty.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_len.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_links.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_links.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_names.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_names.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_push.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_collection_push.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connecting_alpn.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connecting_alpn.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connecting_connect.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connecting_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_accept_bi.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_accept_bi.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_accept_uni.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_accept_uni.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_alpn.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_alpn.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_close.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_close.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_close_reason.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_close_reason.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_closed.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_closed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_datagram_send_buffer_space.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_datagram_send_buffer_space.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_max_datagram_size.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_max_datagram_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_open_bi.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_open_bi.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_open_uni.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_open_uni.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_read_datagram.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_read_datagram.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_remote_node_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_remote_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_rtt.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_rtt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_send_datagram.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_send_datagram.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_bii_stream.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_bii_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_uni_stream.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_max_concurrent_uni_stream.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_receive_window.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_set_receive_window.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_stable_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connection_stable_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_direct.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_direct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_mixed.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_mixed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_relay.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_as_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_connectiontype_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_control.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_control.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_payload.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_last_payload.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_latency.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_directaddrinfo_latency.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_close_me.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_close_me.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_delete.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_export_file.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_export_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_download_policy.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_download_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_many.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_many.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_one.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_one.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_sync_peers.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_get_sync_peers.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_import_file.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_import_file.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_leave.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_leave.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_download_policy.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_download_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_set_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_share.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_share.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_start_sync.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_start_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_status.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_subscribe.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_doc_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportfilecallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportfilecallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docexportprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportfilecallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportfilecallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_ingest_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_ingest_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docimportprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_create.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_drop_doc.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_drop_doc.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_join.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_join.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_join_and_subscribe.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_join_and_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_list.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_open.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_docs_open.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadcallback_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadcallback_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_abort.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_abort.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_all_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_all_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_done.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_done.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_hash_seq.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_hash_seq.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_local.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_found_local.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_progress.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_as_progress.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_downloadprogress_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_endpoint_connect.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_endpoint_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_endpoint_node_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_endpoint_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_author.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_content_hash.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_content_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_content_len.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_content_len.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_key.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_namespace.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_namespace.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_timestamp.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_entry_timestamp.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_filterkind_matches.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_filterkind_matches.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_gossip_subscribe.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_gossip_subscribe.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_gossipmessagecallback_on_message.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_gossipmessagecallback_on_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_to_hex.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_hash_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_authors.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_authors.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_blobs.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_blobs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_docs.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_docs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_gossip.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_gossip.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_net.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_net.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_node.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_tags.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroh_tags.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroherror_message.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_iroherror_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_content_ready.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_content_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_local.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_local.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_remote.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_insert_remote.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_down.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_down.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_up.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_neighbor_up.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_sync_finished.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_as_sync_finished.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_liveevent_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_error.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_error.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_joined.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_joined.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_down.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_down.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_up.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_neighbor_up.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_received.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_as_received.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_type.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_message_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_add_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_add_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_home_relay.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_home_relay.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_node_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_remote_info.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_remote_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_remote_info_list.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_net_remote_info_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_endpoint.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_endpoint.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_shutdown.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_stats.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_stats.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_status.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_node_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_direct_addresses.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_direct_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_relay_url.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeaddr_relay_url.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_listen_addrs.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_listen_addrs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_rpc_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_rpc_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_version.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodestatus_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeticket_node_addr.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_nodeticket_node_addr.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolcreator_create.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolcreator_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolhandler_accept.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolhandler_accept.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolhandler_shutdown.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_protocolhandler_shutdown.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_equal.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_equal.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_fmt_short.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_fmt_short.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_query_limit.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_query_limit.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_query_offset.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_query_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_rangespec_is_all.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_rangespec_is_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_rangespec_is_empty.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_rangespec_is_empty.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read_to_end.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_read_to_end.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_received_reset.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_received_reset.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_stop.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_recvstream_stop.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_finish.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_id.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_priority.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_priority.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_reset.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_reset.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_set_priority.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_set_priority.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_stopped.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_stopped.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_write.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_write.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_write_all.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sendstream_write_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_broadcast.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_broadcast_neighbors.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_broadcast_neighbors.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_cancel.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_sender_cancel.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_subscribecallback_event.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_subscribecallback_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_tags_delete.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_tags_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_method_tags_list.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_method_tags_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_author_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_author_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_authorid_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_authorid_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_blobdownloadoptions_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_blobdownloadoptions_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_blobticket_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_blobticket_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_collection_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_collection_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_docticket_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_docticket_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything_except.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_everything_except.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing_except.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_downloadpolicy_nothing_except.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_filterkind_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_filterkind_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_filterkind_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_filterkind_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_hash_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_memory.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_memory.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_memory_with_options.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_memory_with_options.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent_with_options.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_iroh_persistent_with_options.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeaddr_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeaddr_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeticket_new.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeticket_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeticket_parse.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_nodeticket_parse.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_publickey_from_string.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_publickey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_all.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author_key_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author_key_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author_key_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_author_key_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_key_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_key_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_key_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_key_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_prefix.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_query_single_latest_per_key_prefix.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_all.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_all.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_at_most.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_at_most.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_exact.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_readatlen_exact.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_settagoption_auto.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_settagoption_auto.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_settagoption_named.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_settagoption_named.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_wrapoption_no_wrap.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_wrapoption_no_wrap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_wrapoption_wrap.argtypes = (
)
_UniffiLib.uniffi_iroh_ffi_checksum_constructor_wrapoption_wrap.restype = ctypes.c_uint16
_UniffiLib.ffi_iroh_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_iroh_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

# The Timestamp type.
Timestamp = datetime.datetime

# There is a loss of precision when converting from Rust timestamps,
# which are accurate to the nanosecond,
# to Python datetimes, which have a variable precision due to the use of float as representation.
class _UniffiConverterTimestamp(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_i64()
        microseconds = buf.read_u32() / 1000
        # Use fromtimestamp(0) then add the seconds using a timedelta.  This
        # ensures that we get OverflowError rather than ValueError when
        # seconds is too large.
        if seconds >= 0:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) + datetime.timedelta(seconds=seconds, microseconds=microseconds)
        else:
            return datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc) - datetime.timedelta(seconds=-seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        if value >= datetime.datetime.fromtimestamp(0, datetime.timezone.utc):
            sign = 1
            delta = value - datetime.datetime.fromtimestamp(0, datetime.timezone.utc)
        else:
            sign = -1
            delta = datetime.datetime.fromtimestamp(0, datetime.timezone.utc) - value

        seconds = delta.seconds + delta.days * 24 * 3600
        nanoseconds = delta.microseconds * 1000
        buf.write_i64(sign * seconds)
        buf.write_u32(nanoseconds)

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class _UniffiConverterDuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_u64()
        microseconds = buf.read_u32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        seconds = value.seconds + value.days * 24 * 3600
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        buf.write_i64(seconds)
        buf.write_u32(nanoseconds)



class AddCallback(typing.Protocol):
    """
    The `progress` method will be called for each `AddProgress` event that is
    emitted during a `node.blobs_add_from_path`. Use the `AddProgress.type()`
    method to check the `AddProgressType`
    """

    def progress(self, progress: "AddProgress"):
        raise NotImplementedError


class AddCallbackImpl:
    """
    The `progress` method will be called for each `AddProgress` event that is
    emitted during a `node.blobs_add_from_path`. Use the `AddProgress.type()`
    method to check the `AddProgressType`
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_addcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_addcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def progress(self, progress: "AddProgress") -> None:

        _UniffiConverterTypeAddProgress.check_lower(progress)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_addcallback_progress(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddProgress.lower(progress)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )


# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplAddCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_ADD_CALLBACK_METHOD0
    def progress(
            uniffi_handle,
            progress,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAddCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAddProgress.lift(progress), )
            method = uniffi_obj.progress
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeAddCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceAddCallback(
        progress,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_addcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeAddCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return AddCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: AddCallback):
        pass

    @staticmethod
    def lower(value: AddCallback):
        return _UniffiConverterTypeAddCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AddProgressProtocol(typing.Protocol):
    """
    Progress updates for the add operation.
    """

    def as_abort(self, ):
        """
        Return the `AddProgressAbort`
        """

        raise NotImplementedError
    def as_all_done(self, ):
        """
        Return the `AddAllDone`
        """

        raise NotImplementedError
    def as_done(self, ):
        """
        Return the `AddProgressDone` event
        """

        raise NotImplementedError
    def as_found(self, ):
        """
        Return the `AddProgressFound` event
        """

        raise NotImplementedError
    def as_progress(self, ):
        """
        Return the `AddProgressProgress` event
        """

        raise NotImplementedError
    def type(self, ):
        """
        Get the type of event
        """

        raise NotImplementedError


class AddProgress:
    """
    Progress updates for the add operation.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_addprogress, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_addprogress, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "AddProgressAbort":
        """
        Return the `AddProgressAbort`
        """

        return _UniffiConverterTypeAddProgressAbort.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_abort,self._uniffi_clone_pointer(),)
        )





    def as_all_done(self, ) -> "AddProgressAllDone":
        """
        Return the `AddAllDone`
        """

        return _UniffiConverterTypeAddProgressAllDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_all_done,self._uniffi_clone_pointer(),)
        )





    def as_done(self, ) -> "AddProgressDone":
        """
        Return the `AddProgressDone` event
        """

        return _UniffiConverterTypeAddProgressDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_done,self._uniffi_clone_pointer(),)
        )





    def as_found(self, ) -> "AddProgressFound":
        """
        Return the `AddProgressFound` event
        """

        return _UniffiConverterTypeAddProgressFound.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_found,self._uniffi_clone_pointer(),)
        )





    def as_progress(self, ) -> "AddProgressProgress":
        """
        Return the `AddProgressProgress` event
        """

        return _UniffiConverterTypeAddProgressProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_as_progress,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "AddProgressType":
        """
        Get the type of event
        """

        return _UniffiConverterTypeAddProgressType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_addprogress_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAddProgress:

    @staticmethod
    def lift(value: int):
        return AddProgress._make_instance_(value)

    @staticmethod
    def check_lower(value: AddProgress):
        if not isinstance(value, AddProgress):
            raise TypeError("Expected AddProgress instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AddProgressProtocol):
        if not isinstance(value, AddProgress):
            raise TypeError("Expected AddProgress instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddProgressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AuthorProtocol(typing.Protocol):
    """
    Author key to insert entries in a document

    Internally, an author is a `SigningKey` which is used to sign entries.
    """

    def id(self, ):
        """
        Get the [`AuthorId`] of this Author
        """

        raise NotImplementedError


class Author:
    """
    Author key to insert entries in a document

    Internally, an author is a `SigningKey` which is used to sign entries.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_author, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_author, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_string(cls, str: "str"):
        """
        Get an [`Author`] from a String
        """

        _UniffiConverterString.check_lower(str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_author_from_string,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def id(self, ) -> "AuthorId":
        """
        Get the [`AuthorId`] of this Author
        """

        return _UniffiConverterTypeAuthorId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_author_id,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_author_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAuthor:

    @staticmethod
    def lift(value: int):
        return Author._make_instance_(value)

    @staticmethod
    def check_lower(value: Author):
        if not isinstance(value, Author):
            raise TypeError("Expected Author instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AuthorProtocol):
        if not isinstance(value, Author):
            raise TypeError("Expected Author instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AuthorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AuthorIdProtocol(typing.Protocol):
    """
    Identifier for an [`Author`]
    """

    def equal(self, other: "AuthorId"):
        """
        Returns true when both AuthorId's have the same value
        """

        raise NotImplementedError


class AuthorId:
    """
    Identifier for an [`Author`]
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_authorid, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_authorid, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_string(cls, str: "str"):
        """
        Get an [`AuthorId`] from a String.
        """

        _UniffiConverterString.check_lower(str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_authorid_from_string,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def equal(self, other: "AuthorId") -> "bool":
        """
        Returns true when both AuthorId's have the same value
        """

        _UniffiConverterTypeAuthorId.check_lower(other)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_equal,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAuthorId.lower(other))
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_authorid_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAuthorId:

    @staticmethod
    def lift(value: int):
        return AuthorId._make_instance_(value)

    @staticmethod
    def check_lower(value: AuthorId):
        if not isinstance(value, AuthorId):
            raise TypeError("Expected AuthorId instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AuthorIdProtocol):
        if not isinstance(value, AuthorId):
            raise TypeError("Expected AuthorId instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AuthorIdProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AuthorsProtocol(typing.Protocol):
    """
    Iroh authors client.
    """

    def create(self, ):
        """
        Create a new document author.

        You likely want to save the returned [`AuthorId`] somewhere so that you can use this author
        again.

        If you need only a single author, use [`Self::default`].
        """

        raise NotImplementedError
    def default(self, ):
        """
        Returns the default document author of this node.

        On persistent nodes, the author is created on first start and its public key is saved
        in the data directory.

        The default author can be set with [`Self::set_default`].
        """

        raise NotImplementedError
    def delete(self, author: "AuthorId"):
        """
        Deletes the given author by id.

        Warning: This permanently removes this author.
        """

        raise NotImplementedError
    def export(self, author: "AuthorId"):
        """
        Export the given author.

        Warning: This contains sensitive data.
        """

        raise NotImplementedError
    def _import(self, author: "Author"):
        """
        Import the given author.

        Warning: This contains sensitive data.
        """

        raise NotImplementedError
    def import_author(self, author: "Author"):
        """
        Import the given author.

        Warning: This contains sensitive data.
        `import` is reserved in python.
        """

        raise NotImplementedError
    def list(self, ):
        """
        List all the AuthorIds that exist on this node.
        """

        raise NotImplementedError


class Authors:
    """
    Iroh authors client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_authors, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_authors, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def create(self, ) -> "AuthorId":
        """
        Create a new document author.

        You likely want to save the returned [`AuthorId`] somewhere so that you can use this author
        again.

        If you need only a single author, use [`Self::default`].
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_create(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAuthorId.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def default(self, ) -> "AuthorId":
        """
        Returns the default document author of this node.

        On persistent nodes, the author is created on first start and its public key is saved
        in the data directory.

        The default author can be set with [`Self::set_default`].
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_default(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAuthorId.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def delete(self, author: "AuthorId") -> None:

        """
        Deletes the given author by id.

        Warning: This permanently removes this author.
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def export(self, author: "AuthorId") -> "Author":
        """
        Export the given author.

        Warning: This contains sensitive data.
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_export(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAuthor.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def _import(self, author: "Author") -> "AuthorId":
        """
        Import the given author.

        Warning: This contains sensitive data.
        """

        _UniffiConverterTypeAuthor.check_lower(author)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_import(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthor.lower(author)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAuthorId.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def import_author(self, author: "Author") -> "AuthorId":
        """
        Import the given author.

        Warning: This contains sensitive data.
        `import` is reserved in python.
        """

        _UniffiConverterTypeAuthor.check_lower(author)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_import_author(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthor.lower(author)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAuthorId.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list(self, ) -> "typing.List[AuthorId]":
        """
        List all the AuthorIds that exist on this node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_authors_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeAuthorId.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeAuthors:

    @staticmethod
    def lift(value: int):
        return Authors._make_instance_(value)

    @staticmethod
    def check_lower(value: Authors):
        if not isinstance(value, Authors):
            raise TypeError("Expected Authors instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AuthorsProtocol):
        if not isinstance(value, Authors):
            raise TypeError("Expected Authors instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AuthorsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BiStreamProtocol(typing.Protocol):
    def recv(self, ):
        raise NotImplementedError
    def send(self, ):
        raise NotImplementedError


class BiStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_bistream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_bistream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def recv(self, ) -> "RecvStream":
        return _UniffiConverterTypeRecvStream.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_recv,self._uniffi_clone_pointer(),)
        )





    def send(self, ) -> "SendStream":
        return _UniffiConverterTypeSendStream.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_bistream_send,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBiStream:

    @staticmethod
    def lift(value: int):
        return BiStream._make_instance_(value)

    @staticmethod
    def check_lower(value: BiStream):
        if not isinstance(value, BiStream):
            raise TypeError("Expected BiStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BiStreamProtocol):
        if not isinstance(value, BiStream):
            raise TypeError("Expected BiStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BiStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobDownloadOptionsProtocol(typing.Protocol):
    """
    Options to download  data specified by the hash.
    """

    pass


class BlobDownloadOptions:
    """
    Options to download  data specified by the hash.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, format: "BlobFormat",nodes: "typing.List[NodeAddr]",tag: "SetTagOption"):
        """
        Create a BlobDownloadRequest
        """

        _UniffiConverterTypeBlobFormat.check_lower(format)
        
        _UniffiConverterSequenceTypeNodeAddr.check_lower(nodes)
        
        _UniffiConverterTypeSetTagOption.check_lower(tag)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobdownloadoptions_new,
        _UniffiConverterTypeBlobFormat.lower(format),
        _UniffiConverterSequenceTypeNodeAddr.lower(nodes),
        _UniffiConverterTypeSetTagOption.lower(tag))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobdownloadoptions, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobdownloadoptions, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeBlobDownloadOptions:

    @staticmethod
    def lift(value: int):
        return BlobDownloadOptions._make_instance_(value)

    @staticmethod
    def check_lower(value: BlobDownloadOptions):
        if not isinstance(value, BlobDownloadOptions):
            raise TypeError("Expected BlobDownloadOptions instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlobDownloadOptionsProtocol):
        if not isinstance(value, BlobDownloadOptions):
            raise TypeError("Expected BlobDownloadOptions instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobDownloadOptionsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobProvideEventProtocol(typing.Protocol):
    """
    Events emitted by the provider informing about the current status.
    """

    def as_client_connected(self, ):
        """
        Return the `ClientConnected` event
        """

        raise NotImplementedError
    def as_get_request_received(self, ):
        """
        Return the `GetRequestReceived` event
        """

        raise NotImplementedError
    def as_tagged_blob_added(self, ):
        """
        Return the `TaggedBlobAdded` event
        """

        raise NotImplementedError
    def as_transfer_aborted(self, ):
        """
        Return the `TransferAborted` event
        """

        raise NotImplementedError
    def as_transfer_blob_completed(self, ):
        """
        Return the `TransferBlobCompleted` event
        """

        raise NotImplementedError
    def as_transfer_completed(self, ):
        """
        Return the `TransferCompleted` event
        """

        raise NotImplementedError
    def as_transfer_hash_seq_started(self, ):
        """
        Return the `TransferHashSeqStarted` event
        """

        raise NotImplementedError
    def as_transfer_progress(self, ):
        """
        Return the `TransferProgress` event
        """

        raise NotImplementedError
    def type(self, ):
        """
        Get the type of event
        """

        raise NotImplementedError


class BlobProvideEvent:
    """
    Events emitted by the provider informing about the current status.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideevent, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideevent, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_client_connected(self, ) -> "ClientConnected":
        """
        Return the `ClientConnected` event
        """

        return _UniffiConverterTypeClientConnected.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_client_connected,self._uniffi_clone_pointer(),)
        )





    def as_get_request_received(self, ) -> "GetRequestReceived":
        """
        Return the `GetRequestReceived` event
        """

        return _UniffiConverterTypeGetRequestReceived.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_get_request_received,self._uniffi_clone_pointer(),)
        )





    def as_tagged_blob_added(self, ) -> "TaggedBlobAdded":
        """
        Return the `TaggedBlobAdded` event
        """

        return _UniffiConverterTypeTaggedBlobAdded.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_tagged_blob_added,self._uniffi_clone_pointer(),)
        )





    def as_transfer_aborted(self, ) -> "TransferAborted":
        """
        Return the `TransferAborted` event
        """

        return _UniffiConverterTypeTransferAborted.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_aborted,self._uniffi_clone_pointer(),)
        )





    def as_transfer_blob_completed(self, ) -> "TransferBlobCompleted":
        """
        Return the `TransferBlobCompleted` event
        """

        return _UniffiConverterTypeTransferBlobCompleted.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_blob_completed,self._uniffi_clone_pointer(),)
        )





    def as_transfer_completed(self, ) -> "TransferCompleted":
        """
        Return the `TransferCompleted` event
        """

        return _UniffiConverterTypeTransferCompleted.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_completed,self._uniffi_clone_pointer(),)
        )





    def as_transfer_hash_seq_started(self, ) -> "TransferHashSeqStarted":
        """
        Return the `TransferHashSeqStarted` event
        """

        return _UniffiConverterTypeTransferHashSeqStarted.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_hash_seq_started,self._uniffi_clone_pointer(),)
        )





    def as_transfer_progress(self, ) -> "TransferProgress":
        """
        Return the `TransferProgress` event
        """

        return _UniffiConverterTypeTransferProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_as_transfer_progress,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "BlobProvideEventType":
        """
        Get the type of event
        """

        return _UniffiConverterTypeBlobProvideEventType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideevent_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBlobProvideEvent:

    @staticmethod
    def lift(value: int):
        return BlobProvideEvent._make_instance_(value)

    @staticmethod
    def check_lower(value: BlobProvideEvent):
        if not isinstance(value, BlobProvideEvent):
            raise TypeError("Expected BlobProvideEvent instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlobProvideEventProtocol):
        if not isinstance(value, BlobProvideEvent):
            raise TypeError("Expected BlobProvideEvent instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobProvideEventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobProvideEventCallback(typing.Protocol):
    """
    The `progress` method will be called for each `BlobProvideEvent` event that is
    emitted from the iroh node while the callback is registered. Use the `BlobProvideEvent.type()`
    method to check the `BlobProvideEventType`
    """

    def blob_event(self, event: "BlobProvideEvent"):
        raise NotImplementedError


class BlobProvideEventCallbackImpl:
    """
    The `progress` method will be called for each `BlobProvideEvent` event that is
    emitted from the iroh node while the callback is registered. Use the `BlobProvideEvent.type()`
    method to check the `BlobProvideEventType`
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobprovideeventcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobprovideeventcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def blob_event(self, event: "BlobProvideEvent") -> None:

        _UniffiConverterTypeBlobProvideEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobprovideeventcallback_blob_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeBlobProvideEvent.lower(event)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplBlobProvideEventCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_BLOB_PROVIDE_EVENT_CALLBACK_METHOD0
    def blob_event(
            uniffi_handle,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeBlobProvideEventCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeBlobProvideEvent.lift(event), )
            method = uniffi_obj.blob_event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeBlobProvideEventCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceBlobProvideEventCallback(
        blob_event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_blobprovideeventcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeBlobProvideEventCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return BlobProvideEventCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: BlobProvideEventCallback):
        pass

    @staticmethod
    def lower(value: BlobProvideEventCallback):
        return _UniffiConverterTypeBlobProvideEventCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobProvideEventCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobStatusProtocol(typing.Protocol):
    """
    Status information about a blob.
    """

    pass


class BlobStatus:
    """
    Status information about a blob.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobstatus, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobstatus, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeBlobStatus:

    @staticmethod
    def lift(value: int):
        return BlobStatus._make_instance_(value)

    @staticmethod
    def check_lower(value: BlobStatus):
        if not isinstance(value, BlobStatus):
            raise TypeError("Expected BlobStatus instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlobStatusProtocol):
        if not isinstance(value, BlobStatus):
            raise TypeError("Expected BlobStatus instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobStatusProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobTicketProtocol(typing.Protocol):
    """
    A token containing everything to get a file from the provider.

    It is a single item which can be easily serialized and deserialized.
    """

    def as_download_options(self, ):
        """
        Convert this ticket into input parameters for a call to blobs_download
        """

        raise NotImplementedError
    def format(self, ):
        """
        The [`BlobFormat`] for this ticket.
        """

        raise NotImplementedError
    def hash(self, ):
        """
        The hash of the item this ticket can retrieve.
        """

        raise NotImplementedError
    def node_addr(self, ):
        """
        The [`NodeAddr`] of the provider for this ticket.
        """

        raise NotImplementedError
    def recursive(self, ):
        """
        True if the ticket is for a collection and should retrieve all blobs in it.
        """

        raise NotImplementedError


class BlobTicket:
    """
    A token containing everything to get a file from the provider.

    It is a single item which can be easily serialized and deserialized.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, str: "str"):
        _UniffiConverterString.check_lower(str)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_blobticket_new,
        _UniffiConverterString.lower(str))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobticket, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobticket, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_download_options(self, ) -> "BlobDownloadOptions":
        """
        Convert this ticket into input parameters for a call to blobs_download
        """

        return _UniffiConverterTypeBlobDownloadOptions.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_as_download_options,self._uniffi_clone_pointer(),)
        )





    def format(self, ) -> "BlobFormat":
        """
        The [`BlobFormat`] for this ticket.
        """

        return _UniffiConverterTypeBlobFormat.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_format,self._uniffi_clone_pointer(),)
        )





    def hash(self, ) -> "Hash":
        """
        The hash of the item this ticket can retrieve.
        """

        return _UniffiConverterTypeHash.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_hash,self._uniffi_clone_pointer(),)
        )





    def node_addr(self, ) -> "NodeAddr":
        """
        The [`NodeAddr`] of the provider for this ticket.
        """

        return _UniffiConverterTypeNodeAddr.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_node_addr,self._uniffi_clone_pointer(),)
        )





    def recursive(self, ) -> "bool":
        """
        True if the ticket is for a collection and should retrieve all blobs in it.
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_recursive,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_blobticket_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBlobTicket:

    @staticmethod
    def lift(value: int):
        return BlobTicket._make_instance_(value)

    @staticmethod
    def check_lower(value: BlobTicket):
        if not isinstance(value, BlobTicket):
            raise TypeError("Expected BlobTicket instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlobTicketProtocol):
        if not isinstance(value, BlobTicket):
            raise TypeError("Expected BlobTicket instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobTicketProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BlobsProtocol(typing.Protocol):
    """
    Iroh blobs client.
    """

    def add_bytes(self, bytes: "bytes"):
        """
        Write a blob by passing bytes.
        """

        raise NotImplementedError
    def add_bytes_named(self, bytes: "bytes",name: "str"):
        """
        Write a blob by passing bytes, setting an explicit tag name.
        """

        raise NotImplementedError
    def add_from_path(self, path: "str",in_place: "bool",tag: "SetTagOption",wrap: "WrapOption",cb: "AddCallback"):
        """
        Import a blob from a filesystem path.

        `path` should be an absolute path valid for the file system on which
        the node runs.
        If `in_place` is true, Iroh will assume that the data will not change and will share it in
        place without copying to the Iroh data directory.
        """

        raise NotImplementedError
    def create_collection(self, collection: "Collection",tag: "SetTagOption",tags_to_delete: "typing.List[str]"):
        """
        Create a collection from already existing blobs.

        To automatically clear the tags for the passed in blobs you can set
        `tags_to_delete` on those tags, and they will be deleted once the collection is created.
        """

        raise NotImplementedError
    def delete_blob(self, hash: "Hash"):
        """
        Delete a blob.
        """

        raise NotImplementedError
    def download(self, hash: "Hash",opts: "BlobDownloadOptions",cb: "DownloadCallback"):
        """
        Download a blob from another node and add it to the local database.
        """

        raise NotImplementedError
    def export(self, hash: "Hash",destination: "str",format: "BlobExportFormat",mode: "BlobExportMode"):
        """
        Export a blob from the internal blob store to a path on the node's filesystem.

        `destination` should be a writeable, absolute path on the local node's filesystem.

        If `format` is set to [`ExportFormat::Collection`], and the `hash` refers to a collection,
        all children of the collection will be exported. See [`ExportFormat`] for details.

        The `mode` argument defines if the blob should be copied to the target location or moved out of
        the internal store into the target location. See [`ExportMode`] for details.
        """

        raise NotImplementedError
    def get_collection(self, hash: "Hash"):
        """
        Read the content of a collection
        """

        raise NotImplementedError
    def has(self, hash: "Hash"):
        """
        Check if a blob is completely stored on the node.

        This is just a convenience wrapper around `status` that returns a boolean.
        """

        raise NotImplementedError
    def list(self, ):
        """
        List all complete blobs.

        Note: this allocates for each `BlobListResponse`, if you have many `BlobListReponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        raise NotImplementedError
    def list_collections(self, ):
        """
        List all collections.

        Note: this allocates for each `BlobListCollectionsResponse`, if you have many `BlobListCollectionsResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        raise NotImplementedError
    def list_incomplete(self, ):
        """
        List all incomplete (partial) blobs.

        Note: this allocates for each `BlobListIncompleteResponse`, if you have many `BlobListIncompleteResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        raise NotImplementedError
    def read_at_to_bytes(self, hash: "Hash",offset: "int",len: "ReadAtLen"):
        """
        Read all bytes of single blob at `offset` for length `len`.

        This allocates a buffer for the full length `len`. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_at_to_bytes`].
        """

        raise NotImplementedError
    def read_to_bytes(self, hash: "Hash"):
        """
        Read all bytes of single blob.

        This allocates a buffer for the full blob. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_to_bytes`].
        """

        raise NotImplementedError
    def share(self, hash: "Hash",blob_format: "BlobFormat",ticket_options: "AddrInfoOptions"):
        """
        Create a ticket for sharing a blob from this node.
        """

        raise NotImplementedError
    def size(self, hash: "Hash"):
        """
        Get the size information on a single blob.

        Method only exists in FFI
        """

        raise NotImplementedError
    def status(self, hash: "Hash"):
        """
        Check the storage status of a blob on this node.
        """

        raise NotImplementedError
    def write_to_path(self, hash: "Hash",path: "str"):
        """
        Export the blob contents to a file path
        The `path` field is expected to be the absolute path.
        """

        raise NotImplementedError


class Blobs:
    """
    Iroh blobs client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_blobs, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_blobs, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_bytes(self, bytes: "bytes") -> "BlobAddOutcome":
        """
        Write a blob by passing bytes.
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(bytes)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeBlobAddOutcome.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def add_bytes_named(self, bytes: "bytes",name: "str") -> "BlobAddOutcome":
        """
        Write a blob by passing bytes, setting an explicit tag name.
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        _UniffiConverterString.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_bytes_named(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(bytes),
        _UniffiConverterString.lower(name)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeBlobAddOutcome.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def add_from_path(self, path: "str",in_place: "bool",tag: "SetTagOption",wrap: "WrapOption",cb: "AddCallback") -> None:

        """
        Import a blob from a filesystem path.

        `path` should be an absolute path valid for the file system on which
        the node runs.
        If `in_place` is true, Iroh will assume that the data will not change and will share it in
        place without copying to the Iroh data directory.
        """

        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterBool.check_lower(in_place)
        
        _UniffiConverterTypeSetTagOption.check_lower(tag)
        
        _UniffiConverterTypeWrapOption.check_lower(wrap)
        
        _UniffiConverterTypeAddCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_add_from_path(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(path),
        _UniffiConverterBool.lower(in_place),
        _UniffiConverterTypeSetTagOption.lower(tag),
        _UniffiConverterTypeWrapOption.lower(wrap),
        _UniffiConverterTypeAddCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def create_collection(self, collection: "Collection",tag: "SetTagOption",tags_to_delete: "typing.List[str]") -> "HashAndTag":
        """
        Create a collection from already existing blobs.

        To automatically clear the tags for the passed in blobs you can set
        `tags_to_delete` on those tags, and they will be deleted once the collection is created.
        """

        _UniffiConverterTypeCollection.check_lower(collection)
        
        _UniffiConverterTypeSetTagOption.check_lower(tag)
        
        _UniffiConverterSequenceString.check_lower(tags_to_delete)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_create_collection(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeCollection.lower(collection),
        _UniffiConverterTypeSetTagOption.lower(tag),
        _UniffiConverterSequenceString.lower(tags_to_delete)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeHashAndTag.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def delete_blob(self, hash: "Hash") -> None:

        """
        Delete a blob.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_delete_blob(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def download(self, hash: "Hash",opts: "BlobDownloadOptions",cb: "DownloadCallback") -> None:

        """
        Download a blob from another node and add it to the local database.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterTypeBlobDownloadOptions.check_lower(opts)
        
        _UniffiConverterTypeDownloadCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_download(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterTypeBlobDownloadOptions.lower(opts),
        _UniffiConverterTypeDownloadCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def export(self, hash: "Hash",destination: "str",format: "BlobExportFormat",mode: "BlobExportMode") -> None:

        """
        Export a blob from the internal blob store to a path on the node's filesystem.

        `destination` should be a writeable, absolute path on the local node's filesystem.

        If `format` is set to [`ExportFormat::Collection`], and the `hash` refers to a collection,
        all children of the collection will be exported. See [`ExportFormat`] for details.

        The `mode` argument defines if the blob should be copied to the target location or moved out of
        the internal store into the target location. See [`ExportMode`] for details.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterString.check_lower(destination)
        
        _UniffiConverterTypeBlobExportFormat.check_lower(format)
        
        _UniffiConverterTypeBlobExportMode.check_lower(mode)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_export(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterString.lower(destination),
        _UniffiConverterTypeBlobExportFormat.lower(format),
        _UniffiConverterTypeBlobExportMode.lower(mode)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_collection(self, hash: "Hash") -> "Collection":
        """
        Read the content of a collection
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_get_collection(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeCollection.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def has(self, hash: "Hash") -> "bool":
        """
        Check if a blob is completely stored on the node.

        This is just a convenience wrapper around `status` that returns a boolean.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_has(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list(self, ) -> "typing.List[Hash]":
        """
        List all complete blobs.

        Note: this allocates for each `BlobListResponse`, if you have many `BlobListReponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeHash.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list_collections(self, ) -> "typing.List[CollectionInfo]":
        """
        List all collections.

        Note: this allocates for each `BlobListCollectionsResponse`, if you have many `BlobListCollectionsResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_collections(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeCollectionInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list_incomplete(self, ) -> "typing.List[IncompleteBlobInfo]":
        """
        List all incomplete (partial) blobs.

        Note: this allocates for each `BlobListIncompleteResponse`, if you have many `BlobListIncompleteResponse`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_list_incomplete(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeIncompleteBlobInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def read_at_to_bytes(self, hash: "Hash",offset: "int",len: "ReadAtLen") -> "bytes":
        """
        Read all bytes of single blob at `offset` for length `len`.

        This allocates a buffer for the full length `len`. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_at_to_bytes`].
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterUInt64.check_lower(offset)
        
        _UniffiConverterTypeReadAtLen.check_lower(len)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_at_to_bytes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterUInt64.lower(offset),
        _UniffiConverterTypeReadAtLen.lower(len)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def read_to_bytes(self, hash: "Hash") -> "bytes":
        """
        Read all bytes of single blob.

        This allocates a buffer for the full blob. Use only if you know that the blob you're
        reading is small. If not sure, use [`Self::blobs_size`] and check the size with
        before calling [`Self::blobs_read_to_bytes`].
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_read_to_bytes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def share(self, hash: "Hash",blob_format: "BlobFormat",ticket_options: "AddrInfoOptions") -> "BlobTicket":
        """
        Create a ticket for sharing a blob from this node.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterTypeBlobFormat.check_lower(blob_format)
        
        _UniffiConverterTypeAddrInfoOptions.check_lower(ticket_options)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_share(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterTypeBlobFormat.lower(blob_format),
        _UniffiConverterTypeAddrInfoOptions.lower(ticket_options)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeBlobTicket.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def size(self, hash: "Hash") -> "int":
        """
        Get the size information on a single blob.

        Method only exists in FFI
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_size(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def status(self, hash: "Hash") -> "BlobStatus":
        """
        Check the storage status of a blob on this node.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_status(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeBlobStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def write_to_path(self, hash: "Hash",path: "str") -> None:

        """
        Export the blob contents to a file path
        The `path` field is expected to be the absolute path.
        """

        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterString.check_lower(path)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_blobs_write_to_path(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterString.lower(path)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeBlobs:

    @staticmethod
    def lift(value: int):
        return Blobs._make_instance_(value)

    @staticmethod
    def check_lower(value: Blobs):
        if not isinstance(value, Blobs):
            raise TypeError("Expected Blobs instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BlobsProtocol):
        if not isinstance(value, Blobs):
            raise TypeError("Expected Blobs instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BlobsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class CollectionProtocol(typing.Protocol):
    """
    A collection of blobs
    """

    def blobs(self, ):
        """
        Get the blobs associated with this collection
        """

        raise NotImplementedError
    def is_empty(self, ):
        """
        Check if the collection is empty
        """

        raise NotImplementedError
    def len(self, ):
        """
        Returns the number of blobs in this collection
        """

        raise NotImplementedError
    def links(self, ):
        """
        Get the links to the blobs in this collection
        """

        raise NotImplementedError
    def names(self, ):
        """
        Get the names of the blobs in this collection
        """

        raise NotImplementedError
    def push(self, name: "str",hash: "Hash"):
        """
        Add the given blob to the collection
        """

        raise NotImplementedError


class Collection:
    """
    A collection of blobs
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        """
        Create a new empty collection
        """

        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_collection_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_collection, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_collection, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def blobs(self, ) -> "typing.List[LinkAndName]":
        """
        Get the blobs associated with this collection
        """

        return _UniffiConverterSequenceTypeLinkAndName.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_blobs,self._uniffi_clone_pointer(),)
        )





    def is_empty(self, ) -> "bool":
        """
        Check if the collection is empty
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_is_empty,self._uniffi_clone_pointer(),)
        )





    def len(self, ) -> "int":
        """
        Returns the number of blobs in this collection
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_len,self._uniffi_clone_pointer(),)
        )





    def links(self, ) -> "typing.List[Hash]":
        """
        Get the links to the blobs in this collection
        """

        return _UniffiConverterSequenceTypeHash.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_links,self._uniffi_clone_pointer(),)
        )





    def names(self, ) -> "typing.List[str]":
        """
        Get the names of the blobs in this collection
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_names,self._uniffi_clone_pointer(),)
        )





    def push(self, name: "str",hash: "Hash") -> None:
        """
        Add the given blob to the collection
        """

        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterTypeHash.check_lower(hash)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_collection_push,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(name),
        _UniffiConverterTypeHash.lower(hash))







class _UniffiConverterTypeCollection:

    @staticmethod
    def lift(value: int):
        return Collection._make_instance_(value)

    @staticmethod
    def check_lower(value: Collection):
        if not isinstance(value, Collection):
            raise TypeError("Expected Collection instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CollectionProtocol):
        if not isinstance(value, Collection):
            raise TypeError("Expected Collection instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CollectionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ConnectingProtocol(typing.Protocol):
    def alpn(self, ):
        raise NotImplementedError
    def connect(self, ):
        raise NotImplementedError


class Connecting:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_connecting, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_connecting, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def alpn(self, ) -> "bytes":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connecting_alpn(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def connect(self, ) -> "Connection":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connecting_connect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeConnection.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeConnecting:

    @staticmethod
    def lift(value: int):
        return Connecting._make_instance_(value)

    @staticmethod
    def check_lower(value: Connecting):
        if not isinstance(value, Connecting):
            raise TypeError("Expected Connecting instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConnectingProtocol):
        if not isinstance(value, Connecting):
            raise TypeError("Expected Connecting instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConnectingProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ConnectionProtocol(typing.Protocol):
    def accept_bi(self, ):
        raise NotImplementedError
    def accept_uni(self, ):
        raise NotImplementedError
    def alpn(self, ):
        raise NotImplementedError
    def close(self, error_code: "int",reason: "bytes"):
        raise NotImplementedError
    def close_reason(self, ):
        raise NotImplementedError
    def closed(self, ):
        raise NotImplementedError
    def datagram_send_buffer_space(self, ):
        raise NotImplementedError
    def max_datagram_size(self, ):
        raise NotImplementedError
    def open_bi(self, ):
        raise NotImplementedError
    def open_uni(self, ):
        raise NotImplementedError
    def read_datagram(self, ):
        raise NotImplementedError
    def remote_node_id(self, ):
        raise NotImplementedError
    def rtt(self, ):
        raise NotImplementedError
    def send_datagram(self, data: "bytes"):
        raise NotImplementedError
    def set_max_concurrent_bii_stream(self, count: "int"):
        raise NotImplementedError
    def set_max_concurrent_uni_stream(self, count: "int"):
        raise NotImplementedError
    def set_receive_window(self, count: "int"):
        raise NotImplementedError
    def stable_id(self, ):
        raise NotImplementedError


class Connection:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_connection, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_connection, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def accept_bi(self, ) -> "BiStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_bi(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeBiStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def accept_uni(self, ) -> "RecvStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_accept_uni(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeRecvStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )




    def alpn(self, ) -> "typing.Optional[bytes]":
        return _UniffiConverterOptionalBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_alpn,self._uniffi_clone_pointer(),)
        )





    def close(self, error_code: "int",reason: "bytes") -> None:
        _UniffiConverterUInt64.check_lower(error_code)
        
        _UniffiConverterBytes.check_lower(reason)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(error_code),
        _UniffiConverterBytes.lower(reason))






    def close_reason(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_close_reason,self._uniffi_clone_pointer(),)
        )




    async def closed(self, ) -> "str":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_closed(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter

    None,

        )




    def datagram_send_buffer_space(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_datagram_send_buffer_space,self._uniffi_clone_pointer(),)
        )





    def max_datagram_size(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_max_datagram_size,self._uniffi_clone_pointer(),)
        )




    async def open_bi(self, ) -> "BiStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_bi(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeBiStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def open_uni(self, ) -> "SendStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_open_uni(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSendStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def read_datagram(self, ) -> "bytes":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_connection_read_datagram(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )




    def remote_node_id(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_remote_node_id,self._uniffi_clone_pointer(),)
        )





    def rtt(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_rtt,self._uniffi_clone_pointer(),)
        )





    def send_datagram(self, data: "bytes") -> None:
        _UniffiConverterBytes.check_lower(data)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_send_datagram,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(data))






    def set_max_concurrent_bii_stream(self, count: "int") -> None:
        _UniffiConverterUInt64.check_lower(count)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_bii_stream,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(count))






    def set_max_concurrent_uni_stream(self, count: "int") -> None:
        _UniffiConverterUInt64.check_lower(count)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_max_concurrent_uni_stream,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(count))






    def set_receive_window(self, count: "int") -> None:
        _UniffiConverterUInt64.check_lower(count)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_connection_set_receive_window,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(count))






    def stable_id(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connection_stable_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeConnection:

    @staticmethod
    def lift(value: int):
        return Connection._make_instance_(value)

    @staticmethod
    def check_lower(value: Connection):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConnectionProtocol):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConnectionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ConnectionTypeProtocol(typing.Protocol):
    """
    The type of connection we have to the node
    """

    def as_direct(self, ):
        """
        Return the socket address if this is a direct connection
        """

        raise NotImplementedError
    def as_mixed(self, ):
        """
        Return the socket address and DERP url if this is a mixed connection
        """

        raise NotImplementedError
    def as_relay(self, ):
        """
        Return the derp url if this is a relay connection
        """

        raise NotImplementedError
    def type(self, ):
        """
        Whether connection is direct, relay, mixed, or none
        """

        raise NotImplementedError


class ConnectionType:
    """
    The type of connection we have to the node
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_connectiontype, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_connectiontype, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_direct(self, ) -> "str":
        """
        Return the socket address if this is a direct connection
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_direct,self._uniffi_clone_pointer(),)
        )





    def as_mixed(self, ) -> "ConnectionTypeMixed":
        """
        Return the socket address and DERP url if this is a mixed connection
        """

        return _UniffiConverterTypeConnectionTypeMixed.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_mixed,self._uniffi_clone_pointer(),)
        )





    def as_relay(self, ) -> "str":
        """
        Return the derp url if this is a relay connection
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_as_relay,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "ConnType":
        """
        Whether connection is direct, relay, mixed, or none
        """

        return _UniffiConverterTypeConnType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_connectiontype_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeConnectionType:

    @staticmethod
    def lift(value: int):
        return ConnectionType._make_instance_(value)

    @staticmethod
    def check_lower(value: ConnectionType):
        if not isinstance(value, ConnectionType):
            raise TypeError("Expected ConnectionType instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConnectionTypeProtocol):
        if not isinstance(value, ConnectionType):
            raise TypeError("Expected ConnectionType instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConnectionTypeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DirectAddrInfoProtocol(typing.Protocol):
    """
    Information about a direct address.
    """

    def addr(self, ):
        """
        Get the reported address
        """

        raise NotImplementedError
    def last_control(self, ):
        """
        Get the last control message received by this node
        """

        raise NotImplementedError
    def last_payload(self, ):
        """
        Get how long ago the last payload message was received for this node
        """

        raise NotImplementedError
    def latency(self, ):
        """
        Get the reported latency, if it exists
        """

        raise NotImplementedError


class DirectAddrInfo:
    """
    Information about a direct address.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_directaddrinfo, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_directaddrinfo, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def addr(self, ) -> "str":
        """
        Get the reported address
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_addr,self._uniffi_clone_pointer(),)
        )





    def last_control(self, ) -> "typing.Optional[LatencyAndControlMsg]":
        """
        Get the last control message received by this node
        """

        return _UniffiConverterOptionalTypeLatencyAndControlMsg.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_control,self._uniffi_clone_pointer(),)
        )





    def last_payload(self, ) -> "typing.Optional[Duration]":
        """
        Get how long ago the last payload message was received for this node
        """

        return _UniffiConverterOptionalDuration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_last_payload,self._uniffi_clone_pointer(),)
        )





    def latency(self, ) -> "typing.Optional[Duration]":
        """
        Get the reported latency, if it exists
        """

        return _UniffiConverterOptionalDuration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_directaddrinfo_latency,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDirectAddrInfo:

    @staticmethod
    def lift(value: int):
        return DirectAddrInfo._make_instance_(value)

    @staticmethod
    def check_lower(value: DirectAddrInfo):
        if not isinstance(value, DirectAddrInfo):
            raise TypeError("Expected DirectAddrInfo instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DirectAddrInfoProtocol):
        if not isinstance(value, DirectAddrInfo):
            raise TypeError("Expected DirectAddrInfo instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DirectAddrInfoProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocProtocol(typing.Protocol):
    """
    A representation of a mutable, synchronizable key-value store.
    """

    def close_me(self, ):
        """
        Close the document.
        """

        raise NotImplementedError
    def delete(self, author_id: "AuthorId",prefix: "bytes"):
        """
        Delete entries that match the given `author` and key `prefix`.

        This inserts an empty entry with the key set to `prefix`, effectively clearing all other
        entries whose key starts with or is equal to the given `prefix`.

        Returns the number of entries deleted.
        """

        raise NotImplementedError
    def export_file(self, entry: "Entry",path: "str",cb: "typing.Optional[DocExportFileCallback]"):
        """
        Export an entry as a file to a given absolute path
        """

        raise NotImplementedError
    def get_download_policy(self, ):
        """
        Get the download policy for this document
        """

        raise NotImplementedError
    def get_exact(self, author: "AuthorId",key: "bytes",include_empty: "bool"):
        """
        Get an entry for a key and author.
        """

        raise NotImplementedError
    def get_many(self, query: "Query"):
        """
        Get entries.

        Note: this allocates for each `Entry`, if you have many `Entry`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        raise NotImplementedError
    def get_one(self, query: "Query"):
        """
        Get the latest entry for a key and author.
        """

        raise NotImplementedError
    def get_sync_peers(self, ):
        """
        Get sync peers for this document
        """

        raise NotImplementedError
    def id(self, ):
        """
        Get the document id of this doc.
        """

        raise NotImplementedError
    def import_file(self, author: "AuthorId",key: "bytes",path: "str",in_place: "bool",cb: "typing.Optional[DocImportFileCallback]"):
        """
        Add an entry from an absolute file path
        """

        raise NotImplementedError
    def leave(self, ):
        """
        Stop the live sync for this document.
        """

        raise NotImplementedError
    def set_bytes(self, author_id: "AuthorId",key: "bytes",value: "bytes"):
        """
        Set the content of a key to a byte array.
        """

        raise NotImplementedError
    def set_download_policy(self, policy: "DownloadPolicy"):
        """
        Set the download policy for this document
        """

        raise NotImplementedError
    def set_hash(self, author_id: "AuthorId",key: "bytes",hash: "Hash",size: "int"):
        """
        Set an entries on the doc via its key, hash, and size.
        """

        raise NotImplementedError
    def share(self, mode: "ShareMode",addr_options: "AddrInfoOptions"):
        """
        Share this document with peers over a ticket.
        """

        raise NotImplementedError
    def start_sync(self, peers: "typing.List[NodeAddr]"):
        """
        Start to sync this document with a list of peers.
        """

        raise NotImplementedError
    def status(self, ):
        """
        Get status info for this document
        """

        raise NotImplementedError
    def subscribe(self, cb: "SubscribeCallback"):
        """
        Subscribe to events for this document.
        """

        raise NotImplementedError


class Doc:
    """
    A representation of a mutable, synchronizable key-value store.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_doc, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_doc, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def close_me(self, ) -> None:

        """
        Close the document.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_close_me(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def delete(self, author_id: "AuthorId",prefix: "bytes") -> "int":
        """
        Delete entries that match the given `author` and key `prefix`.

        This inserts an empty entry with the key set to `prefix`, effectively clearing all other
        entries whose key starts with or is equal to the given `prefix`.

        Returns the number of entries deleted.
        """

        _UniffiConverterTypeAuthorId.check_lower(author_id)
        
        _UniffiConverterBytes.check_lower(prefix)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author_id),
        _UniffiConverterBytes.lower(prefix)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def export_file(self, entry: "Entry",path: "str",cb: "typing.Optional[DocExportFileCallback]") -> None:

        """
        Export an entry as a file to a given absolute path
        """

        _UniffiConverterTypeEntry.check_lower(entry)
        
        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterOptionalTypeDocExportFileCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_export_file(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeEntry.lower(entry),
        _UniffiConverterString.lower(path),
        _UniffiConverterOptionalTypeDocExportFileCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_download_policy(self, ) -> "DownloadPolicy":
        """
        Get the download policy for this document
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_download_policy(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDownloadPolicy.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_exact(self, author: "AuthorId",key: "bytes",include_empty: "bool") -> "typing.Optional[Entry]":
        """
        Get an entry for a key and author.
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        _UniffiConverterBytes.check_lower(key)
        
        _UniffiConverterBool.check_lower(include_empty)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_exact(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterBool.lower(include_empty)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEntry.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_many(self, query: "Query") -> "typing.List[Entry]":
        """
        Get entries.

        Note: this allocates for each `Entry`, if you have many `Entry`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        _UniffiConverterTypeQuery.check_lower(query)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_many(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeQuery.lower(query)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeEntry.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_one(self, query: "Query") -> "typing.Optional[Entry]":
        """
        Get the latest entry for a key and author.
        """

        _UniffiConverterTypeQuery.check_lower(query)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_one(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeQuery.lower(query)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEntry.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def get_sync_peers(self, ) -> "typing.Optional[typing.List[bytes]]":
        """
        Get sync peers for this document
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_get_sync_peers(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalSequenceBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )




    def id(self, ) -> "str":
        """
        Get the document id of this doc.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_doc_id,self._uniffi_clone_pointer(),)
        )




    async def import_file(self, author: "AuthorId",key: "bytes",path: "str",in_place: "bool",cb: "typing.Optional[DocImportFileCallback]") -> None:

        """
        Add an entry from an absolute file path
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        _UniffiConverterBytes.check_lower(key)
        
        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterBool.check_lower(in_place)
        
        _UniffiConverterOptionalTypeDocImportFileCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_import_file(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterString.lower(path),
        _UniffiConverterBool.lower(in_place),
        _UniffiConverterOptionalTypeDocImportFileCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def leave(self, ) -> None:

        """
        Stop the live sync for this document.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_leave(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def set_bytes(self, author_id: "AuthorId",key: "bytes",value: "bytes") -> "Hash":
        """
        Set the content of a key to a byte array.
        """

        _UniffiConverterTypeAuthorId.check_lower(author_id)
        
        _UniffiConverterBytes.check_lower(key)
        
        _UniffiConverterBytes.check_lower(value)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_bytes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author_id),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterBytes.lower(value)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeHash.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def set_download_policy(self, policy: "DownloadPolicy") -> None:

        """
        Set the download policy for this document
        """

        _UniffiConverterTypeDownloadPolicy.check_lower(policy)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_download_policy(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDownloadPolicy.lower(policy)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def set_hash(self, author_id: "AuthorId",key: "bytes",hash: "Hash",size: "int") -> None:

        """
        Set an entries on the doc via its key, hash, and size.
        """

        _UniffiConverterTypeAuthorId.check_lower(author_id)
        
        _UniffiConverterBytes.check_lower(key)
        
        _UniffiConverterTypeHash.check_lower(hash)
        
        _UniffiConverterUInt64.check_lower(size)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_set_hash(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAuthorId.lower(author_id),
        _UniffiConverterBytes.lower(key),
        _UniffiConverterTypeHash.lower(hash),
        _UniffiConverterUInt64.lower(size)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def share(self, mode: "ShareMode",addr_options: "AddrInfoOptions") -> "DocTicket":
        """
        Share this document with peers over a ticket.
        """

        _UniffiConverterTypeShareMode.check_lower(mode)
        
        _UniffiConverterTypeAddrInfoOptions.check_lower(addr_options)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_share(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeShareMode.lower(mode),
        _UniffiConverterTypeAddrInfoOptions.lower(addr_options)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDocTicket.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def start_sync(self, peers: "typing.List[NodeAddr]") -> None:

        """
        Start to sync this document with a list of peers.
        """

        _UniffiConverterSequenceTypeNodeAddr.check_lower(peers)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_start_sync(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeNodeAddr.lower(peers)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def status(self, ) -> "OpenState":
        """
        Get status info for this document
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_status(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeOpenState.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def subscribe(self, cb: "SubscribeCallback") -> None:

        """
        Subscribe to events for this document.
        """

        _UniffiConverterTypeSubscribeCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_doc_subscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSubscribeCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeDoc:

    @staticmethod
    def lift(value: int):
        return Doc._make_instance_(value)

    @staticmethod
    def check_lower(value: Doc):
        if not isinstance(value, Doc):
            raise TypeError("Expected Doc instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DocProtocol):
        if not isinstance(value, Doc):
            raise TypeError("Expected Doc instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocExportFileCallback(typing.Protocol):
    """
    The `progress` method will be called for each `DocExportProgress` event that is
    emitted during a `doc.export_file()` call. Use the `DocExportProgress.type()`
    method to check the `DocExportProgressType`
    """

    def progress(self, progress: "DocExportProgress"):
        raise NotImplementedError


class DocExportFileCallbackImpl:
    """
    The `progress` method will be called for each `DocExportProgress` event that is
    emitted during a `doc.export_file()` call. Use the `DocExportProgress.type()`
    method to check the `DocExportProgressType`
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docexportfilecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportfilecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def progress(self, progress: "DocExportProgress") -> None:

        _UniffiConverterTypeDocExportProgress.check_lower(progress)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docexportfilecallback_progress(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDocExportProgress.lower(progress)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplDocExportFileCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_DOC_EXPORT_FILE_CALLBACK_METHOD0
    def progress(
            uniffi_handle,
            progress,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeDocExportFileCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeDocExportProgress.lift(progress), )
            method = uniffi_obj.progress
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeDocExportFileCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceDocExportFileCallback(
        progress,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docexportfilecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeDocExportFileCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return DocExportFileCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: DocExportFileCallback):
        pass

    @staticmethod
    def lower(value: DocExportFileCallback):
        return _UniffiConverterTypeDocExportFileCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocExportFileCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocExportProgressProtocol(typing.Protocol):
    """
    Progress updates for the doc import file operation.
    """

    def as_abort(self, ):
        """
        Return the `DocExportProgressAbort`
        """

        raise NotImplementedError
    def as_found(self, ):
        """
        Return the `DocExportProgressFound` event
        """

        raise NotImplementedError
    def as_progress(self, ):
        """
        Return the `DocExportProgressProgress` event
        """

        raise NotImplementedError
    def type(self, ):
        """
        Get the type of event
        """

        raise NotImplementedError


class DocExportProgress:
    """
    Progress updates for the doc import file operation.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docexportprogress, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docexportprogress, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DocExportProgressAbort":
        """
        Return the `DocExportProgressAbort`
        """

        return _UniffiConverterTypeDocExportProgressAbort.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_abort,self._uniffi_clone_pointer(),)
        )





    def as_found(self, ) -> "DocExportProgressFound":
        """
        Return the `DocExportProgressFound` event
        """

        return _UniffiConverterTypeDocExportProgressFound.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_found,self._uniffi_clone_pointer(),)
        )





    def as_progress(self, ) -> "DocExportProgressProgress":
        """
        Return the `DocExportProgressProgress` event
        """

        return _UniffiConverterTypeDocExportProgressProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_as_progress,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "DocExportProgressType":
        """
        Get the type of event
        """

        return _UniffiConverterTypeDocExportProgressType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docexportprogress_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDocExportProgress:

    @staticmethod
    def lift(value: int):
        return DocExportProgress._make_instance_(value)

    @staticmethod
    def check_lower(value: DocExportProgress):
        if not isinstance(value, DocExportProgress):
            raise TypeError("Expected DocExportProgress instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DocExportProgressProtocol):
        if not isinstance(value, DocExportProgress):
            raise TypeError("Expected DocExportProgress instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocExportProgressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocImportFileCallback(typing.Protocol):
    """
    The `progress` method will be called for each `DocImportProgress` event that is
    emitted during a `doc.import_file()` call. Use the `DocImportProgress.type()`
    method to check the `DocImportProgressType`
    """

    def progress(self, progress: "DocImportProgress"):
        raise NotImplementedError


class DocImportFileCallbackImpl:
    """
    The `progress` method will be called for each `DocImportProgress` event that is
    emitted during a `doc.import_file()` call. Use the `DocImportProgress.type()`
    method to check the `DocImportProgressType`
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docimportfilecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportfilecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def progress(self, progress: "DocImportProgress") -> None:

        _UniffiConverterTypeDocImportProgress.check_lower(progress)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docimportfilecallback_progress(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDocImportProgress.lower(progress)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplDocImportFileCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_DOC_IMPORT_FILE_CALLBACK_METHOD0
    def progress(
            uniffi_handle,
            progress,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeDocImportFileCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeDocImportProgress.lift(progress), )
            method = uniffi_obj.progress
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeDocImportFileCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceDocImportFileCallback(
        progress,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_docimportfilecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeDocImportFileCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return DocImportFileCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: DocImportFileCallback):
        pass

    @staticmethod
    def lower(value: DocImportFileCallback):
        return _UniffiConverterTypeDocImportFileCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocImportFileCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocImportProgressProtocol(typing.Protocol):
    """
    Progress updates for the doc import file operation.
    """

    def as_abort(self, ):
        """
        Return the `DocImportProgressAbort`
        """

        raise NotImplementedError
    def as_all_done(self, ):
        """
        Return the `DocImportProgressAllDone`
        """

        raise NotImplementedError
    def as_found(self, ):
        """
        Return the `DocImportProgressFound` event
        """

        raise NotImplementedError
    def as_ingest_done(self, ):
        """
        Return the `DocImportProgressDone` event
        """

        raise NotImplementedError
    def as_progress(self, ):
        """
        Return the `DocImportProgressProgress` event
        """

        raise NotImplementedError
    def type(self, ):
        """
        Get the type of event
        """

        raise NotImplementedError


class DocImportProgress:
    """
    Progress updates for the doc import file operation.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docimportprogress, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docimportprogress, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DocImportProgressAbort":
        """
        Return the `DocImportProgressAbort`
        """

        return _UniffiConverterTypeDocImportProgressAbort.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_abort,self._uniffi_clone_pointer(),)
        )





    def as_all_done(self, ) -> "DocImportProgressAllDone":
        """
        Return the `DocImportProgressAllDone`
        """

        return _UniffiConverterTypeDocImportProgressAllDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_all_done,self._uniffi_clone_pointer(),)
        )





    def as_found(self, ) -> "DocImportProgressFound":
        """
        Return the `DocImportProgressFound` event
        """

        return _UniffiConverterTypeDocImportProgressFound.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_found,self._uniffi_clone_pointer(),)
        )





    def as_ingest_done(self, ) -> "DocImportProgressIngestDone":
        """
        Return the `DocImportProgressDone` event
        """

        return _UniffiConverterTypeDocImportProgressIngestDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_ingest_done,self._uniffi_clone_pointer(),)
        )





    def as_progress(self, ) -> "DocImportProgressProgress":
        """
        Return the `DocImportProgressProgress` event
        """

        return _UniffiConverterTypeDocImportProgressProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_as_progress,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "DocImportProgressType":
        """
        Get the type of event
        """

        return _UniffiConverterTypeDocImportProgressType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docimportprogress_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDocImportProgress:

    @staticmethod
    def lift(value: int):
        return DocImportProgress._make_instance_(value)

    @staticmethod
    def check_lower(value: DocImportProgress):
        if not isinstance(value, DocImportProgress):
            raise TypeError("Expected DocImportProgress instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DocImportProgressProtocol):
        if not isinstance(value, DocImportProgress):
            raise TypeError("Expected DocImportProgress instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocImportProgressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocTicketProtocol(typing.Protocol):
    """
    Contains both a key (either secret or public) to a document, and a list of peers to join.
    """

    pass


class DocTicket:
    """
    Contains both a key (either secret or public) to a document, and a list of peers to join.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, str: "str"):
        _UniffiConverterString.check_lower(str)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_docticket_new,
        _UniffiConverterString.lower(str))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docticket, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docticket, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_docticket_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDocTicket:

    @staticmethod
    def lift(value: int):
        return DocTicket._make_instance_(value)

    @staticmethod
    def check_lower(value: DocTicket):
        if not isinstance(value, DocTicket):
            raise TypeError("Expected DocTicket instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DocTicketProtocol):
        if not isinstance(value, DocTicket):
            raise TypeError("Expected DocTicket instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocTicketProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DocsProtocol(typing.Protocol):
    """
    Iroh docs client.
    """

    def create(self, ):
        """
        Create a new doc.
        """

        raise NotImplementedError
    def drop_doc(self, doc_id: "str"):
        """
        Delete a document from the local node.

        This is a destructive operation. Both the document secret key and all entries in the
        document will be permanently deleted from the node's storage. Content blobs will be deleted
        through garbage collection unless they are referenced from another document or tag.
        """

        raise NotImplementedError
    def join(self, ticket: "DocTicket"):
        """
        Join and sync with an already existing document.
        """

        raise NotImplementedError
    def join_and_subscribe(self, ticket: "DocTicket",cb: "SubscribeCallback"):
        """
        Join and sync with an already existing document and subscribe to events on that document.
        """

        raise NotImplementedError
    def list(self, ):
        """
        List all the docs we have access to on this node.
        """

        raise NotImplementedError
    def open(self, id: "str"):
        """
        Get a [`Doc`].

        Returns None if the document cannot be found.
        """

        raise NotImplementedError


class Docs:
    """
    Iroh docs client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_docs, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_docs, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def create(self, ) -> "Doc":
        """
        Create a new doc.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_create(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDoc.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def drop_doc(self, doc_id: "str") -> None:

        """
        Delete a document from the local node.

        This is a destructive operation. Both the document secret key and all entries in the
        document will be permanently deleted from the node's storage. Content blobs will be deleted
        through garbage collection unless they are referenced from another document or tag.
        """

        _UniffiConverterString.check_lower(doc_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_drop_doc(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(doc_id)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def join(self, ticket: "DocTicket") -> "Doc":
        """
        Join and sync with an already existing document.
        """

        _UniffiConverterTypeDocTicket.check_lower(ticket)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_join(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDocTicket.lower(ticket)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDoc.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def join_and_subscribe(self, ticket: "DocTicket",cb: "SubscribeCallback") -> "Doc":
        """
        Join and sync with an already existing document and subscribe to events on that document.
        """

        _UniffiConverterTypeDocTicket.check_lower(ticket)
        
        _UniffiConverterTypeSubscribeCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_join_and_subscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDocTicket.lower(ticket),
        _UniffiConverterTypeSubscribeCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDoc.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list(self, ) -> "typing.List[NamespaceAndCapability]":
        """
        List all the docs we have access to on this node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeNamespaceAndCapability.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def open(self, id: "str") -> "typing.Optional[Doc]":
        """
        Get a [`Doc`].

        Returns None if the document cannot be found.
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_docs_open(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeDoc.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeDocs:

    @staticmethod
    def lift(value: int):
        return Docs._make_instance_(value)

    @staticmethod
    def check_lower(value: Docs):
        if not isinstance(value, Docs):
            raise TypeError("Expected Docs instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DocsProtocol):
        if not isinstance(value, Docs):
            raise TypeError("Expected Docs instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DocsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DownloadCallback(typing.Protocol):
    """
    The `progress` method will be called for each `DownloadProgress` event that is emitted during
    a `node.blobs_download`. Use the `DownloadProgress.type()` method to check the
    `DownloadProgressType` of the event.
    """

    def progress(self, progress: "DownloadProgress"):
        raise NotImplementedError


class DownloadCallbackImpl:
    """
    The `progress` method will be called for each `DownloadProgress` event that is emitted during
    a `node.blobs_download`. Use the `DownloadProgress.type()` method to check the
    `DownloadProgressType` of the event.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_downloadcallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadcallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def progress(self, progress: "DownloadProgress") -> None:

        _UniffiConverterTypeDownloadProgress.check_lower(progress)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_downloadcallback_progress(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDownloadProgress.lower(progress)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplDownloadCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_DOWNLOAD_CALLBACK_METHOD0
    def progress(
            uniffi_handle,
            progress,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeDownloadCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeDownloadProgress.lift(progress), )
            method = uniffi_obj.progress
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeDownloadCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceDownloadCallback(
        progress,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_downloadcallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeDownloadCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return DownloadCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: DownloadCallback):
        pass

    @staticmethod
    def lower(value: DownloadCallback):
        return _UniffiConverterTypeDownloadCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DownloadCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DownloadPolicyProtocol(typing.Protocol):
    """
    Download policy to decide which content blobs shall be downloaded.
    """

    pass


class DownloadPolicy:
    """
    Download policy to decide which content blobs shall be downloaded.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_downloadpolicy, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadpolicy, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def everything(cls, ):
        """
        Download everything
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything,)
        return cls._make_instance_(pointer)

    @classmethod
    def everything_except(cls, filters: "typing.List[FilterKind]"):
        """
        Download everything except keys that match the given filters
        """

        _UniffiConverterSequenceTypeFilterKind.check_lower(filters)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_everything_except,
        _UniffiConverterSequenceTypeFilterKind.lower(filters))
        return cls._make_instance_(pointer)

    @classmethod
    def nothing(cls, ):
        """
        Download nothing
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing,)
        return cls._make_instance_(pointer)

    @classmethod
    def nothing_except(cls, filters: "typing.List[FilterKind]"):
        """
        Download nothing except keys that match the given filters
        """

        _UniffiConverterSequenceTypeFilterKind.check_lower(filters)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_downloadpolicy_nothing_except,
        _UniffiConverterSequenceTypeFilterKind.lower(filters))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeDownloadPolicy:

    @staticmethod
    def lift(value: int):
        return DownloadPolicy._make_instance_(value)

    @staticmethod
    def check_lower(value: DownloadPolicy):
        if not isinstance(value, DownloadPolicy):
            raise TypeError("Expected DownloadPolicy instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DownloadPolicyProtocol):
        if not isinstance(value, DownloadPolicy):
            raise TypeError("Expected DownloadPolicy instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DownloadPolicyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DownloadProgressProtocol(typing.Protocol):
    """
    Progress updates for the get operation.
    """

    def as_abort(self, ):
        """
        Return the `DownloadProgressAbort` event
        """

        raise NotImplementedError
    def as_all_done(self, ):
        """
        Return the `DownloadProgressAllDone` event
        """

        raise NotImplementedError
    def as_done(self, ):
        """
        Return the `DownloadProgressDone` event
        """

        raise NotImplementedError
    def as_found(self, ):
        """
        Return the `DownloadProgressFound` event
        """

        raise NotImplementedError
    def as_found_hash_seq(self, ):
        """
        Return the `DownloadProgressFoundHashSeq` event
        """

        raise NotImplementedError
    def as_found_local(self, ):
        """
        Return the `DownloadProgressFoundLocal` event
        """

        raise NotImplementedError
    def as_progress(self, ):
        """
        Return the `DownloadProgressProgress` event
        """

        raise NotImplementedError
    def type(self, ):
        """
        Get the type of event
        note that there is no `as_connected` method, as the `Connected` event has no associated data
        """

        raise NotImplementedError


class DownloadProgress:
    """
    Progress updates for the get operation.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_downloadprogress, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_downloadprogress, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_abort(self, ) -> "DownloadProgressAbort":
        """
        Return the `DownloadProgressAbort` event
        """

        return _UniffiConverterTypeDownloadProgressAbort.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_abort,self._uniffi_clone_pointer(),)
        )





    def as_all_done(self, ) -> "DownloadProgressAllDone":
        """
        Return the `DownloadProgressAllDone` event
        """

        return _UniffiConverterTypeDownloadProgressAllDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_all_done,self._uniffi_clone_pointer(),)
        )





    def as_done(self, ) -> "DownloadProgressDone":
        """
        Return the `DownloadProgressDone` event
        """

        return _UniffiConverterTypeDownloadProgressDone.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_done,self._uniffi_clone_pointer(),)
        )





    def as_found(self, ) -> "DownloadProgressFound":
        """
        Return the `DownloadProgressFound` event
        """

        return _UniffiConverterTypeDownloadProgressFound.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found,self._uniffi_clone_pointer(),)
        )





    def as_found_hash_seq(self, ) -> "DownloadProgressFoundHashSeq":
        """
        Return the `DownloadProgressFoundHashSeq` event
        """

        return _UniffiConverterTypeDownloadProgressFoundHashSeq.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_hash_seq,self._uniffi_clone_pointer(),)
        )





    def as_found_local(self, ) -> "DownloadProgressFoundLocal":
        """
        Return the `DownloadProgressFoundLocal` event
        """

        return _UniffiConverterTypeDownloadProgressFoundLocal.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_found_local,self._uniffi_clone_pointer(),)
        )





    def as_progress(self, ) -> "DownloadProgressProgress":
        """
        Return the `DownloadProgressProgress` event
        """

        return _UniffiConverterTypeDownloadProgressProgress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_as_progress,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "DownloadProgressType":
        """
        Get the type of event
        note that there is no `as_connected` method, as the `Connected` event has no associated data
        """

        return _UniffiConverterTypeDownloadProgressType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_downloadprogress_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDownloadProgress:

    @staticmethod
    def lift(value: int):
        return DownloadProgress._make_instance_(value)

    @staticmethod
    def check_lower(value: DownloadProgress):
        if not isinstance(value, DownloadProgress):
            raise TypeError("Expected DownloadProgress instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DownloadProgressProtocol):
        if not isinstance(value, DownloadProgress):
            raise TypeError("Expected DownloadProgress instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DownloadProgressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EndpointProtocol(typing.Protocol):
    def connect(self, node_addr: "NodeAddr",alpn: "bytes"):
        raise NotImplementedError
    def node_id(self, ):
        """
        The string representation of this endpoint's NodeId.
        """

        raise NotImplementedError


class Endpoint:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_endpoint, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_endpoint, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def connect(self, node_addr: "NodeAddr",alpn: "bytes") -> "Connection":
        _UniffiConverterTypeNodeAddr.check_lower(node_addr)
        
        _UniffiConverterBytes.check_lower(alpn)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_connect(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeNodeAddr.lower(node_addr),
        _UniffiConverterBytes.lower(alpn)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeConnection.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )




    def node_id(self, ) -> "str":
        """
        The string representation of this endpoint's NodeId.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_method_endpoint_node_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEndpoint:

    @staticmethod
    def lift(value: int):
        return Endpoint._make_instance_(value)

    @staticmethod
    def check_lower(value: Endpoint):
        if not isinstance(value, Endpoint):
            raise TypeError("Expected Endpoint instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EndpointProtocol):
        if not isinstance(value, Endpoint):
            raise TypeError("Expected Endpoint instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EndpointProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EntryProtocol(typing.Protocol):
    """
    A single entry in a [`Doc`]

    An entry is identified by a key, its [`AuthorId`], and the [`Doc`]'s
    namespace id. Its value is the 32-byte BLAKE3 [`hash`]
    of the entry's content data, the size of this content data, and a timestamp.
    """

    def author(self, ):
        """
        Get the [`AuthorId`] of this entry.
        """

        raise NotImplementedError
    def content_hash(self, ):
        """
        Get the content_hash of this entry.
        """

        raise NotImplementedError
    def content_len(self, ):
        """
        Get the content_length of this entry.
        """

        raise NotImplementedError
    def key(self, ):
        """
        Get the key of this entry.
        """

        raise NotImplementedError
    def namespace(self, ):
        """
        Get the namespace id of this entry.
        """

        raise NotImplementedError
    def timestamp(self, ):
        """
        Get the timestamp when this entry was written.
        """

        raise NotImplementedError


class Entry:
    """
    A single entry in a [`Doc`]

    An entry is identified by a key, its [`AuthorId`], and the [`Doc`]'s
    namespace id. Its value is the 32-byte BLAKE3 [`hash`]
    of the entry's content data, the size of this content data, and a timestamp.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_entry, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_entry, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def author(self, ) -> "AuthorId":
        """
        Get the [`AuthorId`] of this entry.
        """

        return _UniffiConverterTypeAuthorId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_author,self._uniffi_clone_pointer(),)
        )





    def content_hash(self, ) -> "Hash":
        """
        Get the content_hash of this entry.
        """

        return _UniffiConverterTypeHash.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_hash,self._uniffi_clone_pointer(),)
        )





    def content_len(self, ) -> "int":
        """
        Get the content_length of this entry.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_content_len,self._uniffi_clone_pointer(),)
        )





    def key(self, ) -> "bytes":
        """
        Get the key of this entry.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_key,self._uniffi_clone_pointer(),)
        )





    def namespace(self, ) -> "str":
        """
        Get the namespace id of this entry.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_namespace,self._uniffi_clone_pointer(),)
        )





    def timestamp(self, ) -> "int":
        """
        Get the timestamp when this entry was written.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_entry_timestamp,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEntry:

    @staticmethod
    def lift(value: int):
        return Entry._make_instance_(value)

    @staticmethod
    def check_lower(value: Entry):
        if not isinstance(value, Entry):
            raise TypeError("Expected Entry instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EntryProtocol):
        if not isinstance(value, Entry):
            raise TypeError("Expected Entry instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EntryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FilterKindProtocol(typing.Protocol):
    """
    Filter strategy used in download policies.
    """

    def matches(self, key: "bytes"):
        """
        Verifies whether this filter matches a given key
        """

        raise NotImplementedError


class FilterKind:
    """
    Filter strategy used in download policies.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_filterkind, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_filterkind, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def exact(cls, key: "bytes"):
        """
        Returns a FilterKind that matches if the contained bytes and the key are the same.
        """

        _UniffiConverterBytes.check_lower(key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_exact,
        _UniffiConverterBytes.lower(key))
        return cls._make_instance_(pointer)

    @classmethod
    def prefix(cls, prefix: "bytes"):
        """
        Returns a FilterKind that matches if the contained bytes are a prefix of the key.
        """

        _UniffiConverterBytes.check_lower(prefix)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_filterkind_prefix,
        _UniffiConverterBytes.lower(prefix))
        return cls._make_instance_(pointer)



    def matches(self, key: "bytes") -> "bool":
        """
        Verifies whether this filter matches a given key
        """

        _UniffiConverterBytes.check_lower(key)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_filterkind_matches,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(key))
        )






class _UniffiConverterTypeFilterKind:

    @staticmethod
    def lift(value: int):
        return FilterKind._make_instance_(value)

    @staticmethod
    def check_lower(value: FilterKind):
        if not isinstance(value, FilterKind):
            raise TypeError("Expected FilterKind instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FilterKindProtocol):
        if not isinstance(value, FilterKind):
            raise TypeError("Expected FilterKind instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FilterKindProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class GossipProtocol(typing.Protocol):
    """
    Iroh gossip client.
    """

    def subscribe(self, topic: "bytes",bootstrap: "typing.List[str]",cb: "GossipMessageCallback"):
        raise NotImplementedError


class Gossip:
    """
    Iroh gossip client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_gossip, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_gossip, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def subscribe(self, topic: "bytes",bootstrap: "typing.List[str]",cb: "GossipMessageCallback") -> "Sender":
        _UniffiConverterBytes.check_lower(topic)
        
        _UniffiConverterSequenceString.check_lower(bootstrap)
        
        _UniffiConverterTypeGossipMessageCallback.check_lower(cb)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_gossip_subscribe(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(topic),
        _UniffiConverterSequenceString.lower(bootstrap),
        _UniffiConverterTypeGossipMessageCallback.lower(cb)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeSender.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeGossip:

    @staticmethod
    def lift(value: int):
        return Gossip._make_instance_(value)

    @staticmethod
    def check_lower(value: Gossip):
        if not isinstance(value, Gossip):
            raise TypeError("Expected Gossip instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: GossipProtocol):
        if not isinstance(value, Gossip):
            raise TypeError("Expected Gossip instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: GossipProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class GossipMessageCallback(typing.Protocol):
    def on_message(self, msg: "Message"):
        raise NotImplementedError


class GossipMessageCallbackImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_gossipmessagecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_gossipmessagecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def on_message(self, msg: "Message") -> None:

        _UniffiConverterTypeMessage.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_gossipmessagecallback_on_message(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeMessage.lower(msg)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplGossipMessageCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_GOSSIP_MESSAGE_CALLBACK_METHOD0
    def on_message(
            uniffi_handle,
            msg,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeGossipMessageCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeMessage.lift(msg), )
            method = uniffi_obj.on_message
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeGossipMessageCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceGossipMessageCallback(
        on_message,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_gossipmessagecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeGossipMessageCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return GossipMessageCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: GossipMessageCallback):
        pass

    @staticmethod
    def lower(value: GossipMessageCallback):
        return _UniffiConverterTypeGossipMessageCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: GossipMessageCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class HashProtocol(typing.Protocol):
    """
    Hash type used throughout Iroh. A blake3 hash.
    """

    def equal(self, other: "Hash"):
        """
        Returns true if the Hash's have the same value
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Bytes of the hash.
        """

        raise NotImplementedError
    def to_hex(self, ):
        """
        Convert the hash to a hex string.
        """

        raise NotImplementedError


class Hash:
    """
    Hash type used throughout Iroh. A blake3 hash.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, buf: "bytes"):
        """
        Calculate the hash of the provide bytes.
        """

        _UniffiConverterBytes.check_lower(buf)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_new,
        _UniffiConverterBytes.lower(buf))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_hash, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_hash, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        """
        Create a `Hash` from its raw bytes representation.
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_string(cls, s: "str"):
        """
        Make a Hash from hex string
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_hash_from_string,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def equal(self, other: "Hash") -> "bool":
        """
        Returns true if the Hash's have the same value
        """

        _UniffiConverterTypeHash.check_lower(other)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_hash_equal,self._uniffi_clone_pointer(),
        _UniffiConverterTypeHash.lower(other))
        )





    def to_bytes(self, ) -> "bytes":
        """
        Bytes of the hash.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_hex(self, ) -> "str":
        """
        Convert the hash to a hex string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_hash_to_hex,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_hash_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeHash:

    @staticmethod
    def lift(value: int):
        return Hash._make_instance_(value)

    @staticmethod
    def check_lower(value: Hash):
        if not isinstance(value, Hash):
            raise TypeError("Expected Hash instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: HashProtocol):
        if not isinstance(value, Hash):
            raise TypeError("Expected Hash instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: HashProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class IrohProtocol(typing.Protocol):
    """
    An Iroh node. Allows you to sync, store, and transfer data.
    """

    def authors(self, ):
        """
        Access to gossip specific funtionaliy.
        """

        raise NotImplementedError
    def blobs(self, ):
        """
        Access to blob specific funtionaliy.
        """

        raise NotImplementedError
    def docs(self, ):
        """
        Access to docs specific funtionaliy.
        """

        raise NotImplementedError
    def gossip(self, ):
        """
        Access to gossip specific funtionaliy.
        """

        raise NotImplementedError
    def net(self, ):
        """
        Access to blob specific funtionaliy.
        """

        raise NotImplementedError
    def node(self, ):
        """
        Access to node specific funtionaliy.
        """

        raise NotImplementedError
    def tags(self, ):
        """
        Access to tags specific funtionaliy.
        """

        raise NotImplementedError


class Iroh:
    """
    An Iroh node. Allows you to sync, store, and transfer data.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_iroh, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_iroh, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    async def memory(cls, ):
        """
        Create a new iroh node.

        All data will be only persistet in memory.
        """


        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory(),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            _UniffiConverterTypeIroh.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )

    @classmethod
    async def memory_with_options(cls, options: "NodeOptions"):
        """
        Create a new in memory iroh node with options.
        """

        _UniffiConverterTypeNodeOptions.check_lower(options)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_memory_with_options(
        _UniffiConverterTypeNodeOptions.lower(options)),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            _UniffiConverterTypeIroh.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )

    @classmethod
    async def persistent(cls, path: "str"):
        """
        Create a new iroh node.

        The `path` param should be a directory where we can store or load
        iroh data from a previous session.
        """

        _UniffiConverterString.check_lower(path)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent(
        _UniffiConverterString.lower(path)),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            _UniffiConverterTypeIroh.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )

    @classmethod
    async def persistent_with_options(cls, path: "str",options: "NodeOptions"):
        """
        Create a new iroh node with options.
        """

        _UniffiConverterString.check_lower(path)
        
        _UniffiConverterTypeNodeOptions.check_lower(options)
        

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_constructor_iroh_persistent_with_options(
        _UniffiConverterString.lower(path),
        _UniffiConverterTypeNodeOptions.lower(options)),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            _UniffiConverterTypeIroh.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    def authors(self, ) -> "Authors":
        """
        Access to gossip specific funtionaliy.
        """

        return _UniffiConverterTypeAuthors.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_authors,self._uniffi_clone_pointer(),)
        )





    def blobs(self, ) -> "Blobs":
        """
        Access to blob specific funtionaliy.
        """

        return _UniffiConverterTypeBlobs.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_blobs,self._uniffi_clone_pointer(),)
        )





    def docs(self, ) -> "Docs":
        """
        Access to docs specific funtionaliy.
        """

        return _UniffiConverterTypeDocs.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_docs,self._uniffi_clone_pointer(),)
        )





    def gossip(self, ) -> "Gossip":
        """
        Access to gossip specific funtionaliy.
        """

        return _UniffiConverterTypeGossip.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_gossip,self._uniffi_clone_pointer(),)
        )





    def net(self, ) -> "Net":
        """
        Access to blob specific funtionaliy.
        """

        return _UniffiConverterTypeNet.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_net,self._uniffi_clone_pointer(),)
        )





    def node(self, ) -> "Node":
        """
        Access to node specific funtionaliy.
        """

        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_node,self._uniffi_clone_pointer(),)
        )





    def tags(self, ) -> "Tags":
        """
        Access to tags specific funtionaliy.
        """

        return _UniffiConverterTypeTags.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroh_tags,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeIroh:

    @staticmethod
    def lift(value: int):
        return Iroh._make_instance_(value)

    @staticmethod
    def check_lower(value: Iroh):
        if not isinstance(value, Iroh):
            raise TypeError("Expected Iroh instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: IrohProtocol):
        if not isinstance(value, Iroh):
            raise TypeError("Expected Iroh instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: IrohProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class IrohErrorProtocol(typing.Protocol):
    """
    An Error.
    """

    def message(self, ):
        raise NotImplementedError


class IrohError(Exception):
    """
    An Error.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_iroherror, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_iroherror, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def message(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_message,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_iroherror_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeIrohError__as_error(_UniffiConverterRustBuffer):
    @classmethod
    def read(cls, buf):
        raise NotImplementedError()

    @classmethod
    def write(cls, value, buf):
        raise NotImplementedError()

    @staticmethod
    def lift(value):
        # Errors are always a rust buffer holding a pointer - which is a "read"
        with value.consume_with_stream() as stream:
            return _UniffiConverterTypeIrohError.read(stream)

    @staticmethod
    def lower(value):
        raise NotImplementedError()

class _UniffiConverterTypeIrohError:

    @staticmethod
    def lift(value: int):
        return IrohError._make_instance_(value)

    @staticmethod
    def check_lower(value: IrohError):
        if not isinstance(value, IrohError):
            raise TypeError("Expected IrohError instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: IrohErrorProtocol):
        if not isinstance(value, IrohError):
            raise TypeError("Expected IrohError instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: IrohErrorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class LiveEventProtocol(typing.Protocol):
    """
    Events informing about actions of the live sync progress
    """

    def as_content_ready(self, ):
        """
        For `LiveEventType::ContentReady`, returns a Hash
        """

        raise NotImplementedError
    def as_insert_local(self, ):
        """
        For `LiveEventType::InsertLocal`, returns an Entry
        """

        raise NotImplementedError
    def as_insert_remote(self, ):
        """
        For `LiveEventType::InsertRemote`, returns an InsertRemoteEvent
        """

        raise NotImplementedError
    def as_neighbor_down(self, ):
        """
        For `LiveEventType::NeighborDown`, returns a PublicKey
        """

        raise NotImplementedError
    def as_neighbor_up(self, ):
        """
        For `LiveEventType::NeighborUp`, returns a PublicKey
        """

        raise NotImplementedError
    def as_sync_finished(self, ):
        """
        For `LiveEventType::SyncFinished`, returns a SyncEvent
        """

        raise NotImplementedError
    def type(self, ):
        """
        The type LiveEvent
        """

        raise NotImplementedError


class LiveEvent:
    """
    Events informing about actions of the live sync progress
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_liveevent, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_liveevent, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_content_ready(self, ) -> "Hash":
        """
        For `LiveEventType::ContentReady`, returns a Hash
        """

        return _UniffiConverterTypeHash.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_content_ready,self._uniffi_clone_pointer(),)
        )





    def as_insert_local(self, ) -> "Entry":
        """
        For `LiveEventType::InsertLocal`, returns an Entry
        """

        return _UniffiConverterTypeEntry.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_local,self._uniffi_clone_pointer(),)
        )





    def as_insert_remote(self, ) -> "InsertRemoteEvent":
        """
        For `LiveEventType::InsertRemote`, returns an InsertRemoteEvent
        """

        return _UniffiConverterTypeInsertRemoteEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_insert_remote,self._uniffi_clone_pointer(),)
        )





    def as_neighbor_down(self, ) -> "PublicKey":
        """
        For `LiveEventType::NeighborDown`, returns a PublicKey
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_down,self._uniffi_clone_pointer(),)
        )





    def as_neighbor_up(self, ) -> "PublicKey":
        """
        For `LiveEventType::NeighborUp`, returns a PublicKey
        """

        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_neighbor_up,self._uniffi_clone_pointer(),)
        )





    def as_sync_finished(self, ) -> "SyncEvent":
        """
        For `LiveEventType::SyncFinished`, returns a SyncEvent
        """

        return _UniffiConverterTypeSyncEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_as_sync_finished,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "LiveEventType":
        """
        The type LiveEvent
        """

        return _UniffiConverterTypeLiveEventType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_liveevent_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeLiveEvent:

    @staticmethod
    def lift(value: int):
        return LiveEvent._make_instance_(value)

    @staticmethod
    def check_lower(value: LiveEvent):
        if not isinstance(value, LiveEvent):
            raise TypeError("Expected LiveEvent instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: LiveEventProtocol):
        if not isinstance(value, LiveEvent):
            raise TypeError("Expected LiveEvent instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LiveEventProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MessageProtocol(typing.Protocol):
    """
    Gossip message
    """

    def as_error(self, ):
        raise NotImplementedError
    def as_joined(self, ):
        raise NotImplementedError
    def as_neighbor_down(self, ):
        raise NotImplementedError
    def as_neighbor_up(self, ):
        raise NotImplementedError
    def as_received(self, ):
        raise NotImplementedError
    def type(self, ):
        raise NotImplementedError


class Message:
    """
    Gossip message
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_message, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_message, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_error(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_error,self._uniffi_clone_pointer(),)
        )





    def as_joined(self, ) -> "typing.List[str]":
        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_joined,self._uniffi_clone_pointer(),)
        )





    def as_neighbor_down(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_down,self._uniffi_clone_pointer(),)
        )





    def as_neighbor_up(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_neighbor_up,self._uniffi_clone_pointer(),)
        )





    def as_received(self, ) -> "MessageContent":
        return _UniffiConverterTypeMessageContent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_as_received,self._uniffi_clone_pointer(),)
        )





    def type(self, ) -> "MessageType":
        return _UniffiConverterTypeMessageType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_message_type,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMessage:

    @staticmethod
    def lift(value: int):
        return Message._make_instance_(value)

    @staticmethod
    def check_lower(value: Message):
        if not isinstance(value, Message):
            raise TypeError("Expected Message instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MessageProtocol):
        if not isinstance(value, Message):
            raise TypeError("Expected Message instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MessageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NetProtocol(typing.Protocol):
    """
    Iroh net client.
    """

    def add_node_addr(self, addr: "NodeAddr"):
        """
        Add a known node address to the node.
        """

        raise NotImplementedError
    def home_relay(self, ):
        """
        Get the relay server we are connected to.
        """

        raise NotImplementedError
    def node_addr(self, ):
        """
        Return the [`NodeAddr`] for this node.
        """

        raise NotImplementedError
    def node_id(self, ):
        """
        The string representation of the PublicKey of this node.
        """

        raise NotImplementedError
    def remote_info(self, node_id: "PublicKey"):
        """
        Return connection information on the currently running node.
        """

        raise NotImplementedError
    def remote_info_list(self, ):
        """
        Return `ConnectionInfo`s for each connection we have to another iroh node.
        """

        raise NotImplementedError


class Net:
    """
    Iroh net client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_net, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_net, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def add_node_addr(self, addr: "NodeAddr") -> None:

        """
        Add a known node address to the node.
        """

        _UniffiConverterTypeNodeAddr.check_lower(addr)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_add_node_addr(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeNodeAddr.lower(addr)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def home_relay(self, ) -> "typing.Optional[str]":
        """
        Get the relay server we are connected to.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_home_relay(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalString.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def node_addr(self, ) -> "NodeAddr":
        """
        Return the [`NodeAddr`] for this node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_node_addr(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeNodeAddr.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def node_id(self, ) -> "str":
        """
        The string representation of the PublicKey of this node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_node_id(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def remote_info(self, node_id: "PublicKey") -> "typing.Optional[RemoteInfo]":
        """
        Return connection information on the currently running node.
        """

        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePublicKey.lower(node_id)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeRemoteInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def remote_info_list(self, ) -> "typing.List[RemoteInfo]":
        """
        Return `ConnectionInfo`s for each connection we have to another iroh node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_net_remote_info_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeRemoteInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeNet:

    @staticmethod
    def lift(value: int):
        return Net._make_instance_(value)

    @staticmethod
    def check_lower(value: Net):
        if not isinstance(value, Net):
            raise TypeError("Expected Net instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NetProtocol):
        if not isinstance(value, Net):
            raise TypeError("Expected Net instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NetProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NodeProtocol(typing.Protocol):
    """
    Iroh node client.
    """

    def endpoint(self, ):
        raise NotImplementedError
    def shutdown(self, ):
        """
        Shutdown this iroh node.
        """

        raise NotImplementedError
    def stats(self, ):
        """
        Get statistics of the running node.
        """

        raise NotImplementedError
    def status(self, ):
        """
        Get status information about a node
        """

        raise NotImplementedError


class Node:
    """
    Iroh node client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_node, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_node, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def endpoint(self, ) -> "Endpoint":
        return _UniffiConverterTypeEndpoint.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_node_endpoint,self._uniffi_clone_pointer(),)
        )




    async def shutdown(self, ) -> None:

        """
        Shutdown this iroh node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_node_shutdown(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def stats(self, ) -> "dict[str, CounterStats]":
        """
        Get statistics of the running node.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_node_stats(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringTypeCounterStats.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def status(self, ) -> "NodeStatus":
        """
        Get status information about a node
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_node_status(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeNodeStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeNode:

    @staticmethod
    def lift(value: int):
        return Node._make_instance_(value)

    @staticmethod
    def check_lower(value: Node):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeProtocol):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NodeAddrProtocol(typing.Protocol):
    """
    A peer and it's addressing information.
    """

    def direct_addresses(self, ):
        """
        Get the direct addresses of this peer.
        """

        raise NotImplementedError
    def equal(self, other: "NodeAddr"):
        """
        Returns true if both NodeAddr's have the same values
        """

        raise NotImplementedError
    def relay_url(self, ):
        """
        Get the home relay URL for this peer
        """

        raise NotImplementedError


class NodeAddr:
    """
    A peer and it's addressing information.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, node_id: "PublicKey",derp_url: "typing.Optional[str]",addresses: "typing.List[str]"):
        """
        Create a new [`NodeAddr`] with empty [`AddrInfo`].
        """

        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterOptionalString.check_lower(derp_url)
        
        _UniffiConverterSequenceString.check_lower(addresses)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeaddr_new,
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterOptionalString.lower(derp_url),
        _UniffiConverterSequenceString.lower(addresses))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_nodeaddr, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeaddr, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def direct_addresses(self, ) -> "typing.List[str]":
        """
        Get the direct addresses of this peer.
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_direct_addresses,self._uniffi_clone_pointer(),)
        )





    def equal(self, other: "NodeAddr") -> "bool":
        """
        Returns true if both NodeAddr's have the same values
        """

        _UniffiConverterTypeNodeAddr.check_lower(other)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_equal,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNodeAddr.lower(other))
        )





    def relay_url(self, ) -> "typing.Optional[str]":
        """
        Get the home relay URL for this peer
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodeaddr_relay_url,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNodeAddr:

    @staticmethod
    def lift(value: int):
        return NodeAddr._make_instance_(value)

    @staticmethod
    def check_lower(value: NodeAddr):
        if not isinstance(value, NodeAddr):
            raise TypeError("Expected NodeAddr instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeAddrProtocol):
        if not isinstance(value, NodeAddr):
            raise TypeError("Expected NodeAddr instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeAddrProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NodeStatusProtocol(typing.Protocol):
    """
    The response to a status request
    """

    def listen_addrs(self, ):
        """
        The bound listening addresses of the node
        """

        raise NotImplementedError
    def node_addr(self, ):
        """
        The node id and socket addresses of this node.
        """

        raise NotImplementedError
    def rpc_addr(self, ):
        """
        The address of the RPC of the node
        """

        raise NotImplementedError
    def version(self, ):
        """
        The version of the node
        """

        raise NotImplementedError


class NodeStatus:
    """
    The response to a status request
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_nodestatus, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_nodestatus, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def listen_addrs(self, ) -> "typing.List[str]":
        """
        The bound listening addresses of the node
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_listen_addrs,self._uniffi_clone_pointer(),)
        )





    def node_addr(self, ) -> "NodeAddr":
        """
        The node id and socket addresses of this node.
        """

        return _UniffiConverterTypeNodeAddr.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_node_addr,self._uniffi_clone_pointer(),)
        )





    def rpc_addr(self, ) -> "typing.Optional[str]":
        """
        The address of the RPC of the node
        """

        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_rpc_addr,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "str":
        """
        The version of the node
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodestatus_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNodeStatus:

    @staticmethod
    def lift(value: int):
        return NodeStatus._make_instance_(value)

    @staticmethod
    def check_lower(value: NodeStatus):
        if not isinstance(value, NodeStatus):
            raise TypeError("Expected NodeStatus instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeStatusProtocol):
        if not isinstance(value, NodeStatus):
            raise TypeError("Expected NodeStatus instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeStatusProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NodeTicketProtocol(typing.Protocol):
    """
    A token containing information for establishing a connection to a node.

    This allows establishing a connection to the node in most circumstances where it is
    possible to do so.

    It is a single item which can be easily serialized and deserialized.
    """

    def node_addr(self, ):
        """
        The [`NodeAddr`] of the provider for this ticket.
        """

        raise NotImplementedError


class NodeTicket:
    """
    A token containing information for establishing a connection to a node.

    This allows establishing a connection to the node in most circumstances where it is
    possible to do so.

    It is a single item which can be easily serialized and deserialized.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, addr: "NodeAddr"):
        """
        Wrap the given [`NodeAddr`] as a [`NodeTicket`].

        The returned ticket can easily be deserialized using its string presentation, and
        later parsed again using [`Self::parse`].
        """

        _UniffiConverterTypeNodeAddr.check_lower(addr)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_new,
        _UniffiConverterTypeNodeAddr.lower(addr))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_nodeticket, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_nodeticket, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def parse(cls, str: "str"):
        """
        Parse back a [`NodeTicket`] from its string presentation.
        """

        _UniffiConverterString.check_lower(str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_nodeticket_parse,
        _UniffiConverterString.lower(str))
        return cls._make_instance_(pointer)



    def node_addr(self, ) -> "NodeAddr":
        """
        The [`NodeAddr`] of the provider for this ticket.
        """

        return _UniffiConverterTypeNodeAddr.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_node_addr,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_nodeticket_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNodeTicket:

    @staticmethod
    def lift(value: int):
        return NodeTicket._make_instance_(value)

    @staticmethod
    def check_lower(value: NodeTicket):
        if not isinstance(value, NodeTicket):
            raise TypeError("Expected NodeTicket instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeTicketProtocol):
        if not isinstance(value, NodeTicket):
            raise TypeError("Expected NodeTicket instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeTicketProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ProtocolCreator(typing.Protocol):
    def create(self, endpoint: "Endpoint"):
        raise NotImplementedError


class ProtocolCreatorImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_protocolcreator, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolcreator, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def create(self, endpoint: "Endpoint") -> "ProtocolHandler":
        _UniffiConverterTypeEndpoint.check_lower(endpoint)
        
        return _UniffiConverterTypeProtocolHandler.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_protocolcreator_create,self._uniffi_clone_pointer(),
        _UniffiConverterTypeEndpoint.lower(endpoint))
        )





# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplProtocolCreator:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_CREATOR_METHOD0
    def create(
            uniffi_handle,
            endpoint,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeProtocolCreator._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeEndpoint.lift(endpoint), )
            method = uniffi_obj.create
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypeProtocolHandler.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeProtocolCreator._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceProtocolCreator(
        create,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolcreator(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeProtocolCreator:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return ProtocolCreatorImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: ProtocolCreator):
        pass

    @staticmethod
    def lower(value: ProtocolCreator):
        return _UniffiConverterTypeProtocolCreator._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ProtocolCreator, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ProtocolHandler(typing.Protocol):
    def accept(self, conn: "Connection"):
        raise NotImplementedError
    def shutdown(self, ):
        raise NotImplementedError


class ProtocolHandlerImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_protocolhandler, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_protocolhandler, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def accept(self, conn: "Connection") -> None:

        _UniffiConverterTypeConnection.check_lower(conn)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_accept(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeConnection.lower(conn)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )



    async def shutdown(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_protocolhandler_shutdown(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter

    None,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplProtocolHandler:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD0
    def accept(
            uniffi_handle,
            conn,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeProtocolHandler._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeConnection.lift(conn), )
            method = uniffi_obj.accept
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_PROTOCOL_HANDLER_METHOD1
    def shutdown(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeProtocolHandler._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.shutdown
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async(make_call, handle_success, handle_error)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeProtocolHandler._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceProtocolHandler(
        accept,
        shutdown,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_protocolhandler(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeProtocolHandler:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return ProtocolHandlerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: ProtocolHandler):
        pass

    @staticmethod
    def lower(value: ProtocolHandler):
        return _UniffiConverterTypeProtocolHandler._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ProtocolHandler, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PublicKeyProtocol(typing.Protocol):
    """
    A public key.

    The key itself is just a 32 byte array, but a key has associated crypto
    information that is cached for performance reasons.
    """

    def equal(self, other: "PublicKey"):
        """
        Returns true if the PublicKeys are equal
        """

        raise NotImplementedError
    def fmt_short(self, ):
        """
        Convert to a base32 string limited to the first 10 bytes for a friendly string
        representation of the key.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Express the PublicKey as a byte array
        """

        raise NotImplementedError


class PublicKey:
    """
    A public key.

    The key itself is just a 32 byte array, but a key has associated crypto
    information that is cached for performance reasons.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        """
        Make a PublicKey from byte array
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_string(cls, s: "str"):
        """
        Make a PublicKey from base32 string
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_constructor_publickey_from_string,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def equal(self, other: "PublicKey") -> "bool":
        """
        Returns true if the PublicKeys are equal
        """

        _UniffiConverterTypePublicKey.check_lower(other)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_equal,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(other))
        )





    def fmt_short(self, ) -> "str":
        """
        Convert to a base32 string limited to the first 10 bytes for a friendly string
        representation of the key.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_fmt_short,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        """
        Express the PublicKey as a byte array
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_publickey_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePublicKey:

    @staticmethod
    def lift(value: int):
        return PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: PublicKey):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PublicKeyProtocol):
        if not isinstance(value, PublicKey):
            raise TypeError("Expected PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class QueryProtocol(typing.Protocol):
    """
    Build a Query to search for an entry or entries in a doc.

    Use this with `QueryOptions` to determine sorting, grouping, and pagination.
    """

    def limit(self, ):
        """
        Get the limit for this query (max. number of entries to emit).
        """

        raise NotImplementedError
    def offset(self, ):
        """
        Get the offset for this query (number of entries to skip at the beginning).
        """

        raise NotImplementedError


class Query:
    """
    Build a Query to search for an entry or entries in a doc.

    Use this with `QueryOptions` to determine sorting, grouping, and pagination.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_query, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_query, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def all(cls, opts: "typing.Optional[QueryOptions]"):
        """
        Query all records.

        If `opts` is `None`, the default values will be used:
        sort_by: SortBy::AuthorKey
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_all,
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def author(cls, author: "AuthorId",opts: "typing.Optional[QueryOptions]"):
        """
        Query all entries for by a single author.

        If `opts` is `None`, the default values will be used:
        sort_by: SortBy::AuthorKey
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def author_key_exact(cls, author: "AuthorId",key: "bytes"):
        """
        Create a Query for a single key and author.
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        _UniffiConverterBytes.check_lower(key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_exact,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(key))
        return cls._make_instance_(pointer)

    @classmethod
    def author_key_prefix(cls, author: "AuthorId",prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
        """
        Create a query for all entries of a single author with a given key prefix.

        If `opts` is `None`, the default values will be used:
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterTypeAuthorId.check_lower(author)
        
        _UniffiConverterBytes.check_lower(prefix)
        
        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_author_key_prefix,
        _UniffiConverterTypeAuthorId.lower(author),
        _UniffiConverterBytes.lower(prefix),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def key_exact(cls, key: "bytes",opts: "typing.Optional[QueryOptions]"):
        """
        Query all entries that have an exact key.

        If `opts` is `None`, the default values will be used:
        sort_by: SortBy::AuthorKey
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterBytes.check_lower(key)
        
        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_exact,
        _UniffiConverterBytes.lower(key),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def key_prefix(cls, prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
        """
        Create a query for all entries with a given key prefix.

        If `opts` is `None`, the default values will be used:
        sort_by: SortBy::AuthorKey
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterBytes.check_lower(prefix)
        
        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_key_prefix,
        _UniffiConverterBytes.lower(prefix),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def single_latest_per_key(cls, opts: "typing.Optional[QueryOptions]"):
        """
        Query only the latest entry for each key, omitting older entries if the entry was written
        to by multiple authors.

        If `opts` is `None`, the default values will be used:
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key,
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)

    @classmethod
    def single_latest_per_key_exact(cls, key: "bytes"):
        """
        Query exactly the key, but only the latest entry for it, omitting older entries if the entry was written
        to by multiple authors.
        """

        _UniffiConverterBytes.check_lower(key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_exact,
        _UniffiConverterBytes.lower(key))
        return cls._make_instance_(pointer)

    @classmethod
    def single_latest_per_key_prefix(cls, prefix: "bytes",opts: "typing.Optional[QueryOptions]"):
        """
        Query only the latest entry for each key, with this prefix, omitting older entries if the entry was written
        to by multiple authors.

        If `opts` is `None`, the default values will be used:
        direction: SortDirection::Asc
        offset: None
        limit: None
        """

        _UniffiConverterBytes.check_lower(prefix)
        
        _UniffiConverterOptionalTypeQueryOptions.check_lower(opts)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_query_single_latest_per_key_prefix,
        _UniffiConverterBytes.lower(prefix),
        _UniffiConverterOptionalTypeQueryOptions.lower(opts))
        return cls._make_instance_(pointer)



    def limit(self, ) -> "typing.Optional[int]":
        """
        Get the limit for this query (max. number of entries to emit).
        """

        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_query_limit,self._uniffi_clone_pointer(),)
        )





    def offset(self, ) -> "int":
        """
        Get the offset for this query (number of entries to skip at the beginning).
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_query_offset,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeQuery:

    @staticmethod
    def lift(value: int):
        return Query._make_instance_(value)

    @staticmethod
    def check_lower(value: Query):
        if not isinstance(value, Query):
            raise TypeError("Expected Query instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: QueryProtocol):
        if not isinstance(value, Query):
            raise TypeError("Expected Query instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: QueryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RangeSpecProtocol(typing.Protocol):
    """
    A chunk range specification as a sequence of chunk offsets
    """

    def is_all(self, ):
        """
        Check if this [`RangeSpec`] selects all chunks in the blob
        """

        raise NotImplementedError
    def is_empty(self, ):
        """
        Checks if this [`RangeSpec`] does not select any chunks in the blob
        """

        raise NotImplementedError


class RangeSpec:
    """
    A chunk range specification as a sequence of chunk offsets
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_rangespec, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_rangespec, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def is_all(self, ) -> "bool":
        """
        Check if this [`RangeSpec`] selects all chunks in the blob
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_all,self._uniffi_clone_pointer(),)
        )





    def is_empty(self, ) -> "bool":
        """
        Checks if this [`RangeSpec`] does not select any chunks in the blob
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_method_rangespec_is_empty,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeRangeSpec:

    @staticmethod
    def lift(value: int):
        return RangeSpec._make_instance_(value)

    @staticmethod
    def check_lower(value: RangeSpec):
        if not isinstance(value, RangeSpec):
            raise TypeError("Expected RangeSpec instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RangeSpecProtocol):
        if not isinstance(value, RangeSpec):
            raise TypeError("Expected RangeSpec instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RangeSpecProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ReadAtLenProtocol(typing.Protocol):
    """
    Defines the way to read bytes.
    """

    pass


class ReadAtLen:
    """
    Defines the way to read bytes.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_readatlen, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_readatlen, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def all(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_all,)
        return cls._make_instance_(pointer)

    @classmethod
    def at_most(cls, size: "int"):
        _UniffiConverterUInt64.check_lower(size)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_at_most,
        _UniffiConverterUInt64.lower(size))
        return cls._make_instance_(pointer)

    @classmethod
    def exact(cls, size: "int"):
        _UniffiConverterUInt64.check_lower(size)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_readatlen_exact,
        _UniffiConverterUInt64.lower(size))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeReadAtLen:

    @staticmethod
    def lift(value: int):
        return ReadAtLen._make_instance_(value)

    @staticmethod
    def check_lower(value: ReadAtLen):
        if not isinstance(value, ReadAtLen):
            raise TypeError("Expected ReadAtLen instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ReadAtLenProtocol):
        if not isinstance(value, ReadAtLen):
            raise TypeError("Expected ReadAtLen instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ReadAtLenProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RecvStreamProtocol(typing.Protocol):
    def id(self, ):
        raise NotImplementedError
    def read(self, size_limit: "int"):
        raise NotImplementedError
    def read_exact(self, size: "int"):
        raise NotImplementedError
    def read_to_end(self, size_limit: "int"):
        raise NotImplementedError
    def received_reset(self, ):
        raise NotImplementedError
    def stop(self, error_code: "int"):
        raise NotImplementedError


class RecvStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_recvstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_recvstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def id(self, ) -> "str":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_id(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter

    None,

        )



    async def read(self, size_limit: "int") -> "bytes":
        _UniffiConverterUInt32.check_lower(size_limit)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(size_limit)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def read_exact(self, size: "int") -> "bytes":
        _UniffiConverterUInt32.check_lower(size)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_exact(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(size)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def read_to_end(self, size_limit: "int") -> "bytes":
        _UniffiConverterUInt32.check_lower(size_limit)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_read_to_end(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt32.lower(size_limit)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def received_reset(self, ) -> "typing.Optional[int]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_received_reset(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def stop(self, error_code: "int") -> None:

        _UniffiConverterUInt64.check_lower(error_code)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_recvstream_stop(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(error_code)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeRecvStream:

    @staticmethod
    def lift(value: int):
        return RecvStream._make_instance_(value)

    @staticmethod
    def check_lower(value: RecvStream):
        if not isinstance(value, RecvStream):
            raise TypeError("Expected RecvStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RecvStreamProtocol):
        if not isinstance(value, RecvStream):
            raise TypeError("Expected RecvStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RecvStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SendStreamProtocol(typing.Protocol):
    def finish(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def priority(self, ):
        raise NotImplementedError
    def reset(self, error_code: "int"):
        raise NotImplementedError
    def set_priority(self, p: "int"):
        raise NotImplementedError
    def stopped(self, ):
        raise NotImplementedError
    def write(self, buf: "bytes"):
        raise NotImplementedError
    def write_all(self, buf: "bytes"):
        raise NotImplementedError


class SendStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_sendstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_sendstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def finish(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_finish(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def id(self, ) -> "str":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_id(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter

    None,

        )



    async def priority(self, ) -> "int":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_priority(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_i32,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_i32,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_i32,
            # lift function
            _UniffiConverterInt32.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def reset(self, error_code: "int") -> None:

        _UniffiConverterUInt64.check_lower(error_code)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_reset(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(error_code)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def set_priority(self, p: "int") -> None:

        _UniffiConverterInt32.check_lower(p)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_set_priority(
                self._uniffi_clone_pointer(), 
        _UniffiConverterInt32.lower(p)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def stopped(self, ) -> "typing.Optional[int]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_stopped(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def write(self, buf: "bytes") -> "int":
        _UniffiConverterBytes.check_lower(buf)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(buf)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def write_all(self, buf: "bytes") -> None:

        _UniffiConverterBytes.check_lower(buf)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sendstream_write_all(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(buf)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeSendStream:

    @staticmethod
    def lift(value: int):
        return SendStream._make_instance_(value)

    @staticmethod
    def check_lower(value: SendStream):
        if not isinstance(value, SendStream):
            raise TypeError("Expected SendStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SendStreamProtocol):
        if not isinstance(value, SendStream):
            raise TypeError("Expected SendStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SendStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SenderProtocol(typing.Protocol):
    """
    Gossip sender
    """

    def broadcast(self, msg: "bytes"):
        """
        Broadcast a message to all nodes in the swarm
        """

        raise NotImplementedError
    def broadcast_neighbors(self, msg: "bytes"):
        """
        Broadcast a message to all direct neighbors.
        """

        raise NotImplementedError
    def cancel(self, ):
        """
        Closes the subscription, it is an error to use it afterwards
        """

        raise NotImplementedError


class Sender:
    """
    Gossip sender
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_sender, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_sender, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def broadcast(self, msg: "bytes") -> None:

        """
        Broadcast a message to all nodes in the swarm
        """

        _UniffiConverterBytes.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(msg)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def broadcast_neighbors(self, msg: "bytes") -> None:

        """
        Broadcast a message to all direct neighbors.
        """

        _UniffiConverterBytes.check_lower(msg)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sender_broadcast_neighbors(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(msg)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def cancel(self, ) -> None:

        """
        Closes the subscription, it is an error to use it afterwards
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_sender_cancel(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeSender:

    @staticmethod
    def lift(value: int):
        return Sender._make_instance_(value)

    @staticmethod
    def check_lower(value: Sender):
        if not isinstance(value, Sender):
            raise TypeError("Expected Sender instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SenderProtocol):
        if not isinstance(value, Sender):
            raise TypeError("Expected Sender instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SenderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SetTagOptionProtocol(typing.Protocol):
    """
    An option for commands that allow setting a Tag
    """

    pass


class SetTagOption:
    """
    An option for commands that allow setting a Tag
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_settagoption, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_settagoption, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def auto(cls, ):
        """
        Indicate you want an automatically generated tag
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_auto,)
        return cls._make_instance_(pointer)

    @classmethod
    def named(cls, tag: "bytes"):
        """
        Indicate you want a named tag
        """

        _UniffiConverterBytes.check_lower(tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_settagoption_named,
        _UniffiConverterBytes.lower(tag))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeSetTagOption:

    @staticmethod
    def lift(value: int):
        return SetTagOption._make_instance_(value)

    @staticmethod
    def check_lower(value: SetTagOption):
        if not isinstance(value, SetTagOption):
            raise TypeError("Expected SetTagOption instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SetTagOptionProtocol):
        if not isinstance(value, SetTagOption):
            raise TypeError("Expected SetTagOption instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SetTagOptionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SubscribeCallback(typing.Protocol):
    """
    The `progress` method will be called for each `SubscribeProgress` event that is
    emitted during a `node.doc_subscribe`. Use the `SubscribeProgress.type()`
    method to check the `LiveEvent`
    """

    def event(self, event: "LiveEvent"):
        raise NotImplementedError


class SubscribeCallbackImpl:
    """
    The `progress` method will be called for each `SubscribeProgress` event that is
    emitted during a `node.doc_subscribe`. Use the `SubscribeProgress.type()`
    method to check the `LiveEvent`
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_subscribecallback, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_subscribecallback, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def event(self, event: "LiveEvent") -> None:

        _UniffiConverterTypeLiveEvent.check_lower(event)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_subscribecallback_event(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeLiveEvent.lower(event)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeCallbackError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplSubscribeCallback:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_SUBSCRIBE_CALLBACK_METHOD0
    def event(
            uniffi_handle,
            event,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeSubscribeCallback._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeLiveEvent.lift(event), )
            method = uniffi_obj.event
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, CallbackError, _UniffiConverterTypeCallbackError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeSubscribeCallback._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceSubscribeCallback(
        event,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_iroh_ffi_fn_init_callback_vtable_subscribecallback(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeSubscribeCallback:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return SubscribeCallbackImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: SubscribeCallback):
        pass

    @staticmethod
    def lower(value: SubscribeCallback):
        return _UniffiConverterTypeSubscribeCallback._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SubscribeCallback, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TagsProtocol(typing.Protocol):
    """
    Iroh tags client.
    """

    def delete(self, name: "bytes"):
        """
        Delete a tag
        """

        raise NotImplementedError
    def list(self, ):
        """
        List all tags

        Note: this allocates for each `ListTagsResponse`, if you have many `Tags`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        raise NotImplementedError


class Tags:
    """
    Iroh tags client.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_tags, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_tags, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def delete(self, name: "bytes") -> None:

        """
        Delete a tag
        """

        _UniffiConverterBytes.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_tags_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(name)
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )



    async def list(self, ) -> "typing.List[TagInfo]":
        """
        List all tags

        Note: this allocates for each `ListTagsResponse`, if you have many `Tags`s this may be a prohibitively large list.
        Please file an [issue](https://github.com/n0-computer/iroh-ffi/issues/new) if you run into this issue
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iroh_ffi_fn_method_tags_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iroh_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iroh_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeTagInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeIrohError__as_error,

        )





class _UniffiConverterTypeTags:

    @staticmethod
    def lift(value: int):
        return Tags._make_instance_(value)

    @staticmethod
    def check_lower(value: Tags):
        if not isinstance(value, Tags):
            raise TypeError("Expected Tags instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TagsProtocol):
        if not isinstance(value, Tags):
            raise TypeError("Expected Tags instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TagsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class WrapOptionProtocol(typing.Protocol):
    """
    Whether to wrap the added data in a collection.
    """

    pass


class WrapOption:
    """
    Whether to wrap the added data in a collection.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_free_wrapoption, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_clone_wrapoption, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def no_wrap(cls, ):
        """
        Indicate you do not wrap the file or directory.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_no_wrap,)
        return cls._make_instance_(pointer)

    @classmethod
    def wrap(cls, name: "typing.Optional[str]"):
        """
        Indicate you want to wrap the file or directory in a colletion, with an optional name
        """

        _UniffiConverterOptionalString.check_lower(name)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_constructor_wrapoption_wrap,
        _UniffiConverterOptionalString.lower(name))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeWrapOption:

    @staticmethod
    def lift(value: int):
        return WrapOption._make_instance_(value)

    @staticmethod
    def check_lower(value: WrapOption):
        if not isinstance(value, WrapOption):
            raise TypeError("Expected WrapOption instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: WrapOptionProtocol):
        if not isinstance(value, WrapOption):
            raise TypeError("Expected WrapOption instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WrapOptionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AddProgressAbort:
    """
    An AddProgress event indicating we got an error and need to abort
    """

    error: "str"
    def __init__(self, *, error: "str"):
        self.error = error

    def __str__(self):
        return "AddProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeAddProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class AddProgressAllDone:
    """
    An AddProgress event indicating we are done with the the whole operation
    """

    hash: "Hash"
    """
    The hash of the created data.
    """

    format: "BlobFormat"
    """
    The format of the added data.
    """

    tag: "bytes"
    """
    The tag of the added data.
    """

    def __init__(self, *, hash: "Hash", format: "BlobFormat", tag: "bytes"):
        self.hash = hash
        self.format = format
        self.tag = tag

    def __str__(self):
        return "AddProgressAllDone(hash={}, format={}, tag={})".format(self.hash, self.format, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.format != other.format:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeAddProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressAllDone(
            hash=_UniffiConverterTypeHash.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterTypeBlobFormat.check_lower(value.format)
        _UniffiConverterBytes.check_lower(value.tag)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class AddProgressDone:
    """
    An AddProgress event indicated we are done with `id` and now have a hash `hash`
    """

    id: "int"
    """
    The unique id of the entry.
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    def __init__(self, *, id: "int", hash: "Hash"):
        self.id = id
        self.hash = hash

    def __str__(self):
        return "AddProgressDone(id={}, hash={})".format(self.id, self.hash)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeAddProgressDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressDone(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class AddProgressFound:
    """
    An AddProgress event indicating an item was found with name `name`, that can be referred to by `id`
    """

    id: "int"
    """
    A new unique id for this entry.
    """

    name: "str"
    """
    The name of the entry.
    """

    size: "int"
    """
    The size of the entry in bytes.
    """

    def __init__(self, *, id: "int", name: "str", size: "int"):
        self.id = id
        self.name = name
        self.size = size

    def __str__(self):
        return "AddProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeAddProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterString.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterUInt64.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class AddProgressProgress:
    """
    An AddProgress event indicating we got progress ingesting item `id`.
    """

    id: "int"
    """
    The unique id of the entry.
    """

    offset: "int"
    """
    The offset of the progress, in bytes.
    """

    def __init__(self, *, id: "int", offset: "int"):
        self.id = id
        self.offset = offset

    def __str__(self):
        return "AddProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeAddProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class BlobAddOutcome:
    """
    Outcome of a blob add operation.
    """

    hash: "Hash"
    """
    The hash of the blob
    """

    format: "BlobFormat"
    """
    The format the blob
    """

    size: "int"
    """
    The size of the blob
    """

    tag: "bytes"
    """
    The tag of the blob
    """

    def __init__(self, *, hash: "Hash", format: "BlobFormat", size: "int", tag: "bytes"):
        self.hash = hash
        self.format = format
        self.size = size
        self.tag = tag

    def __str__(self):
        return "BlobAddOutcome(hash={}, format={}, size={}, tag={})".format(self.hash, self.format, self.size, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.format != other.format:
            return False
        if self.size != other.size:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeBlobAddOutcome(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobAddOutcome(
            hash=_UniffiConverterTypeHash.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterTypeBlobFormat.check_lower(value.format)
        _UniffiConverterUInt64.check_lower(value.size)
        _UniffiConverterBytes.check_lower(value.tag)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class BlobInfo:
    """
    A response to a list blobs request
    """

    path: "str"
    """
    Location of the blob
    """

    hash: "Hash"
    """
    The hash of the blob
    """

    size: "int"
    """
    The size of the blob
    """

    def __init__(self, *, path: "str", hash: "Hash", size: "int"):
        self.path = path
        self.hash = hash
        self.size = size

    def __str__(self):
        return "BlobInfo(path={}, hash={}, size={})".format(self.path, self.hash, self.size)

    def __eq__(self, other):
        if self.path != other.path:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeBlobInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlobInfo(
            path=_UniffiConverterString.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.path)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.path, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class ClientConnected:
    """
    A new client connected to the node.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    def __init__(self, *, connection_id: "int"):
        self.connection_id = connection_id

    def __str__(self):
        return "ClientConnected(connection_id={})".format(self.connection_id)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        return True

class _UniffiConverterTypeClientConnected(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ClientConnected(
            connection_id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)


class CollectionInfo:
    """
    A response to a list collections request
    """

    tag: "bytes"
    """
    Tag of the collection
    """

    hash: "Hash"
    """
    Hash of the collection
    """

    total_blobs_count: "typing.Optional[int]"
    """
    Number of children in the collection

    This is an optional field, because the data is not always available.
    """

    total_blobs_size: "typing.Optional[int]"
    """
    Total size of the raw data referred to by all links

    This is an optional field, because the data is not always available.
    """

    def __init__(self, *, tag: "bytes", hash: "Hash", total_blobs_count: "typing.Optional[int]", total_blobs_size: "typing.Optional[int]"):
        self.tag = tag
        self.hash = hash
        self.total_blobs_count = total_blobs_count
        self.total_blobs_size = total_blobs_size

    def __str__(self):
        return "CollectionInfo(tag={}, hash={}, total_blobs_count={}, total_blobs_size={})".format(self.tag, self.hash, self.total_blobs_count, self.total_blobs_size)

    def __eq__(self, other):
        if self.tag != other.tag:
            return False
        if self.hash != other.hash:
            return False
        if self.total_blobs_count != other.total_blobs_count:
            return False
        if self.total_blobs_size != other.total_blobs_size:
            return False
        return True

class _UniffiConverterTypeCollectionInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CollectionInfo(
            tag=_UniffiConverterBytes.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            total_blobs_count=_UniffiConverterOptionalUInt64.read(buf),
            total_blobs_size=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.tag)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterOptionalUInt64.check_lower(value.total_blobs_count)
        _UniffiConverterOptionalUInt64.check_lower(value.total_blobs_size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.tag, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterOptionalUInt64.write(value.total_blobs_count, buf)
        _UniffiConverterOptionalUInt64.write(value.total_blobs_size, buf)


class ConnectionTypeMixed:
    """
    The socket address and url of the mixed connection
    """

    addr: "str"
    """
    Address of the node
    """

    relay_url: "str"
    """
    Url of the relay node to which the node is connected
    """

    def __init__(self, *, addr: "str", relay_url: "str"):
        self.addr = addr
        self.relay_url = relay_url

    def __str__(self):
        return "ConnectionTypeMixed(addr={}, relay_url={})".format(self.addr, self.relay_url)

    def __eq__(self, other):
        if self.addr != other.addr:
            return False
        if self.relay_url != other.relay_url:
            return False
        return True

class _UniffiConverterTypeConnectionTypeMixed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConnectionTypeMixed(
            addr=_UniffiConverterString.read(buf),
            relay_url=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.addr)
        _UniffiConverterString.check_lower(value.relay_url)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.addr, buf)
        _UniffiConverterString.write(value.relay_url, buf)


class CounterStats:
    """
    Stats counter
    """

    value: "int"
    """
    The counter value
    """

    description: "str"
    """
    The counter description
    """

    def __init__(self, *, value: "int", description: "str"):
        self.value = value
        self.description = description

    def __str__(self):
        return "CounterStats(value={}, description={})".format(self.value, self.description)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeCounterStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CounterStats(
            value=_UniffiConverterUInt32.read(buf),
            description=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.value)
        _UniffiConverterString.check_lower(value.description)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.value, buf)
        _UniffiConverterString.write(value.description, buf)


class DocExportProgressAbort:
    """
    A DocExportProgress event indicating we got an error and need to abort
    """

    error: "str"
    """
    The error message
    """

    def __init__(self, *, error: "str"):
        self.error = error

    def __str__(self):
        return "DocExportProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDocExportProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DocExportProgressDone:
    """
    A DocExportProgress event indicating a single blob wit `id` is done
    """

    id: "int"
    """
    The unique id of the entry.
    """

    def __init__(self, *, id: "int"):
        self.id = id

    def __str__(self):
        return "DocExportProgressDone(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class _UniffiConverterTypeDocExportProgressDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressDone(
            id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)


class DocExportProgressFound:
    """
    A DocExportProgress event indicating a file was found with name `name`, from now on referred to via `id`
    """

    id: "int"
    """
    A new unique id for this entry.
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    size: "int"
    """
    The size of the entry in bytes.
    """

    outpath: "str"
    """
    The path where we are writing the entry
    """

    def __init__(self, *, id: "int", hash: "Hash", size: "int", outpath: "str"):
        self.id = id
        self.hash = hash
        self.size = size
        self.outpath = outpath

    def __str__(self):
        return "DocExportProgressFound(id={}, hash={}, size={}, outpath={})".format(self.id, self.hash, self.size, self.outpath)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        if self.outpath != other.outpath:
            return False
        return True

class _UniffiConverterTypeDocExportProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            outpath=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.size)
        _UniffiConverterString.check_lower(value.outpath)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterString.write(value.outpath, buf)


class DocExportProgressProgress:
    """
    A DocExportProgress event indicating we've made progress exporting item `id`.
    """

    id: "int"
    """
    The unique id of the entry.
    """

    offset: "int"
    """
    The offset of the progress, in bytes.
    """

    def __init__(self, *, id: "int", offset: "int"):
        self.id = id
        self.offset = offset

    def __str__(self):
        return "DocExportProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDocExportProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocExportProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class DocImportProgressAbort:
    """
    A DocImportProgress event indicating we got an error and need to abort
    """

    error: "str"
    """
    The error message
    """

    def __init__(self, *, error: "str"):
        self.error = error

    def __str__(self):
        return "DocImportProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDocImportProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DocImportProgressAllDone:
    """
    A DocImportProgress event indicating we are done setting the entry to the doc
    """

    key: "bytes"
    """
    The key of the entry
    """

    def __init__(self, *, key: "bytes"):
        self.key = key

    def __str__(self):
        return "DocImportProgressAllDone(key={})".format(self.key)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeDocImportProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressAllDone(
            key=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.key, buf)


class DocImportProgressFound:
    """
    A DocImportProgress event indicating a file was found with name `name`, from now on referred to via `id`
    """

    id: "int"
    """
    A new unique id for this entry.
    """

    name: "str"
    """
    The name of the entry.
    """

    size: "int"
    """
    The size of the entry in bytes.
    """

    def __init__(self, *, id: "int", name: "str", size: "int"):
        self.id = id
        self.name = name
        self.size = size

    def __str__(self):
        return "DocImportProgressFound(id={}, name={}, size={})".format(self.id, self.name, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeDocImportProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterString.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterUInt64.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class DocImportProgressIngestDone:
    """
    A DocImportProgress event indicating we are finished adding `id` to the data store and the hash is `hash`.
    """

    id: "int"
    """
    The unique id of the entry.
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    def __init__(self, *, id: "int", hash: "Hash"):
        self.id = id
        self.hash = hash

    def __str__(self):
        return "DocImportProgressIngestDone(id={}, hash={})".format(self.id, self.hash)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeDocImportProgressIngestDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressIngestDone(
            id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class DocImportProgressProgress:
    """
    A DocImportProgress event indicating we've made progress ingesting item `id`.
    """

    id: "int"
    """
    The unique id of the entry.
    """

    offset: "int"
    """
    The offset of the progress, in bytes.
    """

    def __init__(self, *, id: "int", offset: "int"):
        self.id = id
        self.offset = offset

    def __str__(self):
        return "DocImportProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDocImportProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DocImportProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class DownloadProgressAbort:
    """
    A DownloadProgress event indicating we got an error and need to abort
    """

    error: "str"
    def __init__(self, *, error: "str"):
        self.error = error

    def __str__(self):
        return "DownloadProgressAbort(error={})".format(self.error)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDownloadProgressAbort(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressAbort(
            error=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.error, buf)


class DownloadProgressAllDone:
    """
    A DownloadProgress event indicating we are done with the whole operation
    """

    bytes_written: "int"
    """
    The number of bytes written
    """

    bytes_read: "int"
    """
    The number of bytes read
    """

    elapsed: "Duration"
    """
    The time it took to transfer the data
    """

    def __init__(self, *, bytes_written: "int", bytes_read: "int", elapsed: "Duration"):
        self.bytes_written = bytes_written
        self.bytes_read = bytes_read
        self.elapsed = elapsed

    def __str__(self):
        return "DownloadProgressAllDone(bytes_written={}, bytes_read={}, elapsed={})".format(self.bytes_written, self.bytes_read, self.elapsed)

    def __eq__(self, other):
        if self.bytes_written != other.bytes_written:
            return False
        if self.bytes_read != other.bytes_read:
            return False
        if self.elapsed != other.elapsed:
            return False
        return True

class _UniffiConverterTypeDownloadProgressAllDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressAllDone(
            bytes_written=_UniffiConverterUInt64.read(buf),
            bytes_read=_UniffiConverterUInt64.read(buf),
            elapsed=_UniffiConverterDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.bytes_written)
        _UniffiConverterUInt64.check_lower(value.bytes_read)
        _UniffiConverterDuration.check_lower(value.elapsed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.bytes_written, buf)
        _UniffiConverterUInt64.write(value.bytes_read, buf)
        _UniffiConverterDuration.write(value.elapsed, buf)


class DownloadProgressDone:
    """
    A DownloadProgress event indicated we are done with `id`
    """

    id: "int"
    """
    The unique id of the entry.
    """

    def __init__(self, *, id: "int"):
        self.id = id

    def __str__(self):
        return "DownloadProgressDone(id={})".format(self.id)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        return True

class _UniffiConverterTypeDownloadProgressDone(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressDone(
            id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)


class DownloadProgressFound:
    """
    A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`
    """

    id: "int"
    """
    A new unique id for this entry.
    """

    child: "int"
    """
    child offset
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    size: "int"
    """
    The size of the entry in bytes.
    """

    def __init__(self, *, id: "int", child: "int", hash: "Hash", size: "int"):
        self.id = id
        self.child = child
        self.hash = hash
        self.size = size

    def __str__(self):
        return "DownloadProgressFound(id={}, child={}, hash={}, size={})".format(self.id, self.child, self.hash, self.size)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.child != other.child:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFound(
            id=_UniffiConverterUInt64.read(buf),
            child=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.child)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.child, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class DownloadProgressFoundHashSeq:
    """
    A DownloadProgress event indicating an item was found with hash `hash`, that can be referred to by `id`
    """

    children: "int"
    """
    Number of children in the collection, if known.
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    def __init__(self, *, children: "int", hash: "Hash"):
        self.children = children
        self.hash = hash

    def __str__(self):
        return "DownloadProgressFoundHashSeq(children={}, hash={})".format(self.children, self.hash)

    def __eq__(self, other):
        if self.children != other.children:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFoundHashSeq(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFoundHashSeq(
            children=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.children)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.children, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class DownloadProgressFoundLocal:
    """
    A DownloadProgress event indicating an entry was found locally
    """

    child: "int"
    """
    child offset
    """

    hash: "Hash"
    """
    The hash of the entry.
    """

    size: "int"
    """
    The size of the entry in bytes.
    """

    valid_ranges: "RangeSpec"
    """
    The ranges that are available locally.
    """

    def __init__(self, *, child: "int", hash: "Hash", size: "int", valid_ranges: "RangeSpec"):
        self.child = child
        self.hash = hash
        self.size = size
        self.valid_ranges = valid_ranges

    def __str__(self):
        return "DownloadProgressFoundLocal(child={}, hash={}, size={}, valid_ranges={})".format(self.child, self.hash, self.size, self.valid_ranges)

    def __eq__(self, other):
        if self.child != other.child:
            return False
        if self.hash != other.hash:
            return False
        if self.size != other.size:
            return False
        if self.valid_ranges != other.valid_ranges:
            return False
        return True

class _UniffiConverterTypeDownloadProgressFoundLocal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressFoundLocal(
            child=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            size=_UniffiConverterUInt64.read(buf),
            valid_ranges=_UniffiConverterTypeRangeSpec.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.child)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.size)
        _UniffiConverterTypeRangeSpec.check_lower(value.valid_ranges)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.child, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterTypeRangeSpec.write(value.valid_ranges, buf)


class DownloadProgressInitialState:
    connected: "bool"
    """
    Whether we are connected to a node
    """

    def __init__(self, *, connected: "bool"):
        self.connected = connected

    def __str__(self):
        return "DownloadProgressInitialState(connected={})".format(self.connected)

    def __eq__(self, other):
        if self.connected != other.connected:
            return False
        return True

class _UniffiConverterTypeDownloadProgressInitialState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressInitialState(
            connected=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.connected)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.connected, buf)


class DownloadProgressProgress:
    """
    A DownloadProgress event indicating we got progress ingesting item `id`.
    """

    id: "int"
    """
    The unique id of the entry.
    """

    offset: "int"
    """
    The offset of the progress, in bytes.
    """

    def __init__(self, *, id: "int", offset: "int"):
        self.id = id
        self.offset = offset

    def __str__(self):
        return "DownloadProgressProgress(id={}, offset={})".format(self.id, self.offset)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeDownloadProgressProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DownloadProgressProgress(
            id=_UniffiConverterUInt64.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterUInt64.check_lower(value.offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterUInt64.write(value.offset, buf)


class GetRequestReceived:
    """
    A request was received from a client.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this transfer request.
    """

    hash: "Hash"
    """
    The hash for which the client wants to receive data.
    """

    def __init__(self, *, connection_id: "int", request_id: "int", hash: "Hash"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.hash = hash

    def __str__(self):
        return "GetRequestReceived(connection_id={}, request_id={}, hash={})".format(self.connection_id, self.request_id, self.hash)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeGetRequestReceived(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetRequestReceived(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class HashAndTag:
    """
    The Hash and associated tag of a newly created collection
    """

    hash: "Hash"
    """
    The hash of the collection
    """

    tag: "bytes"
    """
    The tag of the collection
    """

    def __init__(self, *, hash: "Hash", tag: "bytes"):
        self.hash = hash
        self.tag = tag

    def __str__(self):
        return "HashAndTag(hash={}, tag={})".format(self.hash, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeHashAndTag(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HashAndTag(
            hash=_UniffiConverterTypeHash.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterBytes.check_lower(value.tag)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class IncompleteBlobInfo:
    """
    A response to a list blobs request
    """

    size: "int"
    """
    The size we got
    """

    expected_size: "int"
    """
    The size we expect
    """

    hash: "Hash"
    """
    The hash of the blob
    """

    def __init__(self, *, size: "int", expected_size: "int", hash: "Hash"):
        self.size = size
        self.expected_size = expected_size
        self.hash = hash

    def __str__(self):
        return "IncompleteBlobInfo(size={}, expected_size={}, hash={})".format(self.size, self.expected_size, self.hash)

    def __eq__(self, other):
        if self.size != other.size:
            return False
        if self.expected_size != other.expected_size:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeIncompleteBlobInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IncompleteBlobInfo(
            size=_UniffiConverterUInt64.read(buf),
            expected_size=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.size)
        _UniffiConverterUInt64.check_lower(value.expected_size)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.size, buf)
        _UniffiConverterUInt64.write(value.expected_size, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class InsertRemoteEvent:
    """
    Outcome of an InsertRemove event.
    """

    _from: "PublicKey"
    """
    The peer that sent us the entry.
    """

    entry: "Entry"
    """
    The inserted entry.
    """

    content_status: "ContentStatus"
    """
    If the content is available at the local node
    """

    def __init__(self, *, _from: "PublicKey", entry: "Entry", content_status: "ContentStatus"):
        self._from = _from
        self.entry = entry
        self.content_status = content_status

    def __str__(self):
        return "InsertRemoteEvent(_from={}, entry={}, content_status={})".format(self._from, self.entry, self.content_status)

    def __eq__(self, other):
        if self._from != other._from:
            return False
        if self.entry != other.entry:
            return False
        if self.content_status != other.content_status:
            return False
        return True

class _UniffiConverterTypeInsertRemoteEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InsertRemoteEvent(
            _from=_UniffiConverterTypePublicKey.read(buf),
            entry=_UniffiConverterTypeEntry.read(buf),
            content_status=_UniffiConverterTypeContentStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value._from)
        _UniffiConverterTypeEntry.check_lower(value.entry)
        _UniffiConverterTypeContentStatus.check_lower(value.content_status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value._from, buf)
        _UniffiConverterTypeEntry.write(value.entry, buf)
        _UniffiConverterTypeContentStatus.write(value.content_status, buf)


class LatencyAndControlMsg:
    """
    The latency and type of the control message
    """

    latency: "Duration"
    """
    The latency of the control message
    """

    control_msg: "str"
    """
    The type of control message, represented as a string
    """

    def __init__(self, *, latency: "Duration", control_msg: "str"):
        self.latency = latency
        self.control_msg = control_msg

    def __str__(self):
        return "LatencyAndControlMsg(latency={}, control_msg={})".format(self.latency, self.control_msg)

    def __eq__(self, other):
        if self.latency != other.latency:
            return False
        if self.control_msg != other.control_msg:
            return False
        return True

class _UniffiConverterTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LatencyAndControlMsg(
            latency=_UniffiConverterDuration.read(buf),
            control_msg=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterDuration.check_lower(value.latency)
        _UniffiConverterString.check_lower(value.control_msg)

    @staticmethod
    def write(value, buf):
        _UniffiConverterDuration.write(value.latency, buf)
        _UniffiConverterString.write(value.control_msg, buf)


class LinkAndName:
    """
    `LinkAndName` includes a name and a hash for a blob in a collection
    """

    name: "str"
    """
    The name associated with this [`Hash`]
    """

    link: "Hash"
    """
    The [`Hash`] of the blob
    """

    def __init__(self, *, name: "str", link: "Hash"):
        self.name = name
        self.link = link

    def __str__(self):
        return "LinkAndName(name={}, link={})".format(self.name, self.link)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.link != other.link:
            return False
        return True

class _UniffiConverterTypeLinkAndName(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LinkAndName(
            name=_UniffiConverterString.read(buf),
            link=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterTypeHash.check_lower(value.link)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterTypeHash.write(value.link, buf)


class MessageContent:
    """
    The actual content of a gossip message.
    """

    content: "bytes"
    """
    The content of the message
    """

    delivered_from: "str"
    """
    The node that delivered the message. This is not the same as the original author.
    """

    def __init__(self, *, content: "bytes", delivered_from: "str"):
        self.content = content
        self.delivered_from = delivered_from

    def __str__(self):
        return "MessageContent(content={}, delivered_from={})".format(self.content, self.delivered_from)

    def __eq__(self, other):
        if self.content != other.content:
            return False
        if self.delivered_from != other.delivered_from:
            return False
        return True

class _UniffiConverterTypeMessageContent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MessageContent(
            content=_UniffiConverterBytes.read(buf),
            delivered_from=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.content)
        _UniffiConverterString.check_lower(value.delivered_from)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.content, buf)
        _UniffiConverterString.write(value.delivered_from, buf)


class NamespaceAndCapability:
    """
    The namespace id and CapabilityKind (read/write) of the doc
    """

    namespace: "str"
    """
    The namespace id of the doc
    """

    capability: "CapabilityKind"
    """
    The capability you have for the doc (read/write)
    """

    def __init__(self, *, namespace: "str", capability: "CapabilityKind"):
        self.namespace = namespace
        self.capability = capability

    def __str__(self):
        return "NamespaceAndCapability(namespace={}, capability={})".format(self.namespace, self.capability)

    def __eq__(self, other):
        if self.namespace != other.namespace:
            return False
        if self.capability != other.capability:
            return False
        return True

class _UniffiConverterTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NamespaceAndCapability(
            namespace=_UniffiConverterString.read(buf),
            capability=_UniffiConverterTypeCapabilityKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.namespace)
        _UniffiConverterTypeCapabilityKind.check_lower(value.capability)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.namespace, buf)
        _UniffiConverterTypeCapabilityKind.write(value.capability, buf)


class NodeOptions:
    """
    Options passed to [`IrohNode.new`]. Controls the behaviour of an iroh node.
    """

    gc_interval_millis: "typing.Optional[int]"
    """
    How frequently the blob store should clean up unreferenced blobs, in milliseconds.
    Set to 0 to disable gc
    """

    blob_events: "typing.Optional[BlobProvideEventCallback]"
    """
    Provide a callback to hook into events when the blobs component adds and provides blobs.
    """

    enable_docs: "bool"
    """
    Should docs be enabled? Defaults to `false`.
    """

    ipv4_addr: "typing.Optional[str]"
    """
    Overwrites the default IPv4 address to bind to
    """

    ipv6_addr: "typing.Optional[str]"
    """
    Overwrites the default IPv6 address to bind to
    """

    node_discovery: "typing.Optional[NodeDiscoveryConfig]"
    """
    Configure the node discovery. Defaults to the default set of config
    """

    secret_key: "typing.Optional[bytes]"
    """
    Provide a specific secret key, identifying this node. Must be 32 bytes long.
    """

    protocols: "typing.Optional[dict[bytes, ProtocolCreator]]"
    def __init__(self, *, gc_interval_millis: "typing.Optional[int]" = _DEFAULT, blob_events: "typing.Optional[BlobProvideEventCallback]" = _DEFAULT, enable_docs: "bool" = _DEFAULT, ipv4_addr: "typing.Optional[str]" = _DEFAULT, ipv6_addr: "typing.Optional[str]" = _DEFAULT, node_discovery: "typing.Optional[NodeDiscoveryConfig]" = _DEFAULT, secret_key: "typing.Optional[bytes]" = _DEFAULT, protocols: "typing.Optional[dict[bytes, ProtocolCreator]]" = _DEFAULT):
        if gc_interval_millis is _DEFAULT:
            self.gc_interval_millis = None
        else:
            self.gc_interval_millis = gc_interval_millis
        if blob_events is _DEFAULT:
            self.blob_events = None
        else:
            self.blob_events = blob_events
        if enable_docs is _DEFAULT:
            self.enable_docs = False
        else:
            self.enable_docs = enable_docs
        if ipv4_addr is _DEFAULT:
            self.ipv4_addr = None
        else:
            self.ipv4_addr = ipv4_addr
        if ipv6_addr is _DEFAULT:
            self.ipv6_addr = None
        else:
            self.ipv6_addr = ipv6_addr
        if node_discovery is _DEFAULT:
            self.node_discovery = None
        else:
            self.node_discovery = node_discovery
        if secret_key is _DEFAULT:
            self.secret_key = None
        else:
            self.secret_key = secret_key
        if protocols is _DEFAULT:
            self.protocols = None
        else:
            self.protocols = protocols

    def __str__(self):
        return "NodeOptions(gc_interval_millis={}, blob_events={}, enable_docs={}, ipv4_addr={}, ipv6_addr={}, node_discovery={}, secret_key={}, protocols={})".format(self.gc_interval_millis, self.blob_events, self.enable_docs, self.ipv4_addr, self.ipv6_addr, self.node_discovery, self.secret_key, self.protocols)

    def __eq__(self, other):
        if self.gc_interval_millis != other.gc_interval_millis:
            return False
        if self.blob_events != other.blob_events:
            return False
        if self.enable_docs != other.enable_docs:
            return False
        if self.ipv4_addr != other.ipv4_addr:
            return False
        if self.ipv6_addr != other.ipv6_addr:
            return False
        if self.node_discovery != other.node_discovery:
            return False
        if self.secret_key != other.secret_key:
            return False
        if self.protocols != other.protocols:
            return False
        return True

class _UniffiConverterTypeNodeOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeOptions(
            gc_interval_millis=_UniffiConverterOptionalUInt64.read(buf),
            blob_events=_UniffiConverterOptionalTypeBlobProvideEventCallback.read(buf),
            enable_docs=_UniffiConverterBool.read(buf),
            ipv4_addr=_UniffiConverterOptionalString.read(buf),
            ipv6_addr=_UniffiConverterOptionalString.read(buf),
            node_discovery=_UniffiConverterOptionalTypeNodeDiscoveryConfig.read(buf),
            secret_key=_UniffiConverterOptionalBytes.read(buf),
            protocols=_UniffiConverterOptionalMapBytesTypeProtocolCreator.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.gc_interval_millis)
        _UniffiConverterOptionalTypeBlobProvideEventCallback.check_lower(value.blob_events)
        _UniffiConverterBool.check_lower(value.enable_docs)
        _UniffiConverterOptionalString.check_lower(value.ipv4_addr)
        _UniffiConverterOptionalString.check_lower(value.ipv6_addr)
        _UniffiConverterOptionalTypeNodeDiscoveryConfig.check_lower(value.node_discovery)
        _UniffiConverterOptionalBytes.check_lower(value.secret_key)
        _UniffiConverterOptionalMapBytesTypeProtocolCreator.check_lower(value.protocols)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.gc_interval_millis, buf)
        _UniffiConverterOptionalTypeBlobProvideEventCallback.write(value.blob_events, buf)
        _UniffiConverterBool.write(value.enable_docs, buf)
        _UniffiConverterOptionalString.write(value.ipv4_addr, buf)
        _UniffiConverterOptionalString.write(value.ipv6_addr, buf)
        _UniffiConverterOptionalTypeNodeDiscoveryConfig.write(value.node_discovery, buf)
        _UniffiConverterOptionalBytes.write(value.secret_key, buf)
        _UniffiConverterOptionalMapBytesTypeProtocolCreator.write(value.protocols, buf)


class OpenState:
    """
    The state for an open replica.
    """

    sync: "bool"
    """
    Whether to accept sync requests for this replica.
    """

    subscribers: "int"
    """
    How many event subscriptions are open
    """

    handles: "int"
    """
    By how many handles the replica is currently held open
    """

    def __init__(self, *, sync: "bool", subscribers: "int", handles: "int"):
        self.sync = sync
        self.subscribers = subscribers
        self.handles = handles

    def __str__(self):
        return "OpenState(sync={}, subscribers={}, handles={})".format(self.sync, self.subscribers, self.handles)

    def __eq__(self, other):
        if self.sync != other.sync:
            return False
        if self.subscribers != other.subscribers:
            return False
        if self.handles != other.handles:
            return False
        return True

class _UniffiConverterTypeOpenState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenState(
            sync=_UniffiConverterBool.read(buf),
            subscribers=_UniffiConverterUInt64.read(buf),
            handles=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.sync)
        _UniffiConverterUInt64.check_lower(value.subscribers)
        _UniffiConverterUInt64.check_lower(value.handles)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.sync, buf)
        _UniffiConverterUInt64.write(value.subscribers, buf)
        _UniffiConverterUInt64.write(value.handles, buf)


class QueryOptions:
    """
    Options for sorting and pagination for using [`Query`]s.
    """

    sort_by: "SortBy"
    """
    Sort by author or key first.

    Default is [`SortBy::AuthorKey`], so sorting first by author and then by key.
    """

    direction: "SortDirection"
    """
    Direction by which to sort the entries

    Default is [`SortDirection::Asc`]
    """

    offset: "int"
    """
    Offset
    """

    limit: "int"
    """
    Limit to limit the pagination.

    When the limit is 0, the limit does not exist.
    """

    def __init__(self, *, sort_by: "SortBy", direction: "SortDirection", offset: "int", limit: "int"):
        self.sort_by = sort_by
        self.direction = direction
        self.offset = offset
        self.limit = limit

    def __str__(self):
        return "QueryOptions(sort_by={}, direction={}, offset={}, limit={})".format(self.sort_by, self.direction, self.offset, self.limit)

    def __eq__(self, other):
        if self.sort_by != other.sort_by:
            return False
        if self.direction != other.direction:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        return True

class _UniffiConverterTypeQueryOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return QueryOptions(
            sort_by=_UniffiConverterTypeSortBy.read(buf),
            direction=_UniffiConverterTypeSortDirection.read(buf),
            offset=_UniffiConverterUInt64.read(buf),
            limit=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSortBy.check_lower(value.sort_by)
        _UniffiConverterTypeSortDirection.check_lower(value.direction)
        _UniffiConverterUInt64.check_lower(value.offset)
        _UniffiConverterUInt64.check_lower(value.limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSortBy.write(value.sort_by, buf)
        _UniffiConverterTypeSortDirection.write(value.direction, buf)
        _UniffiConverterUInt64.write(value.offset, buf)
        _UniffiConverterUInt64.write(value.limit, buf)


class RemoteInfo:
    """
    Information about a remote node
    """

    node_id: "PublicKey"
    """
    The node identifier of the endpoint. Also a public key.
    """

    relay_url: "typing.Optional[str]"
    """
    Relay url, if available.
    """

    addrs: "typing.List[DirectAddrInfo]"
    """
    List of addresses at which this node might be reachable, plus any latency information we
    have about that address and the last time the address was used.
    """

    conn_type: "ConnectionType"
    """
    The type of connection we have to the peer, either direct or over relay.
    """

    latency: "typing.Optional[Duration]"
    """
    The latency of the `conn_type`.
    """

    last_used: "typing.Optional[Duration]"
    """
    Duration since the last time this peer was used.
    """

    def __init__(self, *, node_id: "PublicKey", relay_url: "typing.Optional[str]", addrs: "typing.List[DirectAddrInfo]", conn_type: "ConnectionType", latency: "typing.Optional[Duration]", last_used: "typing.Optional[Duration]"):
        self.node_id = node_id
        self.relay_url = relay_url
        self.addrs = addrs
        self.conn_type = conn_type
        self.latency = latency
        self.last_used = last_used

    def __str__(self):
        return "RemoteInfo(node_id={}, relay_url={}, addrs={}, conn_type={}, latency={}, last_used={})".format(self.node_id, self.relay_url, self.addrs, self.conn_type, self.latency, self.last_used)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.relay_url != other.relay_url:
            return False
        if self.addrs != other.addrs:
            return False
        if self.conn_type != other.conn_type:
            return False
        if self.latency != other.latency:
            return False
        if self.last_used != other.last_used:
            return False
        return True

class _UniffiConverterTypeRemoteInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RemoteInfo(
            node_id=_UniffiConverterTypePublicKey.read(buf),
            relay_url=_UniffiConverterOptionalString.read(buf),
            addrs=_UniffiConverterSequenceTypeDirectAddrInfo.read(buf),
            conn_type=_UniffiConverterTypeConnectionType.read(buf),
            latency=_UniffiConverterOptionalDuration.read(buf),
            last_used=_UniffiConverterOptionalDuration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.node_id)
        _UniffiConverterOptionalString.check_lower(value.relay_url)
        _UniffiConverterSequenceTypeDirectAddrInfo.check_lower(value.addrs)
        _UniffiConverterTypeConnectionType.check_lower(value.conn_type)
        _UniffiConverterOptionalDuration.check_lower(value.latency)
        _UniffiConverterOptionalDuration.check_lower(value.last_used)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.node_id, buf)
        _UniffiConverterOptionalString.write(value.relay_url, buf)
        _UniffiConverterSequenceTypeDirectAddrInfo.write(value.addrs, buf)
        _UniffiConverterTypeConnectionType.write(value.conn_type, buf)
        _UniffiConverterOptionalDuration.write(value.latency, buf)
        _UniffiConverterOptionalDuration.write(value.last_used, buf)


class SyncEvent:
    """
    Outcome of a sync operation
    """

    peer: "PublicKey"
    """
    Peer we synced with
    """

    origin: "Origin"
    """
    Origin of the sync exchange
    """

    finished: "Timestamp"
    """
    Timestamp when the sync finished
    """

    started: "Timestamp"
    """
    Timestamp when the sync started
    """

    result: "typing.Optional[str]"
    """
    Result of the sync operation. `None` if successfull.
    """

    def __init__(self, *, peer: "PublicKey", origin: "Origin", finished: "Timestamp", started: "Timestamp", result: "typing.Optional[str]"):
        self.peer = peer
        self.origin = origin
        self.finished = finished
        self.started = started
        self.result = result

    def __str__(self):
        return "SyncEvent(peer={}, origin={}, finished={}, started={}, result={})".format(self.peer, self.origin, self.finished, self.started, self.result)

    def __eq__(self, other):
        if self.peer != other.peer:
            return False
        if self.origin != other.origin:
            return False
        if self.finished != other.finished:
            return False
        if self.started != other.started:
            return False
        if self.result != other.result:
            return False
        return True

class _UniffiConverterTypeSyncEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SyncEvent(
            peer=_UniffiConverterTypePublicKey.read(buf),
            origin=_UniffiConverterTypeOrigin.read(buf),
            finished=_UniffiConverterTimestamp.read(buf),
            started=_UniffiConverterTimestamp.read(buf),
            result=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.peer)
        _UniffiConverterTypeOrigin.check_lower(value.origin)
        _UniffiConverterTimestamp.check_lower(value.finished)
        _UniffiConverterTimestamp.check_lower(value.started)
        _UniffiConverterOptionalString.check_lower(value.result)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.peer, buf)
        _UniffiConverterTypeOrigin.write(value.origin, buf)
        _UniffiConverterTimestamp.write(value.finished, buf)
        _UniffiConverterTimestamp.write(value.started, buf)
        _UniffiConverterOptionalString.write(value.result, buf)


class TagInfo:
    """
    A response to a list collections request
    """

    name: "bytes"
    """
    The tag
    """

    format: "BlobFormat"
    """
    The format of the associated blob
    """

    hash: "Hash"
    """
    The hash of the associated blob
    """

    def __init__(self, *, name: "bytes", format: "BlobFormat", hash: "Hash"):
        self.name = name
        self.format = format
        self.hash = hash

    def __str__(self):
        return "TagInfo(name={}, format={}, hash={})".format(self.name, self.format, self.hash)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.format != other.format:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeTagInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TagInfo(
            name=_UniffiConverterBytes.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.name)
        _UniffiConverterTypeBlobFormat.check_lower(value.format)
        _UniffiConverterTypeHash.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.name, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)


class TaggedBlobAdded:
    """
    An BlobProvide event indicating a new tagged blob or collection was added
    """

    hash: "Hash"
    """
    The hash of the added data
    """

    format: "BlobFormat"
    """
    The format of the added data
    """

    tag: "bytes"
    """
    The tag of the added data
    """

    def __init__(self, *, hash: "Hash", format: "BlobFormat", tag: "bytes"):
        self.hash = hash
        self.format = format
        self.tag = tag

    def __str__(self):
        return "TaggedBlobAdded(hash={}, format={}, tag={})".format(self.hash, self.format, self.tag)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.format != other.format:
            return False
        if self.tag != other.tag:
            return False
        return True

class _UniffiConverterTypeTaggedBlobAdded(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TaggedBlobAdded(
            hash=_UniffiConverterTypeHash.read(buf),
            format=_UniffiConverterTypeBlobFormat.read(buf),
            tag=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterTypeBlobFormat.check_lower(value.format)
        _UniffiConverterBytes.check_lower(value.tag)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterTypeBlobFormat.write(value.format, buf)
        _UniffiConverterBytes.write(value.tag, buf)


class TransferAborted:
    """
    A request was aborted because the client disconnected.
    """

    connection_id: "int"
    """
    The quic connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this request.
    """

    stats: "typing.Optional[TransferStats]"
    """
    statistics about the transfer. This is None if the transfer
    was aborted before any data was sent.
    """

    def __init__(self, *, connection_id: "int", request_id: "int", stats: "typing.Optional[TransferStats]"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.stats = stats

    def __str__(self):
        return "TransferAborted(connection_id={}, request_id={}, stats={})".format(self.connection_id, self.request_id, self.stats)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.stats != other.stats:
            return False
        return True

class _UniffiConverterTypeTransferAborted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferAborted(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            stats=_UniffiConverterOptionalTypeTransferStats.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterOptionalTypeTransferStats.check_lower(value.stats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterOptionalTypeTransferStats.write(value.stats, buf)


class TransferBlobCompleted:
    """
    A blob in a sequence was transferred.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this transfer request.
    """

    hash: "Hash"
    """
    The hash of the blob
    """

    index: "int"
    """
    The index of the blob in the sequence.
    """

    size: "int"
    """
    The size of the blob transferred.
    """

    def __init__(self, *, connection_id: "int", request_id: "int", hash: "Hash", index: "int", size: "int"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.hash = hash
        self.index = index
        self.size = size

    def __str__(self):
        return "TransferBlobCompleted(connection_id={}, request_id={}, hash={}, index={}, size={})".format(self.connection_id, self.request_id, self.hash, self.index, self.size)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.hash != other.hash:
            return False
        if self.index != other.index:
            return False
        if self.size != other.size:
            return False
        return True

class _UniffiConverterTypeTransferBlobCompleted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferBlobCompleted(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            index=_UniffiConverterUInt64.read(buf),
            size=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.index)
        _UniffiConverterUInt64.check_lower(value.size)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.index, buf)
        _UniffiConverterUInt64.write(value.size, buf)


class TransferCompleted:
    """
    A request was completed and the data was sent to the client.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this transfer request.
    """

    stats: "TransferStats"
    """
    statistics about the transfer
    """

    def __init__(self, *, connection_id: "int", request_id: "int", stats: "TransferStats"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.stats = stats

    def __str__(self):
        return "TransferCompleted(connection_id={}, request_id={}, stats={})".format(self.connection_id, self.request_id, self.stats)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.stats != other.stats:
            return False
        return True

class _UniffiConverterTypeTransferCompleted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferCompleted(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            stats=_UniffiConverterTypeTransferStats.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterTypeTransferStats.check_lower(value.stats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterTypeTransferStats.write(value.stats, buf)


class TransferHashSeqStarted:
    """
    A sequence of hashes has been found and is being transferred.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this transfer request.
    """

    num_blobs: "int"
    """
    The number of blobs in the sequence.
    """

    def __init__(self, *, connection_id: "int", request_id: "int", num_blobs: "int"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.num_blobs = num_blobs

    def __str__(self):
        return "TransferHashSeqStarted(connection_id={}, request_id={}, num_blobs={})".format(self.connection_id, self.request_id, self.num_blobs)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.num_blobs != other.num_blobs:
            return False
        return True

class _UniffiConverterTypeTransferHashSeqStarted(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferHashSeqStarted(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            num_blobs=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterUInt64.check_lower(value.num_blobs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterUInt64.write(value.num_blobs, buf)


class TransferProgress:
    """
    A chunk of a blob was transferred.

    These events will be sent with try_send, so you can not assume that you
    will receive all of them.
    """

    connection_id: "int"
    """
    An unique connection id.
    """

    request_id: "int"
    """
    An identifier uniquely identifying this transfer request.
    """

    hash: "Hash"
    """
    The hash for which we are transferring data.
    """

    end_offset: "int"
    """
    Offset up to which we have transferred data.
    """

    def __init__(self, *, connection_id: "int", request_id: "int", hash: "Hash", end_offset: "int"):
        self.connection_id = connection_id
        self.request_id = request_id
        self.hash = hash
        self.end_offset = end_offset

    def __str__(self):
        return "TransferProgress(connection_id={}, request_id={}, hash={}, end_offset={})".format(self.connection_id, self.request_id, self.hash, self.end_offset)

    def __eq__(self, other):
        if self.connection_id != other.connection_id:
            return False
        if self.request_id != other.request_id:
            return False
        if self.hash != other.hash:
            return False
        if self.end_offset != other.end_offset:
            return False
        return True

class _UniffiConverterTypeTransferProgress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferProgress(
            connection_id=_UniffiConverterUInt64.read(buf),
            request_id=_UniffiConverterUInt64.read(buf),
            hash=_UniffiConverterTypeHash.read(buf),
            end_offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.connection_id)
        _UniffiConverterUInt64.check_lower(value.request_id)
        _UniffiConverterTypeHash.check_lower(value.hash)
        _UniffiConverterUInt64.check_lower(value.end_offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.connection_id, buf)
        _UniffiConverterUInt64.write(value.request_id, buf)
        _UniffiConverterTypeHash.write(value.hash, buf)
        _UniffiConverterUInt64.write(value.end_offset, buf)


class TransferStats:
    """
    The stats for a transfer of a collection or blob.
    """

    duration: "int"
    """
    The total duration of the transfer in milliseconds
    """

    def __init__(self, *, duration: "int"):
        self.duration = duration

    def __str__(self):
        return "TransferStats(duration={})".format(self.duration)

    def __eq__(self, other):
        if self.duration != other.duration:
            return False
        return True

class _UniffiConverterTypeTransferStats(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferStats(
            duration=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.duration)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.duration, buf)





class AddProgressType(enum.Enum):
    """
    The different types of AddProgress events
    """

    FOUND = 0
    """
    An item was found with name `name`, from now on referred to via `id`
    """

    
    PROGRESS = 1
    """
    We got progress ingesting item `id`.
    """

    
    DONE = 2
    """
    We are done with `id`, and the hash is `hash`.
    """

    
    ALL_DONE = 3
    """
    We are done with the whole operation.
    """

    
    ABORT = 4
    """
    We got an error and need to abort.

    This will be the last message in the stream.
    """

    


class _UniffiConverterTypeAddProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddProgressType.FOUND
        if variant == 2:
            return AddProgressType.PROGRESS
        if variant == 3:
            return AddProgressType.DONE
        if variant == 4:
            return AddProgressType.ALL_DONE
        if variant == 5:
            return AddProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AddProgressType.FOUND:
            return
        if value == AddProgressType.PROGRESS:
            return
        if value == AddProgressType.DONE:
            return
        if value == AddProgressType.ALL_DONE:
            return
        if value == AddProgressType.ABORT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AddProgressType.FOUND:
            buf.write_i32(1)
        if value == AddProgressType.PROGRESS:
            buf.write_i32(2)
        if value == AddProgressType.DONE:
            buf.write_i32(3)
        if value == AddProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == AddProgressType.ABORT:
            buf.write_i32(5)







class AddrInfoOptions(enum.Enum):
    """
    Options when creating a ticket
    """

    ID = 0
    """
    Only the Node ID is added.

    This usually means that iroh-dns discovery is used to find address information.
    """

    
    RELAY_AND_ADDRESSES = 1
    """
    Include both the relay URL and the direct addresses.
    """

    
    RELAY = 2
    """
    Only include the relay URL.
    """

    
    ADDRESSES = 3
    """
    Only include the direct addresses.
    """

    


class _UniffiConverterTypeAddrInfoOptions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddrInfoOptions.ID
        if variant == 2:
            return AddrInfoOptions.RELAY_AND_ADDRESSES
        if variant == 3:
            return AddrInfoOptions.RELAY
        if variant == 4:
            return AddrInfoOptions.ADDRESSES
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AddrInfoOptions.ID:
            return
        if value == AddrInfoOptions.RELAY_AND_ADDRESSES:
            return
        if value == AddrInfoOptions.RELAY:
            return
        if value == AddrInfoOptions.ADDRESSES:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AddrInfoOptions.ID:
            buf.write_i32(1)
        if value == AddrInfoOptions.RELAY_AND_ADDRESSES:
            buf.write_i32(2)
        if value == AddrInfoOptions.RELAY:
            buf.write_i32(3)
        if value == AddrInfoOptions.ADDRESSES:
            buf.write_i32(4)







class BlobExportFormat(enum.Enum):
    """
    The expected format of a hash being exported.
    """

    BLOB = 0
    """
    The hash refers to any blob and will be exported to a single file.
    """

    
    COLLECTION = 1
    """
    The hash refers to a [`crate::format::collection::Collection`] blob
    and all children of the collection shall be exported to one file per child.

    If the blob can be parsed as a [`BlobFormat::HashSeq`], and the first child contains
    collection metadata, all other children of the collection will be exported to
    a file each, with their collection name treated as a relative path to the export
    destination path.

    If the blob cannot be parsed as a collection, the operation will fail.
    """

    


class _UniffiConverterTypeBlobExportFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobExportFormat.BLOB
        if variant == 2:
            return BlobExportFormat.COLLECTION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BlobExportFormat.BLOB:
            return
        if value == BlobExportFormat.COLLECTION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BlobExportFormat.BLOB:
            buf.write_i32(1)
        if value == BlobExportFormat.COLLECTION:
            buf.write_i32(2)







class BlobExportMode(enum.Enum):
    """
    The export mode describes how files will be exported.

    This is a hint to the import trait method. For some implementations, this
    does not make any sense. E.g. an in memory implementation will always have
    to copy the file into memory. Also, a disk based implementation might choose
    to copy small files even if the mode is `Reference`.
    """

    COPY = 0
    """
    This mode will copy the file to the target directory.

    This is the safe default because the file can not be accidentally modified
    after it has been exported.
    """

    
    TRY_REFERENCE = 1
    """
    This mode will try to move the file to the target directory and then reference it from
    the database.

    This has a large performance and storage benefit, but it is less safe since
    the file might be modified in the target directory after it has been exported.

    Stores are allowed to ignore this mode and always copy the file, e.g.
    if the file is very small or if the store does not support referencing files.
    """

    


class _UniffiConverterTypeBlobExportMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobExportMode.COPY
        if variant == 2:
            return BlobExportMode.TRY_REFERENCE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BlobExportMode.COPY:
            return
        if value == BlobExportMode.TRY_REFERENCE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BlobExportMode.COPY:
            buf.write_i32(1)
        if value == BlobExportMode.TRY_REFERENCE:
            buf.write_i32(2)







class BlobFormat(enum.Enum):
    """
    A format identifier
    """

    RAW = 0
    """
    Raw blob
    """

    
    HASH_SEQ = 1
    """
    A sequence of BLAKE3 hashes
    """

    


class _UniffiConverterTypeBlobFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobFormat.RAW
        if variant == 2:
            return BlobFormat.HASH_SEQ
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BlobFormat.RAW:
            return
        if value == BlobFormat.HASH_SEQ:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BlobFormat.RAW:
            buf.write_i32(1)
        if value == BlobFormat.HASH_SEQ:
            buf.write_i32(2)







class BlobProvideEventType(enum.Enum):
    """
    The different types of BlobProvide events
    """

    TAGGED_BLOB_ADDED = 0
    """
    A new collection or tagged blob has been added
    """

    
    CLIENT_CONNECTED = 1
    """
    A new client connected to the node.
    """

    
    GET_REQUEST_RECEIVED = 2
    """
    A request was received from a client.
    """

    
    TRANSFER_HASH_SEQ_STARTED = 3
    """
    A sequence of hashes has been found and is being transferred.
    """

    
    TRANSFER_PROGRESS = 4
    """
    A chunk of a blob was transferred.

    it is not safe to assume all progress events will be sent
    """

    
    TRANSFER_BLOB_COMPLETED = 5
    """
    A blob in a sequence was transferred.
    """

    
    TRANSFER_COMPLETED = 6
    """
    A request was completed and the data was sent to the client.
    """

    
    TRANSFER_ABORTED = 7
    """
    A request was aborted because the client disconnected.
    """

    


class _UniffiConverterTypeBlobProvideEventType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BlobProvideEventType.TAGGED_BLOB_ADDED
        if variant == 2:
            return BlobProvideEventType.CLIENT_CONNECTED
        if variant == 3:
            return BlobProvideEventType.GET_REQUEST_RECEIVED
        if variant == 4:
            return BlobProvideEventType.TRANSFER_HASH_SEQ_STARTED
        if variant == 5:
            return BlobProvideEventType.TRANSFER_PROGRESS
        if variant == 6:
            return BlobProvideEventType.TRANSFER_BLOB_COMPLETED
        if variant == 7:
            return BlobProvideEventType.TRANSFER_COMPLETED
        if variant == 8:
            return BlobProvideEventType.TRANSFER_ABORTED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BlobProvideEventType.TAGGED_BLOB_ADDED:
            return
        if value == BlobProvideEventType.CLIENT_CONNECTED:
            return
        if value == BlobProvideEventType.GET_REQUEST_RECEIVED:
            return
        if value == BlobProvideEventType.TRANSFER_HASH_SEQ_STARTED:
            return
        if value == BlobProvideEventType.TRANSFER_PROGRESS:
            return
        if value == BlobProvideEventType.TRANSFER_BLOB_COMPLETED:
            return
        if value == BlobProvideEventType.TRANSFER_COMPLETED:
            return
        if value == BlobProvideEventType.TRANSFER_ABORTED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BlobProvideEventType.TAGGED_BLOB_ADDED:
            buf.write_i32(1)
        if value == BlobProvideEventType.CLIENT_CONNECTED:
            buf.write_i32(2)
        if value == BlobProvideEventType.GET_REQUEST_RECEIVED:
            buf.write_i32(3)
        if value == BlobProvideEventType.TRANSFER_HASH_SEQ_STARTED:
            buf.write_i32(4)
        if value == BlobProvideEventType.TRANSFER_PROGRESS:
            buf.write_i32(5)
        if value == BlobProvideEventType.TRANSFER_BLOB_COMPLETED:
            buf.write_i32(6)
        if value == BlobProvideEventType.TRANSFER_COMPLETED:
            buf.write_i32(7)
        if value == BlobProvideEventType.TRANSFER_ABORTED:
            buf.write_i32(8)




# CallbackError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CallbackError(Exception):
    pass

_UniffiTempCallbackError = CallbackError

class CallbackError:  # type: ignore
    class Error(_UniffiTempCallbackError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CallbackError.Error({})".format(str(self))
    _UniffiTempCallbackError.Error = Error # type: ignore

CallbackError = _UniffiTempCallbackError # type: ignore
del _UniffiTempCallbackError


class _UniffiConverterTypeCallbackError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CallbackError.Error(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CallbackError.Error):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CallbackError.Error):
            buf.write_i32(1)





class CapabilityKind(enum.Enum):
    WRITE = 1
    """
    A writable replica.
    """

    
    READ = 2
    """
    A readable replica.
    """

    


class _UniffiConverterTypeCapabilityKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CapabilityKind.WRITE
        if variant == 2:
            return CapabilityKind.READ
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == CapabilityKind.WRITE:
            return
        if value == CapabilityKind.READ:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == CapabilityKind.WRITE:
            buf.write_i32(1)
        if value == CapabilityKind.READ:
            buf.write_i32(2)







class ConnType(enum.Enum):
    """
    The type of the connection
    """

    DIRECT = 0
    """
    Indicates you have a UDP connection.
    """

    
    RELAY = 1
    """
    Indicates you have a relayed connection.
    """

    
    MIXED = 2
    """
    Indicates you have an unverified UDP connection, and a relay connection for backup.
    """

    
    NONE = 3
    """
    Indicates you have no proof of connection.
    """

    


class _UniffiConverterTypeConnType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConnType.DIRECT
        if variant == 2:
            return ConnType.RELAY
        if variant == 3:
            return ConnType.MIXED
        if variant == 4:
            return ConnType.NONE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ConnType.DIRECT:
            return
        if value == ConnType.RELAY:
            return
        if value == ConnType.MIXED:
            return
        if value == ConnType.NONE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ConnType.DIRECT:
            buf.write_i32(1)
        if value == ConnType.RELAY:
            buf.write_i32(2)
        if value == ConnType.MIXED:
            buf.write_i32(3)
        if value == ConnType.NONE:
            buf.write_i32(4)







class ContentStatus(enum.Enum):
    """
    Whether the content status is available on a node.
    """

    COMPLETE = 0
    """
    The content is completely available.
    """

    
    INCOMPLETE = 1
    """
    The content is partially available.
    """

    
    MISSING = 2
    """
    The content is missing.
    """

    


class _UniffiConverterTypeContentStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ContentStatus.COMPLETE
        if variant == 2:
            return ContentStatus.INCOMPLETE
        if variant == 3:
            return ContentStatus.MISSING
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ContentStatus.COMPLETE:
            return
        if value == ContentStatus.INCOMPLETE:
            return
        if value == ContentStatus.MISSING:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ContentStatus.COMPLETE:
            buf.write_i32(1)
        if value == ContentStatus.INCOMPLETE:
            buf.write_i32(2)
        if value == ContentStatus.MISSING:
            buf.write_i32(3)







class DocExportProgressType(enum.Enum):
    """
    The type of `DocExportProgress` event
    """

    FOUND = 0
    """
    An item was found with name `name`, from now on referred to via `id`
    """

    
    PROGRESS = 1
    """
    We got progress exporting item `id`.
    """

    
    DONE = 2
    """
    We finished exporting a blob with `id`
    """

    
    ALL_DONE = 3
    """
    We are done writing the entry to the filesystem
    """

    
    ABORT = 4
    """
    We got an error and need to abort.

    This will be the last message in the stream.
    """

    


class _UniffiConverterTypeDocExportProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DocExportProgressType.FOUND
        if variant == 2:
            return DocExportProgressType.PROGRESS
        if variant == 3:
            return DocExportProgressType.DONE
        if variant == 4:
            return DocExportProgressType.ALL_DONE
        if variant == 5:
            return DocExportProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DocExportProgressType.FOUND:
            return
        if value == DocExportProgressType.PROGRESS:
            return
        if value == DocExportProgressType.DONE:
            return
        if value == DocExportProgressType.ALL_DONE:
            return
        if value == DocExportProgressType.ABORT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DocExportProgressType.FOUND:
            buf.write_i32(1)
        if value == DocExportProgressType.PROGRESS:
            buf.write_i32(2)
        if value == DocExportProgressType.DONE:
            buf.write_i32(3)
        if value == DocExportProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == DocExportProgressType.ABORT:
            buf.write_i32(5)







class DocImportProgressType(enum.Enum):
    """
    The type of `DocImportProgress` event
    """

    FOUND = 0
    """
    An item was found with name `name`, from now on referred to via `id`
    """

    
    PROGRESS = 1
    """
    We got progress ingesting item `id`.
    """

    
    INGEST_DONE = 2
    """
    We are done ingesting `id`, and the hash is `hash`.
    """

    
    ALL_DONE = 3
    """
    We are done with the whole operation.
    """

    
    ABORT = 4
    """
    We got an error and need to abort.

    This will be the last message in the stream.
    """

    


class _UniffiConverterTypeDocImportProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DocImportProgressType.FOUND
        if variant == 2:
            return DocImportProgressType.PROGRESS
        if variant == 3:
            return DocImportProgressType.INGEST_DONE
        if variant == 4:
            return DocImportProgressType.ALL_DONE
        if variant == 5:
            return DocImportProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DocImportProgressType.FOUND:
            return
        if value == DocImportProgressType.PROGRESS:
            return
        if value == DocImportProgressType.INGEST_DONE:
            return
        if value == DocImportProgressType.ALL_DONE:
            return
        if value == DocImportProgressType.ABORT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DocImportProgressType.FOUND:
            buf.write_i32(1)
        if value == DocImportProgressType.PROGRESS:
            buf.write_i32(2)
        if value == DocImportProgressType.INGEST_DONE:
            buf.write_i32(3)
        if value == DocImportProgressType.ALL_DONE:
            buf.write_i32(4)
        if value == DocImportProgressType.ABORT:
            buf.write_i32(5)







class DownloadProgressType(enum.Enum):
    """
    The different types of DownloadProgress events
    """

    INITIAL_STATE = 0
    
    FOUND_LOCAL = 1
    
    CONNECTED = 2
    
    FOUND = 3
    
    FOUND_HASH_SEQ = 4
    
    PROGRESS = 5
    
    DONE = 6
    
    ALL_DONE = 7
    
    ABORT = 8
    


class _UniffiConverterTypeDownloadProgressType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DownloadProgressType.INITIAL_STATE
        if variant == 2:
            return DownloadProgressType.FOUND_LOCAL
        if variant == 3:
            return DownloadProgressType.CONNECTED
        if variant == 4:
            return DownloadProgressType.FOUND
        if variant == 5:
            return DownloadProgressType.FOUND_HASH_SEQ
        if variant == 6:
            return DownloadProgressType.PROGRESS
        if variant == 7:
            return DownloadProgressType.DONE
        if variant == 8:
            return DownloadProgressType.ALL_DONE
        if variant == 9:
            return DownloadProgressType.ABORT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == DownloadProgressType.INITIAL_STATE:
            return
        if value == DownloadProgressType.FOUND_LOCAL:
            return
        if value == DownloadProgressType.CONNECTED:
            return
        if value == DownloadProgressType.FOUND:
            return
        if value == DownloadProgressType.FOUND_HASH_SEQ:
            return
        if value == DownloadProgressType.PROGRESS:
            return
        if value == DownloadProgressType.DONE:
            return
        if value == DownloadProgressType.ALL_DONE:
            return
        if value == DownloadProgressType.ABORT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == DownloadProgressType.INITIAL_STATE:
            buf.write_i32(1)
        if value == DownloadProgressType.FOUND_LOCAL:
            buf.write_i32(2)
        if value == DownloadProgressType.CONNECTED:
            buf.write_i32(3)
        if value == DownloadProgressType.FOUND:
            buf.write_i32(4)
        if value == DownloadProgressType.FOUND_HASH_SEQ:
            buf.write_i32(5)
        if value == DownloadProgressType.PROGRESS:
            buf.write_i32(6)
        if value == DownloadProgressType.DONE:
            buf.write_i32(7)
        if value == DownloadProgressType.ALL_DONE:
            buf.write_i32(8)
        if value == DownloadProgressType.ABORT:
            buf.write_i32(9)







class LiveEventType(enum.Enum):
    """
    The type of events that can be emitted during the live sync progress
    """

    INSERT_LOCAL = 0
    """
    A local insertion.
    """

    
    INSERT_REMOTE = 1
    """
    Received a remote insert.
    """

    
    CONTENT_READY = 2
    """
    The content of an entry was downloaded and is now available at the local node
    """

    
    NEIGHBOR_UP = 3
    """
    We have a new neighbor in the swarm.
    """

    
    NEIGHBOR_DOWN = 4
    """
    We lost a neighbor in the swarm.
    """

    
    SYNC_FINISHED = 5
    """
    A set-reconciliation sync finished.
    """

    
    PENDING_CONTENT_READY = 6
    """
    All pending content is now ready.

    This event signals that all queued content downloads from the last sync run have either
    completed or failed.

    It will only be emitted after a [`Self::SyncFinished`] event, never before.

    Receiving this event does not guarantee that all content in the document is available. If
    blobs failed to download, this event will still be emitted after all operations completed.
    """

    


class _UniffiConverterTypeLiveEventType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LiveEventType.INSERT_LOCAL
        if variant == 2:
            return LiveEventType.INSERT_REMOTE
        if variant == 3:
            return LiveEventType.CONTENT_READY
        if variant == 4:
            return LiveEventType.NEIGHBOR_UP
        if variant == 5:
            return LiveEventType.NEIGHBOR_DOWN
        if variant == 6:
            return LiveEventType.SYNC_FINISHED
        if variant == 7:
            return LiveEventType.PENDING_CONTENT_READY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LiveEventType.INSERT_LOCAL:
            return
        if value == LiveEventType.INSERT_REMOTE:
            return
        if value == LiveEventType.CONTENT_READY:
            return
        if value == LiveEventType.NEIGHBOR_UP:
            return
        if value == LiveEventType.NEIGHBOR_DOWN:
            return
        if value == LiveEventType.SYNC_FINISHED:
            return
        if value == LiveEventType.PENDING_CONTENT_READY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LiveEventType.INSERT_LOCAL:
            buf.write_i32(1)
        if value == LiveEventType.INSERT_REMOTE:
            buf.write_i32(2)
        if value == LiveEventType.CONTENT_READY:
            buf.write_i32(3)
        if value == LiveEventType.NEIGHBOR_UP:
            buf.write_i32(4)
        if value == LiveEventType.NEIGHBOR_DOWN:
            buf.write_i32(5)
        if value == LiveEventType.SYNC_FINISHED:
            buf.write_i32(6)
        if value == LiveEventType.PENDING_CONTENT_READY:
            buf.write_i32(7)







class LogLevel(enum.Enum):
    """
    The logging level. See the rust (log crate)[https://docs.rs/log] for more information.
    """

    TRACE = 0
    
    DEBUG = 1
    
    INFO = 2
    
    WARN = 3
    
    ERROR = 4
    
    OFF = 5
    


class _UniffiConverterTypeLogLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LogLevel.TRACE
        if variant == 2:
            return LogLevel.DEBUG
        if variant == 3:
            return LogLevel.INFO
        if variant == 4:
            return LogLevel.WARN
        if variant == 5:
            return LogLevel.ERROR
        if variant == 6:
            return LogLevel.OFF
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LogLevel.TRACE:
            return
        if value == LogLevel.DEBUG:
            return
        if value == LogLevel.INFO:
            return
        if value == LogLevel.WARN:
            return
        if value == LogLevel.ERROR:
            return
        if value == LogLevel.OFF:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LogLevel.TRACE:
            buf.write_i32(1)
        if value == LogLevel.DEBUG:
            buf.write_i32(2)
        if value == LogLevel.INFO:
            buf.write_i32(3)
        if value == LogLevel.WARN:
            buf.write_i32(4)
        if value == LogLevel.ERROR:
            buf.write_i32(5)
        if value == LogLevel.OFF:
            buf.write_i32(6)







class MessageType(enum.Enum):
    NEIGHBOR_UP = 0
    
    NEIGHBOR_DOWN = 1
    
    RECEIVED = 2
    
    JOINED = 3
    
    LAGGED = 4
    
    ERROR = 5
    


class _UniffiConverterTypeMessageType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MessageType.NEIGHBOR_UP
        if variant == 2:
            return MessageType.NEIGHBOR_DOWN
        if variant == 3:
            return MessageType.RECEIVED
        if variant == 4:
            return MessageType.JOINED
        if variant == 5:
            return MessageType.LAGGED
        if variant == 6:
            return MessageType.ERROR
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == MessageType.NEIGHBOR_UP:
            return
        if value == MessageType.NEIGHBOR_DOWN:
            return
        if value == MessageType.RECEIVED:
            return
        if value == MessageType.JOINED:
            return
        if value == MessageType.LAGGED:
            return
        if value == MessageType.ERROR:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == MessageType.NEIGHBOR_UP:
            buf.write_i32(1)
        if value == MessageType.NEIGHBOR_DOWN:
            buf.write_i32(2)
        if value == MessageType.RECEIVED:
            buf.write_i32(3)
        if value == MessageType.JOINED:
            buf.write_i32(4)
        if value == MessageType.LAGGED:
            buf.write_i32(5)
        if value == MessageType.ERROR:
            buf.write_i32(6)







class NodeDiscoveryConfig(enum.Enum):
    NONE = 0
    """
    Use no node discovery mechanism.
    """

    
    DEFAULT = 1
    """
    Use the default discovery mechanism.

    This uses two discovery services concurrently:

    - It publishes to a pkarr service operated by [number 0] which makes the information
    available via DNS in the `iroh.link` domain.

    - It uses an mDNS-like system to announce itself on the local network.

    # Usage during tests

    Note that the default changes when compiling with `cfg(test)` or the `test-utils`
    cargo feature from [iroh-net] is enabled.  In this case only the Pkarr/DNS service
    is used, but on the `iroh.test` domain.  This domain is not integrated with the
    global DNS network and thus node discovery is effectively disabled.  To use node
    discovery in a test use the [`iroh_net::test_utils::DnsPkarrServer`] in the test and
    configure it here as a custom discovery mechanism ([`DiscoveryConfig::Custom`]).

    [number 0]: https://n0.computer
    """

    


class _UniffiConverterTypeNodeDiscoveryConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NodeDiscoveryConfig.NONE
        if variant == 2:
            return NodeDiscoveryConfig.DEFAULT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == NodeDiscoveryConfig.NONE:
            return
        if value == NodeDiscoveryConfig.DEFAULT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == NodeDiscoveryConfig.NONE:
            buf.write_i32(1)
        if value == NodeDiscoveryConfig.DEFAULT:
            buf.write_i32(2)







class Origin:
    """
    Why we performed a sync exchange
    """

    def __init__(self):
        raise RuntimeError("Origin cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONNECT:
        """
        public, use a unit variant
        """

        reason: "SyncReason"

        def __init__(self,reason: "SyncReason"):
            self.reason = reason

        def __str__(self):
            return "Origin.CONNECT(reason={})".format(self.reason)

        def __eq__(self, other):
            if not other.is_connect():
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class ACCEPT:
        """
        A peer connected to us and we accepted the exchange
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "Origin.ACCEPT()".format()

        def __eq__(self, other):
            if not other.is_accept():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_connect(self) -> bool:
        return isinstance(self, Origin.CONNECT)
    def is_accept(self) -> bool:
        return isinstance(self, Origin.ACCEPT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Origin.CONNECT = type("Origin.CONNECT", (Origin.CONNECT, Origin,), {})  # type: ignore
Origin.ACCEPT = type("Origin.ACCEPT", (Origin.ACCEPT, Origin,), {})  # type: ignore




class _UniffiConverterTypeOrigin(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Origin.CONNECT(
                _UniffiConverterTypeSyncReason.read(buf),
            )
        if variant == 2:
            return Origin.ACCEPT(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_connect():
            _UniffiConverterTypeSyncReason.check_lower(value.reason)
            return
        if value.is_accept():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_connect():
            buf.write_i32(1)
            _UniffiConverterTypeSyncReason.write(value.reason, buf)
        if value.is_accept():
            buf.write_i32(2)







class ShareMode(enum.Enum):
    """
    Intended capability for document share tickets
    """

    READ = 0
    """
    Read-only access
    """

    
    WRITE = 1
    """
    Write access
    """

    


class _UniffiConverterTypeShareMode(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ShareMode.READ
        if variant == 2:
            return ShareMode.WRITE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ShareMode.READ:
            return
        if value == ShareMode.WRITE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ShareMode.READ:
            buf.write_i32(1)
        if value == ShareMode.WRITE:
            buf.write_i32(2)







class SortBy(enum.Enum):
    """
    d Fields by which the query can be sorted
    """

    KEY_AUTHOR = 0
    """
    Sort by key, then author.
    """

    
    AUTHOR_KEY = 1
    """
    Sort by author, then key.
    """

    


class _UniffiConverterTypeSortBy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SortBy.KEY_AUTHOR
        if variant == 2:
            return SortBy.AUTHOR_KEY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SortBy.KEY_AUTHOR:
            return
        if value == SortBy.AUTHOR_KEY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SortBy.KEY_AUTHOR:
            buf.write_i32(1)
        if value == SortBy.AUTHOR_KEY:
            buf.write_i32(2)







class SortDirection(enum.Enum):
    """
    Sort direction
    """

    ASC = 0
    """
    Sort ascending
    """

    
    DESC = 1
    """
    Sort descending
    """

    


class _UniffiConverterTypeSortDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SortDirection.ASC
        if variant == 2:
            return SortDirection.DESC
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SortDirection.ASC:
            return
        if value == SortDirection.DESC:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SortDirection.ASC:
            buf.write_i32(1)
        if value == SortDirection.DESC:
            buf.write_i32(2)







class SyncReason(enum.Enum):
    """
    Why we started a sync request
    """

    DIRECT_JOIN = 0
    """
    Direct join request via API
    """

    
    NEW_NEIGHBOR = 1
    """
    Peer showed up as new neighbor in the gossip swarm
    """

    
    SYNC_REPORT = 2
    """
    We synced after receiving a sync report that indicated news for us
    """

    
    RESYNC = 3
    """
    We received a sync report while a sync was running, so run again afterwars
    """

    


class _UniffiConverterTypeSyncReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SyncReason.DIRECT_JOIN
        if variant == 2:
            return SyncReason.NEW_NEIGHBOR
        if variant == 3:
            return SyncReason.SYNC_REPORT
        if variant == 4:
            return SyncReason.RESYNC
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SyncReason.DIRECT_JOIN:
            return
        if value == SyncReason.NEW_NEIGHBOR:
            return
        if value == SyncReason.SYNC_REPORT:
            return
        if value == SyncReason.RESYNC:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SyncReason.DIRECT_JOIN:
            buf.write_i32(1)
        if value == SyncReason.NEW_NEIGHBOR:
            buf.write_i32(2)
        if value == SyncReason.SYNC_REPORT:
            buf.write_i32(3)
        if value == SyncReason.RESYNC:
            buf.write_i32(4)





class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterDuration.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBlobProvideEventCallback(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBlobProvideEventCallback.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBlobProvideEventCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBlobProvideEventCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDoc(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDoc.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDoc.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDoc.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDocExportFileCallback(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDocExportFileCallback.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDocExportFileCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDocExportFileCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDocImportFileCallback(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDocImportFileCallback.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDocImportFileCallback.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDocImportFileCallback.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEntry.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEntry.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEntry.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLatencyAndControlMsg(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLatencyAndControlMsg.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLatencyAndControlMsg.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLatencyAndControlMsg.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeQueryOptions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeQueryOptions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeQueryOptions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeQueryOptions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRemoteInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRemoteInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRemoteInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRemoteInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransferStats(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransferStats.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransferStats.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransferStats.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeDiscoveryConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeDiscoveryConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeDiscoveryConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeDiscoveryConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapBytesTypeProtocolCreator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapBytesTypeProtocolCreator.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapBytesTypeProtocolCreator.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapBytesTypeProtocolCreator.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAuthorId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAuthorId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAuthorId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAuthorId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDirectAddrInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDirectAddrInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDirectAddrInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDirectAddrInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEntry.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFilterKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFilterKind.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFilterKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFilterKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeHash(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeHash.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeHash.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeHash.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNodeAddr(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNodeAddr.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNodeAddr.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNodeAddr.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCollectionInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCollectionInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCollectionInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCollectionInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeIncompleteBlobInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeIncompleteBlobInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeIncompleteBlobInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeIncompleteBlobInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLinkAndName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLinkAndName.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLinkAndName.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLinkAndName.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNamespaceAndCapability(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNamespaceAndCapability.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNamespaceAndCapability.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNamespaceAndCapability.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRemoteInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRemoteInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRemoteInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRemoteInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTagInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTagInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTagInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTagInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeCounterStats(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeCounterStats.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeCounterStats.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeCounterStats.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapBytesTypeProtocolCreator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterBytes.check_lower(key)
            _UniffiConverterTypeProtocolCreator.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterBytes.write(key, buf)
            _UniffiConverterTypeProtocolCreator.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterBytes.read(buf)
            val = _UniffiConverterTypeProtocolCreator.read(buf)
            d[key] = val
        return d

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        try:
            handle_success(await make_call())
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        try:
            try:
                handle_success(await make_call())
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()

def key_to_path(key: "bytes",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "str":
    """
    Helper function that translates a key that was derived from the [`path_to_key`] function back
    into a path.

    If `prefix` exists, it will be stripped before converting back to a path
    If `root` exists, will add the root as a parent to the created path
    Removes any null byte that has been appened to the key
    """

    _UniffiConverterBytes.check_lower(key)
    
    _UniffiConverterOptionalString.check_lower(prefix)
    
    _UniffiConverterOptionalString.check_lower(root)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_func_key_to_path,
        _UniffiConverterBytes.lower(key),
        _UniffiConverterOptionalString.lower(prefix),
        _UniffiConverterOptionalString.lower(root)))


def path_to_key(path: "str",prefix: "typing.Optional[str]",root: "typing.Optional[str]") -> "bytes":
    """
    Helper function that creates a document key from a canonicalized path, removing the `root` and adding the `prefix`, if they exist

    Appends the null byte to the end of the key.
    """

    _UniffiConverterString.check_lower(path)
    
    _UniffiConverterOptionalString.check_lower(prefix)
    
    _UniffiConverterOptionalString.check_lower(root)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeIrohError__as_error,_UniffiLib.uniffi_iroh_ffi_fn_func_path_to_key,
        _UniffiConverterString.lower(path),
        _UniffiConverterOptionalString.lower(prefix),
        _UniffiConverterOptionalString.lower(root)))


def set_log_level(level: "LogLevel") -> None:
    """
    Set the logging level.
    """

    _UniffiConverterTypeLogLevel.check_lower(level)
    
    _uniffi_rust_call(_UniffiLib.uniffi_iroh_ffi_fn_func_set_log_level,
        _UniffiConverterTypeLogLevel.lower(level))


__all__ = [
    "InternalError",
    "AddProgressType",
    "AddrInfoOptions",
    "BlobExportFormat",
    "BlobExportMode",
    "BlobFormat",
    "BlobProvideEventType",
    "CallbackError",
    "CapabilityKind",
    "ConnType",
    "ContentStatus",
    "DocExportProgressType",
    "DocImportProgressType",
    "DownloadProgressType",
    "LiveEventType",
    "LogLevel",
    "MessageType",
    "NodeDiscoveryConfig",
    "Origin",
    "ShareMode",
    "SortBy",
    "SortDirection",
    "SyncReason",
    "AddProgressAbort",
    "AddProgressAllDone",
    "AddProgressDone",
    "AddProgressFound",
    "AddProgressProgress",
    "BlobAddOutcome",
    "BlobInfo",
    "ClientConnected",
    "CollectionInfo",
    "ConnectionTypeMixed",
    "CounterStats",
    "DocExportProgressAbort",
    "DocExportProgressDone",
    "DocExportProgressFound",
    "DocExportProgressProgress",
    "DocImportProgressAbort",
    "DocImportProgressAllDone",
    "DocImportProgressFound",
    "DocImportProgressIngestDone",
    "DocImportProgressProgress",
    "DownloadProgressAbort",
    "DownloadProgressAllDone",
    "DownloadProgressDone",
    "DownloadProgressFound",
    "DownloadProgressFoundHashSeq",
    "DownloadProgressFoundLocal",
    "DownloadProgressInitialState",
    "DownloadProgressProgress",
    "GetRequestReceived",
    "HashAndTag",
    "IncompleteBlobInfo",
    "InsertRemoteEvent",
    "LatencyAndControlMsg",
    "LinkAndName",
    "MessageContent",
    "NamespaceAndCapability",
    "NodeOptions",
    "OpenState",
    "QueryOptions",
    "RemoteInfo",
    "SyncEvent",
    "TagInfo",
    "TaggedBlobAdded",
    "TransferAborted",
    "TransferBlobCompleted",
    "TransferCompleted",
    "TransferHashSeqStarted",
    "TransferProgress",
    "TransferStats",
    "key_to_path",
    "path_to_key",
    "set_log_level",
    "AddCallback",
    "AddProgress",
    "Author",
    "AuthorId",
    "Authors",
    "BiStream",
    "BlobDownloadOptions",
    "BlobProvideEvent",
    "BlobProvideEventCallback",
    "BlobStatus",
    "BlobTicket",
    "Blobs",
    "Collection",
    "Connecting",
    "Connection",
    "ConnectionType",
    "DirectAddrInfo",
    "Doc",
    "DocExportFileCallback",
    "DocExportProgress",
    "DocImportFileCallback",
    "DocImportProgress",
    "DocTicket",
    "Docs",
    "DownloadCallback",
    "DownloadPolicy",
    "DownloadProgress",
    "Endpoint",
    "Entry",
    "FilterKind",
    "Gossip",
    "GossipMessageCallback",
    "Hash",
    "Iroh",
    "IrohError",
    "LiveEvent",
    "Message",
    "Net",
    "Node",
    "NodeAddr",
    "NodeStatus",
    "NodeTicket",
    "ProtocolCreator",
    "ProtocolHandler",
    "PublicKey",
    "Query",
    "RangeSpec",
    "ReadAtLen",
    "RecvStream",
    "SendStream",
    "Sender",
    "SetTagOption",
    "SubscribeCallback",
    "Tags",
    "WrapOption",
]

