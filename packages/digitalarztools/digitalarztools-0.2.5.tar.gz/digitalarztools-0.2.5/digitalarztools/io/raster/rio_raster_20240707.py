import osimport reimport tracebackfrom itertools import productimport geopandas as gpdfrom typing import Unionimport numpy as npimport pandas as pdimport pyprojimport rasterioimport shapely.geometryfrom affine import Affinefrom boto3 import Sessionfrom rasterio import DatasetReader, MemoryFile, windowsfrom rasterio.coords import BoundingBoxfrom rasterio.crs import CRSfrom rasterio.enums import Resamplingfrom rasterio.features import shapes, rasterizefrom rasterio.mask import maskfrom rasterio.plot import showfrom rasterio.session import AWSSessionfrom rasterio.warp import calculate_default_transform, reprojectfrom shapely.geometry import Point, shape, Polygonfrom shapely.ops import transform, unary_unionfrom digitalarztools.proccessing.operations.geodesy import GeodesyOpsfrom digitalarztools.proccessing.operations.transformation import TransformationOperationsfrom digitalarztools.io.file_io import FileIOfrom digitalarztools.io.raster.band_process import BandProcessfrom digitalarztools.io.raster.indices import IndicesCalcfrom digitalarztools.utils.logger import da_loggerfrom digitalarztools.io.vector.gpd_vector import GPDVectorclass RioRaster:    """        Geo Raster contain informaiton about geotransform and projection        GDAL geotransform = (c,a,b, f,d,e)        RasterIO = (a,b,c,d,e,f)    """    # src: str    dataset: DatasetReader = None    parent_img_name: str = None    temp_dir: str = None    def __init__(self, src: Union[str, DatasetReader], prj_path: str = None, s3_session=None):        self.set_dataset(src, s3_session)        if prj_path is not None and os.path.exists(prj_path):            self.add_crs_from_prj(prj_path)        self.resampling_method = [Resampling.nearest, Resampling.bilinear, Resampling.cubic, Resampling.lanczos,                                  Resampling.average, Resampling.cubic_spline]    def set_temp_folder(self, temp_dir: str):        self.temp_dir = temp_dir    def plot_data(self, band_nu: int = -1):        # plt.imshow(data)        # plt.colorbar()        # plt.title('Overview - Band 4 {}'.format(thumbnail.shape))        # plt.xlabel('Column #')        # plt.ylabel('Row #')        if band_nu == -1:            show(self.dataset)        else:            show(self.dataset.read(1), transform=self.get_geo_transform())        pass    def set_dataset(self, src: Union[str, DatasetReader], s3_session=None):        if isinstance(src, DatasetReader):            if '/vsipythonfilelike/' in src.name:                self.dataset = self.rio_dataset_from_array(src.read(), src.meta)                # with MemoryFile() as memfile:                #     data = src.read()                #     # Create a new in-memory dataset using the original profile                #     with memfile.open(driver='GTiff', count=src.count, dtype=src.dtypes[0], width=src.width,                #                       height=src.height, crs=src.crs, transform=src.transform) as cloned_dataset:                #         # Write the data to the cloned dataset                #         cloned_dataset.write(data)                #                #         # Accessing geotransform and projection information                #         print("Geotransform:", cloned_dataset.transform)                #         print("CRS (Coordinate Reference System):", cloned_dataset.crs)            else:                self.dataset = src        elif isinstance(src, str):            if "s3://" in src:                # print("S3 not available")                # self.dataset = S3Utils().get_rio_dataset(src)                session = rasterio.Env(AWSSession(s3_session))                with session:                    self.dataset = rasterio.open(src)            elif "/vsimem/" in src:                with MemoryFile(src) as memfile:                    self.dataset = memfile.open()            else:                if os.path.exists(src):                    self.dataset = rasterio.open(src, mode='r+')                else:                    raise Exception(f"Raste File not available at {src}")    def get_dataset(self) -> DatasetReader:        return self.dataset    def get_meta(self):        return self.dataset.meta    def get_metadata_copy(self):        return self.dataset.meta.copy()    def update_metadata(self, metadata):        memfile = MemoryFile()        dst = memfile.open(**metadata)        d = self.dataset.read()        dst.write(d)        dst.close()        self.dataset = memfile.open()  # Reopen as DatasetReader    def get_dtype(self):        return self.dataset.meta['dtype']    def get_nodata_value(self):        return self.dataset.meta['nodata']    def get_nodata_value_of_band(self, band_number):        return self.dataset.nodatavals[band_number - 1]    def get_overviews(self, num):        oviews = self.dataset.overviews(1)  # list of overviews from biggest to smallest        return oviews    def get_profile(self):        return self.dataset.profile    def get_file_name(self) -> (str, str):        if self.dataset.files and len(self.dataset.files) > 0:            file_name = str(self.dataset.files[0])            dir_name = os.path.dirname(file_name)            base_name = os.path.basename(file_name)            return dir_name, base_name    @classmethod    def separate_file_path_name(cls, file_path_name: str):        file_dir = os.path.dirname(file_path_name)        file_name = os.path.basename(file_path_name)        return file_dir, file_name    @classmethod    def get_file_name_extension(cls, file_name: str) -> (str, str):        split = file_name.split(".")        if len(split) == 2:            return split[0], split[1]        return file_name, None    def get_file_extension(self):        try:            dir, name = self.separate_file_path_name(self.get_file_name())            name, ext = self.get_file_name_extension(name)            return ext        except Exception as e:            traceback.print_exc()    def get_bounds(self) -> BoundingBox:        return self.dataset.bounds    # def reproject_extent(self, srid, extent=None):    #     if extent is None:    #         extent = self.get_raster_extent()    #     min_x, min_y, max_x, max_y = extent    #     inProj = pyproj.Proj(init='epsg:%d' % self.get_raster_srid())    #     outProj = pyproj.Proj(init='epsg:%d' % srid)    #     transformer = Transformer.from_proj(inProj, outProj)    #     min_x, max_y = transformer.transform(min_x, max_y)    #     max_x, min_y = transformer.transform(max_x, min_y)    #     return min_x, min_y, max_x, max_y    def get_extent_after_skip_rows_cols(self, n_rows_skip, n_cols_skip):        # Remove a part of image and coincident with input rio ds        y_size, x_size = self.get_img_resolution()        # transformation from the from to the to        geo_t = self.get_geo_transform()        min_x = geo_t[2] + n_cols_skip * geo_t[0]        max_y = geo_t[5] + n_rows_skip * geo_t[4]        max_x = geo_t[2] + geo_t[0] * (x_size - n_cols_skip)        min_y = geo_t[5] + geo_t[4] * (y_size - n_rows_skip)        extent = (min_x, min_y, max_x, max_y)        return extent    def get_envelop(self, n_rows_skp=0, n_cols_skip=0, srid=0) -> gpd.GeoDataFrame:        if n_rows_skp != 0 or n_cols_skip != 0:            extent = self.get_extent_after_skip_rows_cols(n_rows_skp, n_cols_skip)        else:            extent = self.get_raster_extent()        envelop = GPDVector.extent_2_envelop(*extent, crs=self.get_crs())        if srid != 0:            envelop.to_crs(epsg=srid)        return envelop.get_gdf()    def get_raster_extent(self) -> list:        bounds = self.dataset.bounds        return [bounds.left, bounds.bottom, bounds.right, bounds.top]    # def get_raster_extent_in_4326(self) -> list:    #     bounds = self.dataset.bounds    #     point_lb = Point(bounds.left, bounds.bottom)    #     point_rt = Point(bounds.right, bounds.top)    #     point_lb = self.transform_geometry(point_lb)    #     point_rt = self.transform_geometry(point_rt)    #     return [point_lb.x, point_lb.y, point_rt.x, point_rt.y]    def get_raster_srid(self) -> int:        try:            # epsg_code = int(self.dataset.crs.data['init'][5:])            profile = self.get_profile()            wkt = str(profile['crs'])            if ':' in wkt:                return int(str(profile['crs']).split(":")[-1])            else:                crs = pyproj.CRS.from_wkt(wkt)                return crs.to_epsg()        except Exception as e:            traceback.print_exc()            return 0    def set_crs(self, crs: pyproj.CRS):        crs = rasterio.crs.CRS.from_wkt(crs.to_wkt())        self.dataset.crs = crs    def get_width(self):        return self.dataset.width    def get_height(self):        return self.dataset.height    def get_crs(self) -> pyproj.CRS:        return self.dataset.crs    def get_pyproj_crs(self) -> pyproj.CRS:        try:            # profile = self.get_profile()            # epsg_code = str(profile['crs'])            return pyproj.CRS.from_wkt(self.dataset.crs.to_wkt())        except Exception as e:            traceback.print_exc()            return pyproj.CRS.from_epsg(0)    # def transform_geometry(self, geometry, to_srid=4326):    #     from_crs = self.get_pyproj_crs()    #     if from_crs and from_crs.to_epsg() != to_srid:    #         to_crs = pyproj.CRS(f'EPSG:{to_srid}')    #         project = pyproj.Transformer.from_crs(from_crs, to_crs, always_xy=True).transform    #         return transform(project, geometry)    #     return geometry    def get_data_shape(self):        data = self.get_data_array()        if len(data.shape) == 2:            band = 1            row, column = data.shape        elif len(data.shape) == 3:            band, row, column = data.shape        return band, row, column    def get_data_array(self, band=None, convert_no_data_2_nan=False, envelop: gpd.GeoDataFrame = None) -> np.ndarray:        dataset = self.dataset if envelop is None else self.get_dataset_under_envelop(envelop=envelop, in_place=False)        if band:            data_arr = dataset.read(band)        else:            data_arr = dataset.read()        if convert_no_data_2_nan:            data_arr = data_arr.astype(np.float)            data_arr[data_arr == self.dataset.nodata] = np.nan        return data_arr    def save_to_file(self, img_des: str, data: np.ndarray = None, crs: CRS = None,                     affine_transform: Affine = None,                     nodata_value=None):        data = self.get_data_array() if data is None else data        crs = crs if crs else self.dataset.crs        affine_transform = affine_transform if affine_transform else self.dataset.transform        nodata_value = nodata_value if nodata_value else self.get_nodata_value()        self.write_to_file(img_des, data, crs, affine_transform, nodata_value)    @staticmethod    def write_to_file(img_des: str, data: np.ndarray, crs: CRS, affine_transform: Affine, nodata_value,                      session: Session = None):        try:            if not "s3://" in img_des:                FileIO.mkdirs(img_des)            ext = img_des.split(".")[-1]            # if ext == "tif":            driver = 'GTiff'            # dir_name = os.path.dirname(img_des)            # if not os.path.exists(dir_name):            #     os.makedirs(dir_name)            dir_name = FileIO.mkdirs(img_des)            def create_new_raster(arr: np.ndarray):                if len(arr.shape) == 2:                    bands = 1                    rows, cols = arr.shape                else:                    bands, rows, cols = arr.shape                dataset = rasterio.open(img_des, 'w',                                        driver=driver,                                        height=rows,                                        width=cols,                                        count=bands,                                        dtype=str(arr.dtype),                                        crs=crs,                                        transform=affine_transform,                                        compress='lzw',                                        nodata=nodata_value)                for i in range(bands):                    d = arr if len(arr.shape) == 2 else arr[i]                    dataset.write(d, i + 1)                dataset.close()            if "s3://" in img_des:                session = rasterio.Env(AWSSession(session))                with session:                    create_new_raster(data)            else:                create_new_raster(data)        except:            da_logger.error(f"fp{img_des}")            da_logger.error(traceback.print_exc())    def rio_raster_from_array(self, img_arr: np.ndarray) -> 'RioRaster':        """        :return:        """        meta_data = self.get_metadata_copy()        raster = self.raster_from_array(img_arr, crs=self.get_crs(),                                        g_transform=self.get_geo_transform(),                                        nodata_value=self.get_nodata_value())        return raster    @staticmethod    def raster_from_array(img_arr: np.ndarray, crs: Union[str, CRS],                          g_transform: Affine, nodata_value=None) -> 'RioRaster':        """        :param img_arr:        :param crs: pyproj.CRS or wkt        :param g_transform:            Affine consist of a, b, c, d, e, f format        :param nodata_value:        :return:        """        memfile = MemoryFile()        if len(img_arr.shape) == 2:            bands = 1            rows, cols = img_arr.shape        else:            bands, rows, cols = img_arr.shape        dataset = memfile.open(driver='GTiff',                               height=rows,                               width=cols,                               count=bands,                               dtype=str(img_arr.dtype),                               crs=crs,                               transform=g_transform,                               nodata=nodata_value                               )        for i in range(bands):            d = img_arr if len(img_arr.shape) == 2 else img_arr[i, :, :]            dataset.write(d, i + 1)        dataset.close()        dataset = memfile.open()  # Reopen as DatasetReader        # dir_name, file_name = self.get_file_name()        new_raster = RioRaster(dataset)        return new_raster    def add_crs_from_prj(self, prj_file):        crs = FileIO.read_prj_file(prj_file)        self.dataset.crs = CRS.from_wkt(crs.to_wkt())    def get_driver(self):        return self.get_profile().data['driver']    def get_img_resolution(self) -> tuple:        """ return rows/height and cols/width of an image"""        cols = self.get_profile().data['width']        rows = self.get_profile().data['height']        return rows, cols    def get_shift_parameter(self):        gt = self.get_geo_transform()        return gt[2], gt[5]    def get_spatial_resoultion(self, in_meter=False) -> tuple:        """ return: spatial resolution  """        # bounds = self.get_bounds()        # s_width = bounds.right - bounds.left        # i_width = self.get_width()        # s_height = bounds.top - bounds.bottom        # i_height = self.get_height()        # return s_width / i_width, s_height / i_height        if in_meter:            temp_rio_ds = self.transform_to_metric_unit_projections()            return temp_rio_ds.res        return self.dataset.res    def get_unit(self) -> str:        """ get unit of image"""        crs = self.get_pyproj_crs()        return crs.to_dict()['units']    def get_radiometric_resolution(self):        s = self.get_profile()['dtype']        m = re.search(r'\d+$', s)        return int(m.group()) if m else None    def get_spectral_resolution(self):        return self.get_profile().data['count']    # def get_no_of_bands(self):    #     return self.dataset.count    def get_geo_transform(self) -> Affine:        """        :return: Affine consist of a, b, c, d, e, f format        """        return self.get_profile().data['transform']    def is_image_crs_same(self, raster2: 'RioRaster') -> bool:        crs1 = self.get_crs()        crs2 = raster2.get_crs()        return str(crs1) == str(crs2)    def is_image_resolution_same(self, raster2: 'RioRaster') -> bool:        res1 = self.get_img_resolution()        res2 = raster2.get_img_resolution()        return res1 == res2    def is_spatial_resolution_same(self, raster2: 'RioRaster'):        res1 = self.get_spatial_resoultion()        res2 = raster2.get_spatial_resoultion()        return res1 == res2    def is_image_extent_same(self, raster2: 'RioRaster'):        E1 = np.array(self.get_raster_extent())        E2 = np.array(raster2.get_raster_extent())        return (E1 == E2).all()    def create_ndwi_data(self, green, nir, output_path: str = None):        nir_data = self.get_data_array(nir)        green_data = self.get_data_array(green)        ndwi = IndicesCalc.NDWIndices(green_data, nir_data)        ndwi = IndicesCalc.normalize(ndwi)        if output_path:            self.save_to_file(output_path, ndwi.astype(rasterio.int8))        return ndwi    def create_ndvi_data(self, red_band: int, nir_band: int, output_path: str = None):        nir_data = self.get_data_array(nir_band)        red_data = self.get_data_array(red_band)        ndvi = IndicesCalc.NDVIndices(nir_data, red_data)        ndvi = IndicesCalc.normalize(ndvi)        if output_path:            self.save_to_file(output_path, ndvi.astype(rasterio.int8))        return ndvi        # with rasterio.open('Data_06/RASTER/NDVI/NDVI.tif', 'w', **meta_ndvi) as dst:        #     dst.write_band(1, ndvi.astype(rasterio.float32))    def vector_2_raster(self, gdv: GPDVector, value_col: str = 'id', d_type=np.uint8) -> 'RioRaster':        if str(gdv.get_crs()).lower() != str(self.get_crs()).lower():            gdv.to_crs(self.get_pyproj_crs())        shapes = gdv.get_geometry_list(value_col)        data = rasterize(shapes, out_shape=self.get_img_resolution(), transform=self.get_geo_transform())        data = data.astype(d_type)        return self.rio_raster_from_array(data)    def raster_2_vector(self, band: Union[int, np.ndarray], classes=[]) -> gpd.GeoDataFrame:        geoms = []        file_path, file_name = self.get_file_name()        if isinstance(band, np.ndarray):            band_data = band        else:            band_data = self.get_data_array(band)        c_ids = []        for vec in shapes(band_data, transform=self.get_geo_transform()):            if len(classes) == 0:                geoms.append(shape(vec[0]))                c_ids.append(vec[1])            elif vec[1] in classes:                geoms.append(shape(vec[0]))                c_ids.append(vec[1])        # ids = np.arange(len(geoms))        gdf = gpd.GeoDataFrame({'geometry': geoms,                                'class_id': np.array(c_ids).astype('uint16'),                                'grid': file_name.split('.')[0]                                })        gdf.crs = self.get_pyproj_crs()        return gdf    def get_tiles(self, width=64, height=64) -> 'RioRaster':        rows, cols = self.get_img_resolution()        offsets = product(range(0, cols, width), range(0, rows, height))        big_window = windows.Window(col_off=0, row_off=0, width=cols, height=rows)        for col_off, row_off in offsets:            window = windows.Window(col_off=col_off, row_off=row_off,                                    width=width, height=height).intersection(big_window)            transform = windows.transform(window, self.get_geo_transform())            tile = self.dataset.read(window=window)            tile_raster = self.raster_from_array(tile, crs=self.get_crs(), g_transform=transform,                                                 nodata_value=self.get_nodata_value())            # print(f"working on tile of {self.get_file_name()[1]} at {window}")            yield tile_raster, col_off, row_off    def get_all_tiles(self):        tiles = []        tile_no = 0        tile_raster: RioRaster        if self.temp_dir:            for tile_raster in self.get_titles(width=500, height=500):                tile_no += 1                file_name = self.get_file_name()[1].split('.')[0]                tile_name = f"{self.temp_dir}/tiles/{file_name}_{tile_no}.tif"                tile_raster.save_to_file(tile_name)                tiles.append(tile_name)            return tiles        else:            da_logger.critical("Please set temp folder path first using set_temp_folder")    @staticmethod    def reverse_band_row_col(data: np.ndarray):        return np.moveaxis(data, 0, 2)    def save_temp_file(self, postfix: str):        if self.temp_dir:            img_name = self.get_file_name()[1].split('.')[0]            img_des = os.path.join(self.temp_dir, f"{img_name}_{postfix}.tif")            print(img_des)            self.save_to_file(img_des)        else:            da_logger.critical("Please set temp folder path first using set_temp_folder")    def resample_raster_spatial_res(self, ref_raster: 'RioRaster', resampling_method_index=0, in_place=True):        """        :param des_resolution:  must in unit of  crs or srs        :param resampling_method_index:        :param in_place:        :return:        """        des_res = ref_raster.get_spatial_resoultion()        self_res = self.get_spatial_resoultion()        width = round(self.get_width() * self_res[0] / des_res[0], 0)        height = round(self.get_height() * self_res[1] / des_res[1], 0)        return self.resample_raster(width, height, resampling_method_index, in_place)    def resample_raster(self, width, height, resampling_method_index=1, in_place=True) -> DatasetReader:        # resampling_method = [Resampling.nearest, Resampling.bilinear, Resampling.cubic, Resampling.lanczos, Resampling.average]        bands = self.dataset.count        data = self.dataset.read(            out_shape=(                bands,                int(height),                int(width)            ),            resampling=self.resampling_method[resampling_method_index]        )        geo_transform = self.dataset.transform * self.dataset.transform.scale(            (self.dataset.width / data.shape[-1]),            (self.dataset.height / data.shape[-2])        )        kwargs = self.dataset.meta.copy()        kwargs.update({            'transform': geo_transform,            'width': data.shape[-1],            'height': data.shape[-2]        })        memfile = MemoryFile()        dst = memfile.open(**kwargs)        for i in range(bands):            d = data if len(data.shape) == 2 else data[i, :, :]            dst.write(d, i + 1)        dst.close()        if in_place:            self.dataset = memfile.open()        else:            return memfile.open()  # Reopen as DatasetReader    def reproject_raster(self, des_crs: pyproj.CRS = None, width=None, height=None, in_place=True,                         resampling_method_index=0):        dst_crs = rasterio.crs.CRS.from_wkt(des_crs.to_wkt())        dst_crs = self.get_crs() if dst_crs is None else dst_crs        width = self.get_width() if width is None else width        height = self.get_height() if height is None else height        g_trans, width, height = calculate_default_transform(self.get_crs(), dst_crs, width,                                                             height, *self.get_raster_extent())        kwargs = self.get_metadata_copy()        kwargs.update({            'crs': dst_crs,            'transform': g_trans,            'width': width,            'height': height        })        memfile = MemoryFile()        dst = memfile.open(**kwargs)        for i in range(1, self.dataset.count + 1):            reproject(                source=rasterio.band(self.dataset, i),                destination=rasterio.band(dst, i),                src_transform=self.get_geo_transform(),                src_crs=self.get_crs(),                dst_transform=transform,                dst_crs=dst_crs,                resampling=self.resampling_method[resampling_method_index])        dst.close()        if in_place:            self.dataset = memfile.open()        else:            return memfile.open()    def clip_raster(self, aoi: Union[gpd.GeoDataFrame, shapely.geometry.Polygon, shapely.geometry.MultiPolygon],                    in_place=True, crs=0) -> 'RioRaster':        """        clip raster based on aoi        :param aoi: shapely polygon geometry        :param in_place: boolean        :param crs        :return: RioRaster        """        if isinstance(aoi, shapely.geometry.Polygon) or isinstance(aoi, shapely.geometry.MultiPolygon):            aoi = gpd.GeoDataFrame(geometry=[aoi], crs=crs)        if str(aoi.crs).lower() != str(self.get_crs()).lower():            geo = aoi.to_crs(self.get_crs())        else:            geo = aoi        geom_col = GPDVector.get_geometry_column_name(geo)        # Convert the geometries into the format expected by rasterio.mask.mask        geometries = [feature[geom_col] for _, feature in geo.iterrows()]        nodata = self.get_nodata_value() if self.get_nodata_value() is not None else 0        # Clip the raster with the polygon        out_img, out_transform = mask(self.dataset, geometries, crop=True, nodata=nodata)        out_meta = self.dataset.meta.copy()        out_meta.update({"driver": "GTiff",                         "height": out_img.shape[1],                         "width": out_img.shape[2],                         "transform": out_transform,                         "nodata": nodata,                         "crs": self.dataset.crs})        descriptions = self.dataset.descriptions        if in_place:            self.dataset = self.rio_dataset_from_array(out_img, out_meta, descriptions)        else:            return RioRaster(self.rio_dataset_from_array(out_img, out_meta, descriptions))    def pad_raster(self, des_raster):        """        clip or pad raster to mak align with bounds        :param des_raster:        :return:        """        # bounds = self.get_spectral_resolution()        # ulx = gt[0] - gt[1] * npad        # uly = gt[3] - gt[5] * npad        aff: Affine = self.get_geo_transform()        des_bounds = des_raster.get_total_bounds()        rows, cols = rasterio.transform.rowcol(aff, xs=[des_bounds[0], des_bounds[2]],                                               ys=[des_bounds[3], des_bounds[1]])        height = rows[1] - rows[0]        width = cols[1] - cols[0]        window = windows.Window(col_off=cols[0], row_off=rows[0],                                width=width, height=height)  # .intersection(big_window)        window_transform = windows.transform(window, self.get_geo_transform())        kwargs = self.dataset.meta.copy()        kwargs.update({            'crs': self.get_crs(),            'transform': window_transform,            'width': width,            'height': height        })        memfile = MemoryFile()        dst = memfile.open(**kwargs)        # for i in range(bands):        #     # tile = self.dataset.read()        data = self.dataset.read(window=window, boundless=False, fill_value=self.dataset.nodata)        dst.write(data)        dst.close()        self.dataset = memfile.open()    def get_dataset_under_envelop(self, envelop: Union[Polygon, gpd.GeoDataFrame], ref_raster: 'RioRaster' = None,                                  in_place=True) -> DatasetReader:        if isinstance(envelop, Polygon):            des_bounds = envelop.bounds        else:            # if str(self.get_crs()).lower() != str(envelop.crs).lower():            if self.get_crs().to_epsg() != envelop.crs.to_epsg():                envelop.to_crs(self.get_crs())            des_bounds = tuple(envelop.bounds.values[0])        aff = self.get_geo_transform()        rows, cols = rasterio.transform.rowcol(aff, xs=[des_bounds[0], des_bounds[2]],                                               ys=[des_bounds[3], des_bounds[1]])        if ref_raster is None:            height = abs(rows[0] - rows[1])            width = abs(cols[0] - cols[1])        else:            img_res = ref_raster.get_img_resolution()            height = img_res[0]            width = img_res[1]        window = windows.Window(col_off=cols[0], row_off=rows[0], width=width,                                height=height)  # .intersection(big_window)        window_transform = windows.transform(window, self.get_geo_transform())        data = self.dataset.read(window=window, boundless=True, fill_value=self.dataset.nodata)        kwargs = self.dataset.meta.copy()        kwargs.update({            'transform': window_transform,            'width': width,            'height': height        })        dataset = self.rio_dataset_from_array(data, kwargs)        if in_place:            self.dataset = dataset        else:            return dataset    def reclassify_raster(self, thresholds, band=None, nodata=0) -> np.ndarray:        """        :param thresholds:            example:  {                    "water": (('lt', 0.015), 4),                    "built-up": ((0.015, 0.02), 1),                    "barren": ((0.07, 0.27), 2),                    "vegetation": (('gt', 0.27), 3)                }        :param band:            band no        :return:        """        nodata = self.get_nodata_value() if self.get_nodata_value() is not None and self.get_nodata_value() != nodata else nodata        no_of_bands = self.get_spectral_resolution()        res = []        for band_no in range(no_of_bands):            img_arr = self.get_data_array(band_no + 1)            img_arr = np.squeeze(img_arr)            classified_data = BandProcess.reclassify_band(img_arr, thresholds, nodata)            res.append(classified_data)        res = np.stack(res, axis=0)        return res.astype(np.uint8)    def make_coincident_with(self, des_raster: 'RioRaster', resampling_method_index=0):        """        des_raster : RioRaster        resampling_method_index : int        [Resampling.nearest, Resampling.bilinear, Resampling.cubic, Resampling.lanczos,                                  Resampling.average, Resampling.cubic_spline]        """        if not self.is_image_crs_same(des_raster):            self.reproject_raster(des_raster.get_crs(), resampling_method_index=resampling_method_index)        if not self.is_spatial_resolution_same(des_raster):            self.resample_raster_spatial_res(des_raster)        des_bbox = des_raster.get_envelop()        src_bbox = self.get_envelop()        # envelop = des_bbox.intersection(src_bbox)        # crs = self.get_crs()        # envelop = gpd.GeoDataFrame({'geometry': envelop}, index=[0], crs=crs)        if not des_bbox.equals(src_bbox):            self.get_dataset_under_envelop(des_bbox, des_raster)        if not self.is_image_resolution_same(des_raster):            width = des_raster.get_width()            height = des_raster.get_height()            self.resample_raster(width, height, resampling_method_index=resampling_method_index)    @staticmethod    def rio_dataset_from_array(data: np.ndarray, meta, descriptions: list = None) -> DatasetReader:        """        :param data: band data in np.ndarray        :param meta: metadata        :param descriptions: list of band names can get throught self.dataset.descriptions        :return:        """        bands = 1 if len(data.shape) == 2 else data.shape[0]        memfile = MemoryFile()        dst = memfile.open(**meta)        for i in range(bands):            d = data if len(data.shape) == 2 else data[i, :, :]            dst.write(d, i + 1)        if descriptions is not None:            dst.descriptions = descriptions        dst.close()        dataset = memfile.open()  # Reopen as DatasetReader        return dataset    def change_datatype(self, new_dtype: np.dtype = "float32"):        data = self.get_data_array()        # band, *_ = data.shape        # for b in range(band):        #     data[b] = data[b].astype(new_dtype)        out_meta = self.dataset.meta.copy()        out_meta.update({"nodata": self.get_nodata_value(),                         "dtype": new_dtype})        self.dataset = self.rio_dataset_from_array(data, out_meta)    def add_nodata_value(self, val):        out_meta = self.dataset.meta.copy()        out_meta.update({"nodata": val})        data = self.get_data_array()        self.dataset = self.rio_dataset_from_array(data, out_meta)    def get_x_y_value_raster(self, in_lat_long=False) -> (np.ndarray, np.ndarray):        """        This function retrieves information about the X and Y raster        :return: lat and lon raster        """        rows, cols = self.get_img_resolution()        if in_lat_long and self.get_raster_srid() != 4326:            geo_t, width, height = calculate_default_transform(self.get_crs(), CRS.from_epsg(4326),                                                               self.get_width(), self.get_height(),                                                               *self.get_raster_extent())        else:            geo_t = self.get_geo_transform()        X = np.zeros((rows, cols))        Y = np.zeros((rows, cols))        # tim way of doing it        # for col in np.arange(cols):        #     # lon[:, col] = geo_t[0] + col * geo_t[1] + geo_t[1] / 2        #     lon[:, col] = geo_t[2] + col * geo_t[0] + geo_t[0] / 2        #     # ULx + col*(E-W pixel spacing) + E-W pixel spacing        # for row in np.arange(rows):        #     # lat[row, :] = geo_t[3] + row * geo_t[5] + geo_t[5] / 2        #     lat[row, :] = geo_t[5] + row * geo_t[4] + geo_t[4] / 2        # return lat, lon        for i in np.arange(cols):            for j in np.arange(i, rows):                Y[j, :] = i * geo_t[3] + j * geo_t[4] + geo_t[5]                break            X[:, i] = i * geo_t[0] + j * geo_t[1] + geo_t[2]        return X, Y    def calculate_spatial_resolution_in_meter(self):        """        This functions calculated the distance between each pixel in meter.        Returns        -------        dlat: array            Array containing the vertical distance between each pixel in meters        dlon: array            Array containing the horizontal distance between each pixel in meters        """        geo_out = self.get_geo_transform()        size_Y, size_X = self.get_img_resolution()        # Create the lat/lon rasters        # lon = np.arange(size_X + 1) * geo_out[1] + geo_out[0] - 0.5 * geo_out[1]        # lat = np.arange(size_Y + 1) * geo_out[5] + geo_out[3] - 0.5 * geo_out[5]        lon = np.arange(size_X + 1) * geo_out[0] + geo_out[2] - 0.5 * geo_out[0]        lat = np.arange(size_Y + 1) * geo_out[4] + geo_out[5] - 0.5 * geo_out[4]        dlat_2d = np.array([lat, ] * int(np.size(lon, 0))).transpose()        dlon_2d = np.array([lon, ] * int(np.size(lat, 0)))        # Radius of the earth in meters        R_earth = 6371000        # Calculate the lat and lon in radians        lonRad = dlon_2d * np.pi / 180        latRad = dlat_2d * np.pi / 180        # Calculate the difference in lat and lon        lonRad_dif = abs(lonRad[:, 1:] - lonRad[:, :-1])        latRad_dif = abs(latRad[:-1] - latRad[1:])        # Calculate the distance between the upper and lower pixel edge        a = np.sin(latRad_dif[:, :-1] / 2) * np.sin(latRad_dif[:, :-1] / 2)        clat = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))        dlat = R_earth * clat        # Calculate the distance between the eastern and western pixel edge        b = np.cos(latRad[1:, :-1]) * np.cos(latRad[:-1, :-1]) * np.sin(lonRad_dif[:-1, :] / 2) * np.sin(            lonRad_dif[:-1, :] / 2)        clon = 2 * np.arctan2(np.sqrt(b), np.sqrt(1 - b));        dlon = R_earth * clon        return dlon, dlat    def transform_to_metric_unit_projections(self, in_place=False):        if self.get_pyproj_crs().to_epsg() == 4326:            gt = self.get_geo_transform()            utm_srid = GeodesyOps.utm_srid_from_coord(gt[2], gt[5])            temp_rio_ds = self.reproject_raster(CRS.from_epsg(utm_srid), in_place=False)        else:            temp_rio_ds = self.get_dataset()        if in_place:            self.dataset = temp_rio_ds        else:            return temp_rio_ds    def get_pixel_value(self, x: float, y: float):        row, col = self.dataset.index(x, y)        values = []        # Loop through each band in the raster        for band in range(1, self.dataset.count + 1):            # Read the current band            data = self.dataset.read(band)            # Append the value at the specified row, col to the list            values.append(data[row, col])        return values    def get_pixel_area_band(self):        temp_rio_ds = self.transform_to_metric_unit_projections()        cols = temp_rio_ds.profile.data['width']        rows = temp_rio_ds.profile.data['height']        geo = temp_rio_ds.profile.data['transform']        # geo 0 and 4 index are scaling factor of x and y respectively        return np.ones((rows, cols)) * geo[0] * geo[4]    @staticmethod    def get_s3_session(aws_access_key_id, aws_secret_access_key, region_name):        return Session(aws_access_key_id, aws_secret_access_key, region_name)    def upload_to_s3(self, img_des: str, session: Session):        self.write_to_file(img_des, self.get_data_array(), self.get_crs(),                           self.get_geo_transform(), self.get_nodata_value(), session)    def get_band_name(self, band_no: int):        """        get name from discription        :param band_no:        :return:        """        if self.dataset.descriptions and len(self.dataset.descriptions) >= band_no:            return self.dataset.descriptions[band_no]    def get_band_summaries(self) -> pd.DataFrame:        """        :return: summaries of all bands        """        summaries = {}        for i in range(self.get_spectral_resolution()):            band_name = self.get_band_name(i)            data = self.get_data_array(i)            no_data = self.get_nodata_value()            summary = BandProcess.get_summary_data(data, nodata=no_data)            summaries[band_name] = summary        df = pd.DataFrame(summaries).T  # T is for transpose        return df    def get_raster_aoi(self, band_number: int, mask_value: float = None) -> gpd.GeoDataFrame:        """            Extract polygons from a specific band of a raster file that are not 'no data' or a specific mask value.            :param band_number: Band number to process.            :param mask_value: Value to mask out. If None, use the 'no data' value of the band.            :return: List of Shapely polygons.        """        polygons = []        band = self.get_data_array(band_number)        if mask_value is None:            mask_value = self.get_nodata_value_of_band(band_number)        # Create a binary mask: 1 for areas of interest, 0 for areas to mask out        binary_mask = np.where((band != mask_value) & (~np.isnan(band)), 1, 0)        # Extract shapes from the binary mask        shapes_and_values = shapes(binary_mask.astype(np.uint8), transform=self.get_geo_transform())        polygons = [shape(geom) for geom, value in shapes_and_values if value == 1 and not shape(geom).is_empty]        # Convert the list of polygons to a GeoDataFrame        gdf = gpd.GeoDataFrame(geometry=polygons, crs=self.get_crs())        return gdf