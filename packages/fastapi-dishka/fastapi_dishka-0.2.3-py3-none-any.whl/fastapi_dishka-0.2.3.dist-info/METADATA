Metadata-Version: 2.4
Name: fastapi_dishka
Version: 0.2.3
Summary: FastAPI + Dishka with providers being first-class citizens
Author-email: NSX Team <heynemann@gmail.com>
License: MIT
Project-URL: Homepage, https://github.com/NSXBet/fastapi-dishka
Project-URL: Bug Reports, https://github.com/NSXBet/fastapi-dishka/issues
Project-URL: Source, https://github.com/NSXBet/fastapi-dishka
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Typing :: Typed
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.13
Classifier: Framework :: AsyncIO
Classifier: Framework :: FastAPI
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.13
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: dishka>=1.3.0
Requires-Dist: fastapi>=0.115.6
Requires-Dist: uvicorn>=0.32.0
Requires-Dist: structlog>=24.1.0
Provides-Extra: dev
Requires-Dist: pytest>=7.4.0; extra == "dev"
Requires-Dist: pytest-mock>=3.12.0; extra == "dev"
Requires-Dist: pytest-cov>=4.1.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.21.0; extra == "dev"
Requires-Dist: httpx>=0.24.0; extra == "dev"
Requires-Dist: black>=25.1.0; extra == "dev"
Requires-Dist: isort>=6.0.1; extra == "dev"
Requires-Dist: flake8>=6.1.0; extra == "dev"
Requires-Dist: pyproject-flake8>=7.0.0; extra == "dev"
Requires-Dist: mypy>=1.16.1; extra == "dev"
Requires-Dist: mkdocs-material>=9.4.0; extra == "dev"
Requires-Dist: mkdocstrings[python]>=0.24.0; extra == "dev"
Requires-Dist: ruff>=0.12.0; extra == "dev"
Dynamic: license-file

# ğŸš€ fastapi-dishka

[![PyPI - Version](https://img.shields.io/pypi/v/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![PyPI - Wheel](https://img.shields.io/pypi/wheel/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![PyPI - Status](https://img.shields.io/pypi/status/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![PyPI - License](https://img.shields.io/pypi/l/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![PyPI - Downloads](https://img.shields.io/pypi/dm/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![PyPI - Format](https://img.shields.io/pypi/format/fastapi_dishka)](https://pypi.org/project/fastapi-dishka/)
[![codecov](https://codecov.io/gh/NSXBet/fastapi-dishka/graph/badge.svg?token=83VQ7PMJ1L)](https://codecov.io/gh/NSXBet/fastapi-dishka)
[![Python 3.13+](https://img.shields.io/badge/python-3.13+-blue.svg)](https://www.python.org/downloads/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.68+-00a393.svg)](https://fastapi.tiangolo.com/)

> ğŸ½ï¸ **Serve your FastAPI dependencies with style!** A delightful integration between FastAPI and Dishka that makes dependency injection feel like a five-star dining experience.

## âœ¨ What is this magic?

**fastapi-dishka** bridges the gap between [FastAPI](https://fastapi.tiangolo.com/) and [Dishka](https://github.com/reagento/dishka), bringing you:

- ğŸ”„ **Auto-registration** - Routers and middleware register themselves like magic
- ğŸ¯ **Provider-first design** - Your providers are first-class citizens
- ğŸ§© **Seamless integration** - Works with existing FastAPI and Dishka code
- ğŸš€ **Zero boilerplate** - Less setup, more building awesome stuff
- ğŸ”’ **Type-safe** - Full type hints and mypy support
- âš¡ **High performance** - Built on FastAPI and Dishka's solid foundations

## ğŸ› ï¸ Installation

Get started in seconds:

```bash
pip install fastapi-dishka
```

Or if you're feeling fancy with poetry:

```bash
poetry add fastapi-dishka
```

## ğŸ¬ Quick Start

Here's how easy it is to get rolling:

```python
from dishka import Scope, provide, FromDishka
from fastapi_dishka import App, APIRouter, provide_router, Provider

# ğŸ“¦ Create your service
class GreetingService:
    def greet(self, name: str) -> str:
        return f"Hello, {name}! ğŸ‘‹"

# ğŸ›£ï¸ Create your router
router = APIRouter(prefix="/api")

@router.get("/greet/{name}")
async def greet_endpoint(name: str, service: FromDishka[GreetingService]) -> dict:
    return {"message": service.greet(name)}

# ğŸ­ Create your provider
class AppProvider(Provider):
    scope = Scope.APP

    # ğŸ¯ Auto-register the router
    greeting_router = provide_router(router)

    # ğŸ“‹ Provide your services
    greeting_service = provide(GreetingService, scope=Scope.APP)

# ğŸš€ Launch your app
app = App("My Awesome API", "1.0.0", AppProvider())

if __name__ == "__main__":
    app.start_sync()  # ğŸ”¥ Your API is now running!
```

That's it! Your API is running with auto-registered routes and dependency injection. ğŸ‰

## ğŸ­ Features & Examples

### ğŸ”„ Auto-Router Registration

Say goodbye to manually registering every router:

```python
from fastapi_dishka import provide_router, Provider

class MyProvider(Provider):
    # âœ¨ These routers register themselves automatically
    users_router = provide_router(users_router)
    posts_router = provide_router(posts_router)
    comments_router = provide_router(comments_router)
```

### ğŸ›¡ï¸ Middleware with Dependency Injection

Create powerful middleware that can inject dependencies:

```python
from fastapi_dishka import Middleware, provide_middleware, Provider

class AuthMiddleware(Middleware):
    async def dispatch(self, request, call_next):
        # ğŸ’‰ Inject services right into your middleware!
        auth_service = await self.get_dependency(request, AuthService)

        if not auth_service.is_authenticated(request):
            return JSONResponse({"error": "Unauthorized"}, status_code=401)

        return await call_next(request)

class SecurityProvider(Provider):
    scope = Scope.APP
    auth_service = provide(AuthService, scope=Scope.APP)

    # ğŸ›¡ï¸ Auto-register middleware with DI support
    auth_middleware = provide_middleware(AuthMiddleware)
```

### ğŸ—ï¸ Multiple Providers

Organize your code with multiple providers:

```python
from fastapi_dishka import Provider

# ğŸ‘¤ User-related stuff
class UserProvider(Provider):
    scope = Scope.APP
    user_router = provide_router(user_router)
    user_service = provide(UserService, scope=Scope.APP)

# ğŸ“ Post-related stuff
class PostProvider(Provider):
    scope = Scope.APP
    post_router = provide_router(post_router)
    post_service = provide(PostService, scope=Scope.APP)

# ğŸš€ Combine them all
app = App("Blog API", "2.0.0", UserProvider(), PostProvider())
```

### ğŸŒ Server Management

Full control over your server lifecycle:

```python
# ğŸ”¥ Blocking mode (great for production)
app.start_sync(host="0.0.0.0", port=8080)

# ğŸ§µ Non-blocking mode (perfect for testing)
app.start_sync(blocking=False, port=8081)
# ... do other stuff ...
app.stop()  # ğŸ›‘ Graceful shutdown

# âš¡ Async mode
await app.start(host="127.0.0.1", port=8082)
```

## ğŸ—ï¸ Architecture

**fastapi-dishka** follows a provider-first design:

```
ğŸ“¦ Your App
â”œâ”€â”€ ğŸ­ Providers (define what you have)
â”‚   â”œâ”€â”€ ğŸ›£ï¸  Router providers (auto-register routes)
â”‚   â”œâ”€â”€ ğŸ›¡ï¸  Middleware providers (auto-register middleware)
â”‚   â””â”€â”€ ğŸ“‹ Service providers (your business logic)
â”œâ”€â”€ ğŸ”„ Auto-registration (happens magically)
â””â”€â”€ ğŸš€ FastAPI App (ready to serve)
```

## ğŸ›ï¸ Provider Options

**fastapi-dishka** gives you flexibility in how you define your providers. You have two options:

### Option 1: Use fastapi-dishka Provider (Recommended)

```python
from fastapi_dishka import Provider

class MyProvider(Provider):
    scope = Scope.APP
    # Your provider methods here...
```

This is the recommended approach as it's specifically designed for fastapi-dishka integration.

### Option 2: Use dishka Provider with fastapi-dishka metaclass

```python
from dishka import Provider
from fastapi_dishka import FastAPIDishkaProviderMeta

class MyProvider(Provider, metaclass=FastAPIDishkaProviderMeta):
    scope = Scope.APP
    # Your provider methods here...
```

This approach allows you to use dishka's Provider directly while still getting fastapi-dishka's auto-registration features through the metaclass.

Both approaches provide the same functionality - choose the one that fits your project's needs! ğŸ¯

## ğŸ§ª Testing

Testing is a breeze with multiple patterns and full async support! Let's start with the classic hello world test:

```python
import pytest
from fastapi.testclient import TestClient
from dishka import Scope, provide, FromDishka
from fastapi_dishka import App, APIRouter, provide_router, start_test, stop_test, test, Provider

class GreetingService:
    def greet(self, name: str) -> str:
        return f"Hello, {name}! ğŸ‘‹"

hello_router = APIRouter()

@hello_router.get("/hello/{name}")
async def hello_endpoint(name: str, service: FromDishka[GreetingService]) -> dict:
    return {"message": service.greet(name)}

class HelloProvider(Provider):
    scope = Scope.APP
    greeting_router = provide_router(hello_router)
    greeting_service = provide(GreetingService, scope=Scope.APP)
```

### ğŸ¯ Pattern 1: Context Manager (Recommended!)

The cleanest and most convenient way to test:

```python
@pytest.mark.asyncio
async def test_hello_world_with_context_manager():
    """The cleanest way to test - using the context manager! ğŸ¯"""
    app = App("Hello World API", "1.0.0", HelloProvider())

    # ğŸ¯ Ultra-clean testing with context manager
    async with test(app) as test_app:
        client = TestClient(test_app.app)
        response = client.get("/hello/World")

        assert response.status_code == 200
        data = response.json()
        assert data["message"] == "Hello, World! ğŸ‘‹"
    # ğŸ§¹ Cleanup happens automatically!
```

### ğŸ”§ Pattern 2: Manual Start/Stop

For more control over the server lifecycle:

```python
@pytest.mark.asyncio
async def test_hello_world():
    """Manual server management with start_test/stop_test."""
    app = App("Hello World API", "1.0.0", HelloProvider())

    try:
        # ğŸš€ Use start_test() for clean async server startup
        await start_test(app, port=9999)

        client = TestClient(app.app)
        response = client.get("/hello/World")

        assert response.status_code == 200
        data = response.json()
        assert data["message"] == "Hello, World! ğŸ‘‹"
    finally:
        # ğŸ§¹ Use stop_test() for clean async server shutdown
        await stop_test(app)
```

### ğŸ­ Which Pattern to Choose?

- **ğŸ¯ Context Manager**: Perfect for most tests, cleanest syntax, automatic cleanup
- **ğŸ”§ Start/Stop**: Use when you need custom server lifecycle management or multiple test phases

Both patterns handle provider reuse correctly, so you can use the same providers across multiple tests! ğŸ‰

## ğŸ¤ Contributing

We love contributions! Here's how to get started:

### ğŸš€ Quick Setup

```bash
# ğŸ“¥ Clone the repo
git clone https://github.com/NSXBet/fastapi-dishka.git
cd fastapi-dishka

# ğŸ Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate

# ğŸ“¦ Install dependencies
pip install -e ".[dev]"
```

### ğŸ§ª Running Tests

We maintain 90%+ test coverage (we're a bit obsessed ğŸ˜…):

```bash
# ğŸƒâ€â™‚ï¸ Run all tests
make test

# ğŸ“Š Check coverage
make coverage

# ğŸ” Lint your code
make lint

# âœ¨ Format your code
make format
```

### ğŸ¯ Development Standards

- âœ… **Type Safety**: We love type hints and use mypy
- ğŸ§ª **Test Coverage**: Keep it above 90%
- ğŸ“š **Documentation**: Update docs for new features
- ğŸ¨ **Code Style**: We use ruff and flake8
- ğŸš€ **Provider-First**: Make providers first-class citizens

### ğŸ’¡ Ideas for Contributions

- ğŸ”Œ Additional integrations (SQLAlchemy, Redis, etc.)
- ğŸ“š More examples and tutorials
- ğŸ› Bug fixes and performance improvements
- ğŸ“– Documentation improvements
- ğŸ§ª More test coverage (can we hit 99%? ğŸ˜)

## ğŸ› Issues & Questions

Found a bug? Have a question? Want to suggest a feature?

- ğŸ› [Report bugs](https://github.com/NSXBet/fastapi-dishka/issues/new?labels=bug)
- ğŸ’¡ [Request features](https://github.com/NSXBet/fastapi-dishka/issues/new?labels=enhancement)
- â“ [Ask questions](https://github.com/NSXBet/fastapi-dishka/discussions)

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- ğŸš€ [FastAPI](https://fastapi.tiangolo.com/) - For making APIs fun again
- ğŸ½ï¸ [Dishka](https://github.com/reagento/dishka) - For elegant dependency injection
- â¤ï¸ All our contributors and users

## â­ Show Your Support

If you like this project, please consider giving it a star! It helps others discover fastapi-dishka and motivates us to keep improving it.

---

<div align="center">

**Made with â¤ï¸ and lots of â˜•**

_Happy coding! ğŸš€_

</div>
